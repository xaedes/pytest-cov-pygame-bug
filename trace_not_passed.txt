 --- modulename: test_draw_failing, funcname: <module>
test_draw_failing.py(4): import coverage
 --- modulename: __init__, funcname: <module>
__init__.py(9): """
__init__.py(11): from coverage.version import __version__, __url__, version_info
 --- modulename: version, funcname: <module>
version.py(4): """The version and URL for coverage.py"""
version.py(8): version_info = (4, 0, 3, 'final', 0)
version.py(11): def _make_version(major, minor, micro, releaselevel, serial):
version.py(23): def _make_url(major, minor, micro, releaselevel, serial):
version.py(32): __version__ = _make_version(*version_info)
 --- modulename: version, funcname: _make_version
version.py(13):     assert releaselevel in ['alpha', 'beta', 'candidate', 'final']
version.py(14):     version = "%d.%d" % (major, minor)
version.py(15):     if micro:
version.py(16):         version += ".%d" % (micro,)
version.py(17):     if releaselevel != 'final':
version.py(20):     return version
version.py(33): __url__ = _make_url(*version_info)
 --- modulename: version, funcname: _make_url
version.py(25):     url = "https://coverage.readthedocs.org"
version.py(26):     if releaselevel != 'final':
version.py(29):     return url
__init__.py(13): from coverage.control import Coverage, process_startup
 --- modulename: control, funcname: <module>
control.py(4): """Core control stuff for coverage.py."""
control.py(6): import atexit
 --- modulename: atexit, funcname: <module>
atexit.py(6): """
atexit.py(8): __all__ = ["register"]
atexit.py(10): import sys
atexit.py(12): _exithandlers = []
atexit.py(13): def _run_exitfuncs():
atexit.py(37): def register(func, *targs, **kargs):
atexit.py(49): if hasattr(sys, "exitfunc"):
atexit.py(52): sys.exitfunc = _run_exitfuncs
atexit.py(54): if __name__ == "__main__":
control.py(7): import inspect
control.py(8): import os
control.py(9): import platform
 --- modulename: platform, funcname: <module>
platform.py(10): """
platform.py(114): """
platform.py(116): __version__ = '1.0.7'
platform.py(118): import sys,string,os,re
platform.py(123): try:
platform.py(124):     DEV_NULL = os.devnull
platform.py(137): _libc_search = re.compile(r'(__libc_init)'
 --- modulename: re, funcname: compile
re.py(194):     return _compile(pattern, flags)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(240):         except KeyError:
re.py(241):             pass
re.py(242):     if isinstance(pattern, _pattern_type):
re.py(246):     if not sre_compile.isstring(pattern):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
re.py(248):     try:
re.py(249):         p = sre_compile.compile(pattern, flags)
 --- modulename: sre_compile, funcname: compile
sre_compile.py(570):     if isstring(p):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
sre_compile.py(571):         pattern = p
sre_compile.py(572):         p = sre_parse.parse(p, flags)
 --- modulename: sre_parse, funcname: parse
sre_parse.py(709):     source = Tokenizer(str)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(190):         self.string = string
sre_parse.py(191):         self.index = 0
sre_parse.py(192):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(711):     if pattern is None:
sre_parse.py(712):         pattern = Pattern()
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(68):         self.flags = 0
sre_parse.py(69):         self.open = []
sre_parse.py(70):         self.groups = 1
sre_parse.py(71):         self.groupdict = {}
sre_parse.py(72):         self.lookbehind = 0
sre_parse.py(713):     pattern.flags = flags
sre_parse.py(714):     pattern.str = str
sre_parse.py(716):     p = _parse_sub(source, pattern, 0)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(326):             continue
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(453):                     this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(454):                     if this == "]":
sre_parse.py(460):                     elif this:
sre_parse.py(461):                         if this[0] == "\\":
sre_parse.py(464):                             code2 = LITERAL, ord(this)
sre_parse.py(465):                         if code1[0] != LITERAL or code2[0] != LITERAL:
sre_parse.py(467):                         lo = code1[1]
sre_parse.py(468):                         hi = code2[1]
sre_parse.py(469):                         if hi < lo:
sre_parse.py(471):                         setappend((RANGE, (lo, hi)))
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(495):             elif this == "+":
sre_parse.py(496):                 min, max = 1, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(326):             continue
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(272):         return code
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(495):             elif this == "+":
sre_parse.py(496):                 min, max = 1, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(491):                 min, max = 0, 1
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(273):     code = ESCAPES.get(escape)
sre_parse.py(274):     if code:
sre_parse.py(276):     try:
sre_parse.py(277):         c = escape[1:2]
sre_parse.py(278):         if c == "x":
sre_parse.py(285):         elif c == "0":
sre_parse.py(290):         elif c in DIGITS:
sre_parse.py(311):         if len(escape) == 2:
sre_parse.py(312):             return LITERAL, ord(escape[1])
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(549):                 group = 0
sre_parse.py(551):                 if sourcematch("P"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(600):                 elif sourcematch(":"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(602):                     group = 2
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(670):                     group = None
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(273):     code = ESCAPES.get(escape)
sre_parse.py(274):     if code:
sre_parse.py(276):     try:
sre_parse.py(277):         c = escape[1:2]
sre_parse.py(278):         if c == "x":
sre_parse.py(285):         elif c == "0":
sre_parse.py(290):         elif c in DIGITS:
sre_parse.py(311):         if len(escape) == 2:
sre_parse.py(312):             return LITERAL, ord(escape[1])
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(272):         return code
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(453):                     this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(454):                     if this == "]":
sre_parse.py(460):                     elif this:
sre_parse.py(461):                         if this[0] == "\\":
sre_parse.py(464):                             code2 = LITERAL, ord(this)
sre_parse.py(465):                         if code1[0] != LITERAL or code2[0] != LITERAL:
sre_parse.py(467):                         lo = code1[1]
sre_parse.py(468):                         hi = code2[1]
sre_parse.py(469):                         if hi < lo:
sre_parse.py(471):                         setappend((RANGE, (lo, hi)))
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(493):                 min, max = 0, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(491):                 min, max = 0, 1
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(415):             break # end of pattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(328):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(337):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(338):     subpatternappend = subpattern.append
sre_parse.py(341):     while 1:
sre_parse.py(342):         prefix = None
sre_parse.py(343):         for item in items:
sre_parse.py(344):             if not item:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(346):             if prefix is None:
sre_parse.py(347):                 prefix = item[0]
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(343):         for item in items:
sre_parse.py(344):             if not item:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(346):             if prefix is None:
sre_parse.py(348):             elif item[0] != prefix:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(349):                 break
sre_parse.py(357):         break
sre_parse.py(360):     for item in items:
sre_parse.py(361):         if len(item) != 1 or item[0][0] != LITERAL:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(362):             break
sre_parse.py(373):     subpattern.append((BRANCH, (None, items)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(374):     return subpattern
sre_parse.py(718):     tail = source.get()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(719):     if tail == ")":
sre_parse.py(721):     elif tail:
sre_parse.py(724):     if flags & SRE_FLAG_DEBUG:
sre_parse.py(727):     if not (flags & SRE_FLAG_VERBOSE) and p.pattern.flags & SRE_FLAG_VERBOSE:
sre_parse.py(732):     return p
sre_compile.py(576):     code = _code(p, flags)
 --- modulename: sre_compile, funcname: _code
sre_compile.py(554):     flags = p.pattern.flags | flags
sre_compile.py(555):     code = []
sre_compile.py(558):     _compile_info(code, p, flags)
 --- modulename: sre_compile, funcname: _compile_info
sre_compile.py(437):     lo, hi = pattern.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(160):                 i = MAXREPEAT - 1
sre_parse.py(161):                 j = 0
sre_parse.py(162):                 for av in av[1]:
sre_parse.py(163):                     l, h = av.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(164):                     i = min(i, l)
sre_parse.py(165):                     j = max(j, h)
sre_parse.py(162):                 for av in av[1]:
sre_parse.py(163):                     l, h = av.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(164):                     i = min(i, l)
sre_parse.py(165):                     j = max(j, h)
sre_parse.py(162):                 for av in av[1]:
sre_parse.py(163):                     l, h = av.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(164):                     i = min(i, l)
sre_parse.py(165):                     j = max(j, h)
sre_parse.py(162):                 for av in av[1]:
sre_parse.py(166):                 lo = lo + i
sre_parse.py(167):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_compile.py(438):     if lo == 0:
sre_compile.py(441):     prefix = []
sre_compile.py(442):     prefixappend = prefix.append
sre_compile.py(443):     prefix_skip = 0
sre_compile.py(444):     charset = [] # not used
sre_compile.py(445):     charsetappend = charset.append
sre_compile.py(446):     if not (flags & SRE_FLAG_IGNORECASE):
sre_compile.py(448):         for op, av in pattern.data:
sre_compile.py(449):             if op is LITERAL:
sre_compile.py(453):             elif op is SUBPATTERN and len(av[1]) == 1:
sre_compile.py(460):                 break
sre_compile.py(462):         if not prefix and pattern.data:
sre_compile.py(463):             op, av = pattern.data[0]
sre_compile.py(464):             if op is SUBPATTERN and av[1]:
sre_compile.py(481):             elif op is BRANCH:
sre_compile.py(482):                 c = []
sre_compile.py(483):                 cappend = c.append
sre_compile.py(484):                 for p in av[1]:
sre_compile.py(485):                     if not p:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_compile.py(487):                     op, av = p[0]
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(488):                     if op is LITERAL:
sre_compile.py(491):                         break
sre_compile.py(501):     emit = code.append
sre_compile.py(502):     emit(OPCODES[INFO])
sre_compile.py(503):     skip = len(code); emit(0)
sre_compile.py(505):     mask = 0
sre_compile.py(506):     if prefix:
sre_compile.py(510):     elif charset:
sre_compile.py(512):     emit(mask)
sre_compile.py(514):     if lo < MAXCODE:
sre_compile.py(515):         emit(lo)
sre_compile.py(519):     if hi < MAXCODE:
sre_compile.py(522):         emit(0)
sre_compile.py(524):     if prefix:
sre_compile.py(535):     elif charset:
sre_compile.py(537):     code[skip] = len(code) - skip
sre_compile.py(561):     _compile(code, p.data, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(155):         elif op in SUCCESS_CODES:
sre_compile.py(157):         elif op in ASSERT_CODES:
sre_compile.py(170):         elif op is CALL:
sre_compile.py(176):         elif op is AT:
sre_compile.py(185):         elif op is BRANCH:
sre_compile.py(186):             emit(OPCODES[op])
sre_compile.py(187):             tail = []
sre_compile.py(188):             tailappend = tail.append
sre_compile.py(189):             for av in av[1]:
sre_compile.py(190):                 skip = _len(code); emit(0)
sre_compile.py(192):                 _compile(code, av, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(193):                 emit(OPCODES[JUMP])
sre_compile.py(194):                 tailappend(_len(code)); emit(0)
sre_compile.py(195):                 code[skip] = _len(code) - skip
sre_compile.py(189):             for av in av[1]:
sre_compile.py(190):                 skip = _len(code); emit(0)
sre_compile.py(192):                 _compile(code, av, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(274):                     r = range(av[0], av[1]+1)
sre_compile.py(275):                     if fixup:
sre_compile.py(277):                     if fixup and fixes:
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(333):                 out.append((RANGE, (p, q - 1)))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(239):             emit(av[0])
sre_compile.py(240):             emit(av[1])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(193):                 emit(OPCODES[JUMP])
sre_compile.py(194):                 tailappend(_len(code)); emit(0)
sre_compile.py(195):                 code[skip] = _len(code) - skip
sre_compile.py(189):             for av in av[1]:
sre_compile.py(190):                 skip = _len(code); emit(0)
sre_compile.py(192):                 _compile(code, av, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
sre_compile.py(136):                 emit(OPCODES[REPEAT])
sre_compile.py(137):                 skip = _len(code); emit(0)
sre_compile.py(138):                 emit(av[0])
sre_compile.py(139):                 emit(av[1])
sre_compile.py(140):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(141):                 code[skip] = _len(code) - skip
sre_compile.py(142):                 if op is MAX_REPEAT:
sre_compile.py(143):                     emit(OPCODES[MAX_UNTIL])
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
sre_compile.py(136):                 emit(OPCODES[REPEAT])
sre_compile.py(137):                 skip = _len(code); emit(0)
sre_compile.py(138):                 emit(av[0])
sre_compile.py(139):                 emit(av[1])
sre_compile.py(140):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(274):                     r = range(av[0], av[1]+1)
sre_compile.py(275):                     if fixup:
sre_compile.py(277):                     if fixup and fixes:
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(333):                 out.append((RANGE, (p, q - 1)))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(239):             emit(av[0])
sre_compile.py(240):             emit(av[1])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(141):                 code[skip] = _len(code) - skip
sre_compile.py(142):                 if op is MAX_REPEAT:
sre_compile.py(143):                     emit(OPCODES[MAX_UNTIL])
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(193):                 emit(OPCODES[JUMP])
sre_compile.py(194):                 tailappend(_len(code)); emit(0)
sre_compile.py(195):                 code[skip] = _len(code) - skip
sre_compile.py(189):             for av in av[1]:
sre_compile.py(196):             emit(0) # end of branch
sre_compile.py(197):             for tail in tail:
sre_compile.py(198):                 code[tail] = _len(code) - tail
sre_compile.py(197):             for tail in tail:
sre_compile.py(198):                 code[tail] = _len(code) - tail
sre_compile.py(197):             for tail in tail:
sre_compile.py(198):                 code[tail] = _len(code) - tail
sre_compile.py(197):             for tail in tail:
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(563):     code.append(OPCODES[SUCCESS])
sre_compile.py(565):     return code
sre_compile.py(581):     if p.pattern.groups > 100:
sre_compile.py(587):     groupindex = p.pattern.groupdict
sre_compile.py(588):     indexgroup = [None] * p.pattern.groups
sre_compile.py(589):     for k, i in groupindex.items():
sre_compile.py(592):     return _sre.compile(
sre_compile.py(593):         pattern, flags | p.pattern.flags, code,
sre_compile.py(594):         p.pattern.groups-1,
sre_compile.py(595):         groupindex, indexgroup
re.py(252):     if not bypass_cache:
re.py(253):         if len(_cache) >= _MAXCACHE:
re.py(255):         if p.flags & LOCALE:
re.py(260):             loc = None
re.py(261):         _cache[cachekey] = p, loc
re.py(262):     return p
platform.py(143): def libc_ver(executable=sys.executable,lib='',version='',
platform.py(145):              chunksize=2048):
platform.py(196): def _dist_try_harder(distname,version,id):
platform.py(246): _release_filename = re.compile(r'(\w+)[-_](release|version)')
 --- modulename: re, funcname: compile
re.py(194):     return _compile(pattern, flags)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(240):         except KeyError:
re.py(241):             pass
re.py(242):     if isinstance(pattern, _pattern_type):
re.py(246):     if not sre_compile.isstring(pattern):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
re.py(248):     try:
re.py(249):         p = sre_compile.compile(pattern, flags)
 --- modulename: sre_compile, funcname: compile
sre_compile.py(570):     if isstring(p):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
sre_compile.py(571):         pattern = p
sre_compile.py(572):         p = sre_parse.parse(p, flags)
 --- modulename: sre_parse, funcname: parse
sre_parse.py(709):     source = Tokenizer(str)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(190):         self.string = string
sre_parse.py(191):         self.index = 0
sre_parse.py(192):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(711):     if pattern is None:
sre_parse.py(712):         pattern = Pattern()
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(68):         self.flags = 0
sre_parse.py(69):         self.open = []
sre_parse.py(70):         self.groups = 1
sre_parse.py(71):         self.groupdict = {}
sre_parse.py(72):         self.lookbehind = 0
sre_parse.py(713):     pattern.flags = flags
sre_parse.py(714):     pattern.str = str
sre_parse.py(716):     p = _parse_sub(source, pattern, 0)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(272):         return code
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(495):             elif this == "+":
sre_parse.py(496):                 min, max = 1, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(326):             continue
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(337):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(338):     subpatternappend = subpattern.append
sre_parse.py(341):     while 1:
sre_parse.py(342):         prefix = None
sre_parse.py(343):         for item in items:
sre_parse.py(344):             if not item:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(346):             if prefix is None:
sre_parse.py(347):                 prefix = item[0]
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(343):         for item in items:
sre_parse.py(344):             if not item:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(346):             if prefix is None:
sre_parse.py(348):             elif item[0] != prefix:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(349):                 break
sre_parse.py(357):         break
sre_parse.py(360):     for item in items:
sre_parse.py(361):         if len(item) != 1 or item[0][0] != LITERAL:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(362):             break
sre_parse.py(373):     subpattern.append((BRANCH, (None, items)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(374):     return subpattern
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(415):             break # end of pattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(328):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(718):     tail = source.get()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(719):     if tail == ")":
sre_parse.py(721):     elif tail:
sre_parse.py(724):     if flags & SRE_FLAG_DEBUG:
sre_parse.py(727):     if not (flags & SRE_FLAG_VERBOSE) and p.pattern.flags & SRE_FLAG_VERBOSE:
sre_parse.py(732):     return p
sre_compile.py(576):     code = _code(p, flags)
 --- modulename: sre_compile, funcname: _code
sre_compile.py(554):     flags = p.pattern.flags | flags
sre_compile.py(555):     code = []
sre_compile.py(558):     _compile_info(code, p, flags)
 --- modulename: sre_compile, funcname: _compile_info
sre_compile.py(437):     lo, hi = pattern.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(160):                 i = MAXREPEAT - 1
sre_parse.py(161):                 j = 0
sre_parse.py(162):                 for av in av[1]:
sre_parse.py(163):                     l, h = av.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(164):                     i = min(i, l)
sre_parse.py(165):                     j = max(j, h)
sre_parse.py(162):                 for av in av[1]:
sre_parse.py(163):                     l, h = av.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(164):                     i = min(i, l)
sre_parse.py(165):                     j = max(j, h)
sre_parse.py(162):                 for av in av[1]:
sre_parse.py(166):                 lo = lo + i
sre_parse.py(167):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_compile.py(438):     if lo == 0:
sre_compile.py(441):     prefix = []
sre_compile.py(442):     prefixappend = prefix.append
sre_compile.py(443):     prefix_skip = 0
sre_compile.py(444):     charset = [] # not used
sre_compile.py(445):     charsetappend = charset.append
sre_compile.py(446):     if not (flags & SRE_FLAG_IGNORECASE):
sre_compile.py(448):         for op, av in pattern.data:
sre_compile.py(449):             if op is LITERAL:
sre_compile.py(453):             elif op is SUBPATTERN and len(av[1]) == 1:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_compile.py(454):                 op, av = av[1][0]
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(455):                 if op is LITERAL:
sre_compile.py(458):                     break
sre_compile.py(462):         if not prefix and pattern.data:
sre_compile.py(463):             op, av = pattern.data[0]
sre_compile.py(464):             if op is SUBPATTERN and av[1]:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_compile.py(465):                 op, av = av[1][0]
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(466):                 if op is LITERAL:
sre_compile.py(468):                 elif op is BRANCH:
sre_compile.py(501):     emit = code.append
sre_compile.py(502):     emit(OPCODES[INFO])
sre_compile.py(503):     skip = len(code); emit(0)
sre_compile.py(505):     mask = 0
sre_compile.py(506):     if prefix:
sre_compile.py(510):     elif charset:
sre_compile.py(512):     emit(mask)
sre_compile.py(514):     if lo < MAXCODE:
sre_compile.py(515):         emit(lo)
sre_compile.py(519):     if hi < MAXCODE:
sre_compile.py(522):         emit(0)
sre_compile.py(524):     if prefix:
sre_compile.py(535):     elif charset:
sre_compile.py(537):     code[skip] = len(code) - skip
sre_compile.py(561):     _compile(code, p.data, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(155):         elif op in SUCCESS_CODES:
sre_compile.py(157):         elif op in ASSERT_CODES:
sre_compile.py(170):         elif op is CALL:
sre_compile.py(176):         elif op is AT:
sre_compile.py(185):         elif op is BRANCH:
sre_compile.py(186):             emit(OPCODES[op])
sre_compile.py(187):             tail = []
sre_compile.py(188):             tailappend = tail.append
sre_compile.py(189):             for av in av[1]:
sre_compile.py(190):                 skip = _len(code); emit(0)
sre_compile.py(192):                 _compile(code, av, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(193):                 emit(OPCODES[JUMP])
sre_compile.py(194):                 tailappend(_len(code)); emit(0)
sre_compile.py(195):                 code[skip] = _len(code) - skip
sre_compile.py(189):             for av in av[1]:
sre_compile.py(190):                 skip = _len(code); emit(0)
sre_compile.py(192):                 _compile(code, av, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(193):                 emit(OPCODES[JUMP])
sre_compile.py(194):                 tailappend(_len(code)); emit(0)
sre_compile.py(195):                 code[skip] = _len(code) - skip
sre_compile.py(189):             for av in av[1]:
sre_compile.py(196):             emit(0) # end of branch
sre_compile.py(197):             for tail in tail:
sre_compile.py(198):                 code[tail] = _len(code) - tail
sre_compile.py(197):             for tail in tail:
sre_compile.py(198):                 code[tail] = _len(code) - tail
sre_compile.py(197):             for tail in tail:
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(563):     code.append(OPCODES[SUCCESS])
sre_compile.py(565):     return code
sre_compile.py(581):     if p.pattern.groups > 100:
sre_compile.py(587):     groupindex = p.pattern.groupdict
sre_compile.py(588):     indexgroup = [None] * p.pattern.groups
sre_compile.py(589):     for k, i in groupindex.items():
sre_compile.py(592):     return _sre.compile(
sre_compile.py(593):         pattern, flags | p.pattern.flags, code,
sre_compile.py(594):         p.pattern.groups-1,
sre_compile.py(595):         groupindex, indexgroup
re.py(252):     if not bypass_cache:
re.py(253):         if len(_cache) >= _MAXCACHE:
re.py(255):         if p.flags & LOCALE:
re.py(260):             loc = None
re.py(261):         _cache[cachekey] = p, loc
re.py(262):     return p
platform.py(247): _lsb_release_version = re.compile(r'(.+)'
 --- modulename: re, funcname: compile
re.py(194):     return _compile(pattern, flags)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(240):         except KeyError:
re.py(241):             pass
re.py(242):     if isinstance(pattern, _pattern_type):
re.py(246):     if not sre_compile.isstring(pattern):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
re.py(248):     try:
re.py(249):         p = sre_compile.compile(pattern, flags)
 --- modulename: sre_compile, funcname: compile
sre_compile.py(570):     if isstring(p):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
sre_compile.py(571):         pattern = p
sre_compile.py(572):         p = sre_parse.parse(p, flags)
 --- modulename: sre_parse, funcname: parse
sre_parse.py(709):     source = Tokenizer(str)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(190):         self.string = string
sre_parse.py(191):         self.index = 0
sre_parse.py(192):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(711):     if pattern is None:
sre_parse.py(712):         pattern = Pattern()
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(68):         self.flags = 0
sre_parse.py(69):         self.open = []
sre_parse.py(70):         self.groups = 1
sre_parse.py(71):         self.groupdict = {}
sre_parse.py(72):         self.lookbehind = 0
sre_parse.py(713):     pattern.flags = flags
sre_parse.py(714):     pattern.str = str
sre_parse.py(716):     p = _parse_sub(source, pattern, 0)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(542):             subpatternappend((ANY, None))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(495):             elif this == "+":
sre_parse.py(496):                 min, max = 1, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(241):     code = CATEGORIES.get(escape)
sre_parse.py(242):     if code and code[0] == IN:
sre_parse.py(243):         return code
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(476):                         code1 = code1[1][0]
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(495):             elif this == "+":
sre_parse.py(496):                 min, max = 1, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(438):                 setappend((NEGATE, None))
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(483):                 subpatternappend((NOT_LITERAL, set[1][1])) # optimization
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(493):                 min, max = 0, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(549):                 group = 0
sre_parse.py(551):                 if sourcematch("P"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(600):                 elif sourcematch(":"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(602):                     group = 2
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(670):                     group = None
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(273):     code = ESCAPES.get(escape)
sre_parse.py(274):     if code:
sre_parse.py(276):     try:
sre_parse.py(277):         c = escape[1:2]
sre_parse.py(278):         if c == "x":
sre_parse.py(285):         elif c == "0":
sre_parse.py(290):         elif c in DIGITS:
sre_parse.py(311):         if len(escape) == 2:
sre_parse.py(312):             return LITERAL, ord(escape[1])
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(542):             subpatternappend((ANY, None))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(495):             elif this == "+":
sre_parse.py(496):                 min, max = 1, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(273):     code = ESCAPES.get(escape)
sre_parse.py(274):     if code:
sre_parse.py(276):     try:
sre_parse.py(277):         c = escape[1:2]
sre_parse.py(278):         if c == "x":
sre_parse.py(285):         elif c == "0":
sre_parse.py(290):         elif c in DIGITS:
sre_parse.py(311):         if len(escape) == 2:
sre_parse.py(312):             return LITERAL, ord(escape[1])
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(491):                 min, max = 0, 1
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(415):             break # end of pattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(328):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(718):     tail = source.get()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(719):     if tail == ")":
sre_parse.py(721):     elif tail:
sre_parse.py(724):     if flags & SRE_FLAG_DEBUG:
sre_parse.py(727):     if not (flags & SRE_FLAG_VERBOSE) and p.pattern.flags & SRE_FLAG_VERBOSE:
sre_parse.py(732):     return p
sre_compile.py(576):     code = _code(p, flags)
 --- modulename: sre_compile, funcname: _code
sre_compile.py(554):     flags = p.pattern.flags | flags
sre_compile.py(555):     code = []
sre_compile.py(558):     _compile_info(code, p, flags)
 --- modulename: sre_compile, funcname: _compile_info
sre_compile.py(437):     lo, hi = pattern.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_compile.py(438):     if lo == 0:
sre_compile.py(441):     prefix = []
sre_compile.py(442):     prefixappend = prefix.append
sre_compile.py(443):     prefix_skip = 0
sre_compile.py(444):     charset = [] # not used
sre_compile.py(445):     charsetappend = charset.append
sre_compile.py(446):     if not (flags & SRE_FLAG_IGNORECASE):
sre_compile.py(448):         for op, av in pattern.data:
sre_compile.py(449):             if op is LITERAL:
sre_compile.py(453):             elif op is SUBPATTERN and len(av[1]) == 1:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_compile.py(454):                 op, av = av[1][0]
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(455):                 if op is LITERAL:
sre_compile.py(458):                     break
sre_compile.py(462):         if not prefix and pattern.data:
sre_compile.py(463):             op, av = pattern.data[0]
sre_compile.py(464):             if op is SUBPATTERN and av[1]:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_compile.py(465):                 op, av = av[1][0]
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(466):                 if op is LITERAL:
sre_compile.py(468):                 elif op is BRANCH:
sre_compile.py(501):     emit = code.append
sre_compile.py(502):     emit(OPCODES[INFO])
sre_compile.py(503):     skip = len(code); emit(0)
sre_compile.py(505):     mask = 0
sre_compile.py(506):     if prefix:
sre_compile.py(510):     elif charset:
sre_compile.py(512):     emit(mask)
sre_compile.py(514):     if lo < MAXCODE:
sre_compile.py(515):         emit(lo)
sre_compile.py(519):     if hi < MAXCODE:
sre_compile.py(522):         emit(0)
sre_compile.py(524):     if prefix:
sre_compile.py(535):     elif charset:
sre_compile.py(537):     code[skip] = len(code) - skip
sre_compile.py(561):     _compile(code, p.data, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(110):             if flags & SRE_FLAG_DOTALL:
sre_compile.py(113):                 emit(OPCODES[ANY])
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
sre_compile.py(136):                 emit(OPCODES[REPEAT])
sre_compile.py(137):                 skip = _len(code); emit(0)
sre_compile.py(138):                 emit(av[0])
sre_compile.py(139):                 emit(av[1])
sre_compile.py(140):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(110):             if flags & SRE_FLAG_DOTALL:
sre_compile.py(113):                 emit(OPCODES[ANY])
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(141):                 code[skip] = _len(code) - skip
sre_compile.py(142):                 if op is MAX_REPEAT:
sre_compile.py(143):                     emit(OPCODES[MAX_UNTIL])
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(563):     code.append(OPCODES[SUCCESS])
sre_compile.py(565):     return code
sre_compile.py(581):     if p.pattern.groups > 100:
sre_compile.py(587):     groupindex = p.pattern.groupdict
sre_compile.py(588):     indexgroup = [None] * p.pattern.groups
sre_compile.py(589):     for k, i in groupindex.items():
sre_compile.py(592):     return _sre.compile(
sre_compile.py(593):         pattern, flags | p.pattern.flags, code,
sre_compile.py(594):         p.pattern.groups-1,
sre_compile.py(595):         groupindex, indexgroup
re.py(252):     if not bypass_cache:
re.py(253):         if len(_cache) >= _MAXCACHE:
re.py(255):         if p.flags & LOCALE:
re.py(260):             loc = None
re.py(261):         _cache[cachekey] = p, loc
re.py(262):     return p
platform.py(251): _release_version = re.compile(r'([^0-9]+)'
 --- modulename: re, funcname: compile
re.py(194):     return _compile(pattern, flags)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(240):         except KeyError:
re.py(241):             pass
re.py(242):     if isinstance(pattern, _pattern_type):
re.py(246):     if not sre_compile.isstring(pattern):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
re.py(248):     try:
re.py(249):         p = sre_compile.compile(pattern, flags)
 --- modulename: sre_compile, funcname: compile
sre_compile.py(570):     if isstring(p):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
sre_compile.py(571):         pattern = p
sre_compile.py(572):         p = sre_parse.parse(p, flags)
 --- modulename: sre_parse, funcname: parse
sre_parse.py(709):     source = Tokenizer(str)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(190):         self.string = string
sre_parse.py(191):         self.index = 0
sre_parse.py(192):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(711):     if pattern is None:
sre_parse.py(712):         pattern = Pattern()
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(68):         self.flags = 0
sre_parse.py(69):         self.open = []
sre_parse.py(70):         self.groups = 1
sre_parse.py(71):         self.groupdict = {}
sre_parse.py(72):         self.lookbehind = 0
sre_parse.py(713):     pattern.flags = flags
sre_parse.py(714):     pattern.str = str
sre_parse.py(716):     p = _parse_sub(source, pattern, 0)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(438):                 setappend((NEGATE, None))
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(453):                     this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(454):                     if this == "]":
sre_parse.py(460):                     elif this:
sre_parse.py(461):                         if this[0] == "\\":
sre_parse.py(464):                             code2 = LITERAL, ord(this)
sre_parse.py(465):                         if code1[0] != LITERAL or code2[0] != LITERAL:
sre_parse.py(467):                         lo = code1[1]
sre_parse.py(468):                         hi = code2[1]
sre_parse.py(469):                         if hi < lo:
sre_parse.py(471):                         setappend((RANGE, (lo, hi)))
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(495):             elif this == "+":
sre_parse.py(496):                 min, max = 1, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(549):                 group = 0
sre_parse.py(551):                 if sourcematch("P"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(600):                 elif sourcematch(":"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(602):                     group = 2
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(670):                     group = None
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(491):                 min, max = 0, 1
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(241):     code = CATEGORIES.get(escape)
sre_parse.py(242):     if code and code[0] == IN:
sre_parse.py(243):         return code
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(476):                         code1 = code1[1][0]
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(495):             elif this == "+":
sre_parse.py(496):                 min, max = 1, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(438):                 setappend((NEGATE, None))
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(483):                 subpatternappend((NOT_LITERAL, set[1][1])) # optimization
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(493):                 min, max = 0, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(549):                 group = 0
sre_parse.py(551):                 if sourcematch("P"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(600):                 elif sourcematch(":"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(602):                     group = 2
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(670):                     group = None
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(273):     code = ESCAPES.get(escape)
sre_parse.py(274):     if code:
sre_parse.py(276):     try:
sre_parse.py(277):         c = escape[1:2]
sre_parse.py(278):         if c == "x":
sre_parse.py(285):         elif c == "0":
sre_parse.py(290):         elif c in DIGITS:
sre_parse.py(311):         if len(escape) == 2:
sre_parse.py(312):             return LITERAL, ord(escape[1])
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(542):             subpatternappend((ANY, None))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(495):             elif this == "+":
sre_parse.py(496):                 min, max = 1, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(273):     code = ESCAPES.get(escape)
sre_parse.py(274):     if code:
sre_parse.py(276):     try:
sre_parse.py(277):         c = escape[1:2]
sre_parse.py(278):         if c == "x":
sre_parse.py(285):         elif c == "0":
sre_parse.py(290):         elif c in DIGITS:
sre_parse.py(311):         if len(escape) == 2:
sre_parse.py(312):             return LITERAL, ord(escape[1])
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(491):                 min, max = 0, 1
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(415):             break # end of pattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(328):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(718):     tail = source.get()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(719):     if tail == ")":
sre_parse.py(721):     elif tail:
sre_parse.py(724):     if flags & SRE_FLAG_DEBUG:
sre_parse.py(727):     if not (flags & SRE_FLAG_VERBOSE) and p.pattern.flags & SRE_FLAG_VERBOSE:
sre_parse.py(732):     return p
sre_compile.py(576):     code = _code(p, flags)
 --- modulename: sre_compile, funcname: _code
sre_compile.py(554):     flags = p.pattern.flags | flags
sre_compile.py(555):     code = []
sre_compile.py(558):     _compile_info(code, p, flags)
 --- modulename: sre_compile, funcname: _compile_info
sre_compile.py(437):     lo, hi = pattern.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_compile.py(438):     if lo == 0:
sre_compile.py(441):     prefix = []
sre_compile.py(442):     prefixappend = prefix.append
sre_compile.py(443):     prefix_skip = 0
sre_compile.py(444):     charset = [] # not used
sre_compile.py(445):     charsetappend = charset.append
sre_compile.py(446):     if not (flags & SRE_FLAG_IGNORECASE):
sre_compile.py(448):         for op, av in pattern.data:
sre_compile.py(449):             if op is LITERAL:
sre_compile.py(453):             elif op is SUBPATTERN and len(av[1]) == 1:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_compile.py(454):                 op, av = av[1][0]
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(455):                 if op is LITERAL:
sre_compile.py(458):                     break
sre_compile.py(462):         if not prefix and pattern.data:
sre_compile.py(463):             op, av = pattern.data[0]
sre_compile.py(464):             if op is SUBPATTERN and av[1]:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_compile.py(465):                 op, av = av[1][0]
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(466):                 if op is LITERAL:
sre_compile.py(468):                 elif op is BRANCH:
sre_compile.py(501):     emit = code.append
sre_compile.py(502):     emit(OPCODES[INFO])
sre_compile.py(503):     skip = len(code); emit(0)
sre_compile.py(505):     mask = 0
sre_compile.py(506):     if prefix:
sre_compile.py(510):     elif charset:
sre_compile.py(512):     emit(mask)
sre_compile.py(514):     if lo < MAXCODE:
sre_compile.py(515):         emit(lo)
sre_compile.py(519):     if hi < MAXCODE:
sre_compile.py(522):         emit(0)
sre_compile.py(524):     if prefix:
sre_compile.py(535):     elif charset:
sre_compile.py(537):     code[skip] = len(code) - skip
sre_compile.py(561):     _compile(code, p.data, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(287):                     out.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(274):                     r = range(av[0], av[1]+1)
sre_compile.py(275):                     if fixup:
sre_compile.py(277):                     if fixup and fixes:
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(333):                 out.append((RANGE, (p, q - 1)))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(235):             pass
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(239):             emit(av[0])
sre_compile.py(240):             emit(av[1])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
sre_compile.py(136):                 emit(OPCODES[REPEAT])
sre_compile.py(137):                 skip = _len(code); emit(0)
sre_compile.py(138):                 emit(av[0])
sre_compile.py(139):                 emit(av[1])
sre_compile.py(140):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(141):                 code[skip] = _len(code) - skip
sre_compile.py(142):                 if op is MAX_REPEAT:
sre_compile.py(143):                     emit(OPCODES[MAX_UNTIL])
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
sre_compile.py(136):                 emit(OPCODES[REPEAT])
sre_compile.py(137):                 skip = _len(code); emit(0)
sre_compile.py(138):                 emit(av[0])
sre_compile.py(139):                 emit(av[1])
sre_compile.py(140):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(110):             if flags & SRE_FLAG_DOTALL:
sre_compile.py(113):                 emit(OPCODES[ANY])
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(141):                 code[skip] = _len(code) - skip
sre_compile.py(142):                 if op is MAX_REPEAT:
sre_compile.py(143):                     emit(OPCODES[MAX_UNTIL])
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(563):     code.append(OPCODES[SUCCESS])
sre_compile.py(565):     return code
sre_compile.py(581):     if p.pattern.groups > 100:
sre_compile.py(587):     groupindex = p.pattern.groupdict
sre_compile.py(588):     indexgroup = [None] * p.pattern.groups
sre_compile.py(589):     for k, i in groupindex.items():
sre_compile.py(592):     return _sre.compile(
sre_compile.py(593):         pattern, flags | p.pattern.flags, code,
sre_compile.py(594):         p.pattern.groups-1,
sre_compile.py(595):         groupindex, indexgroup
re.py(252):     if not bypass_cache:
re.py(253):         if len(_cache) >= _MAXCACHE:
re.py(255):         if p.flags & LOCALE:
re.py(260):             loc = None
re.py(261):         _cache[cachekey] = p, loc
re.py(262):     return p
platform.py(264):     'UnitedLinux', 'turbolinux', 'Ubuntu')
platform.py(266): def _parse_release_file(firstline):
platform.py(293): _distributor_id_file_re = re.compile("(?:DISTRIB_ID\s*=)\s*(.*)", re.I)
 --- modulename: re, funcname: compile
re.py(194):     return _compile(pattern, flags)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(240):         except KeyError:
re.py(241):             pass
re.py(242):     if isinstance(pattern, _pattern_type):
re.py(246):     if not sre_compile.isstring(pattern):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
re.py(248):     try:
re.py(249):         p = sre_compile.compile(pattern, flags)
 --- modulename: sre_compile, funcname: compile
sre_compile.py(570):     if isstring(p):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
sre_compile.py(571):         pattern = p
sre_compile.py(572):         p = sre_parse.parse(p, flags)
 --- modulename: sre_parse, funcname: parse
sre_parse.py(709):     source = Tokenizer(str)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(190):         self.string = string
sre_parse.py(191):         self.index = 0
sre_parse.py(192):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(711):     if pattern is None:
sre_parse.py(712):         pattern = Pattern()
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(68):         self.flags = 0
sre_parse.py(69):         self.open = []
sre_parse.py(70):         self.groups = 1
sre_parse.py(71):         self.groupdict = {}
sre_parse.py(72):         self.lookbehind = 0
sre_parse.py(713):     pattern.flags = flags
sre_parse.py(714):     pattern.str = str
sre_parse.py(716):     p = _parse_sub(source, pattern, 0)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(549):                 group = 0
sre_parse.py(551):                 if sourcematch("P"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(600):                 elif sourcematch(":"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(602):                     group = 2
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(670):                     group = None
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(272):         return code
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(493):                 min, max = 0, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(272):         return code
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(493):                 min, max = 0, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(542):             subpatternappend((ANY, None))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(493):                 min, max = 0, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(415):             break # end of pattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(328):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(718):     tail = source.get()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(719):     if tail == ")":
sre_parse.py(721):     elif tail:
sre_parse.py(724):     if flags & SRE_FLAG_DEBUG:
sre_parse.py(727):     if not (flags & SRE_FLAG_VERBOSE) and p.pattern.flags & SRE_FLAG_VERBOSE:
sre_parse.py(732):     return p
sre_compile.py(576):     code = _code(p, flags)
 --- modulename: sre_compile, funcname: _code
sre_compile.py(554):     flags = p.pattern.flags | flags
sre_compile.py(555):     code = []
sre_compile.py(558):     _compile_info(code, p, flags)
 --- modulename: sre_compile, funcname: _compile_info
sre_compile.py(437):     lo, hi = pattern.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_compile.py(438):     if lo == 0:
sre_compile.py(441):     prefix = []
sre_compile.py(442):     prefixappend = prefix.append
sre_compile.py(443):     prefix_skip = 0
sre_compile.py(444):     charset = [] # not used
sre_compile.py(445):     charsetappend = charset.append
sre_compile.py(446):     if not (flags & SRE_FLAG_IGNORECASE):
sre_compile.py(501):     emit = code.append
sre_compile.py(502):     emit(OPCODES[INFO])
sre_compile.py(503):     skip = len(code); emit(0)
sre_compile.py(505):     mask = 0
sre_compile.py(506):     if prefix:
sre_compile.py(510):     elif charset:
sre_compile.py(512):     emit(mask)
sre_compile.py(514):     if lo < MAXCODE:
sre_compile.py(515):         emit(lo)
sre_compile.py(519):     if hi < MAXCODE:
sre_compile.py(522):         emit(0)
sre_compile.py(524):     if prefix:
sre_compile.py(535):     elif charset:
sre_compile.py(537):     code[skip] = len(code) - skip
sre_compile.py(561):     _compile(code, p.data, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(73):             not (flags & SRE_FLAG_LOCALE) and
sre_compile.py(74):             flags & SRE_FLAG_UNICODE):
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(73):             not (flags & SRE_FLAG_LOCALE) and
sre_compile.py(74):             flags & SRE_FLAG_UNICODE):
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(81):                 lo = _sre.getlower(av, flags)
sre_compile.py(82):                 if fixes and lo in fixes:
sre_compile.py(93):                     emit(OPCODES[OP_IGNORE[op]])
sre_compile.py(94):                     emit(lo)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(81):                 lo = _sre.getlower(av, flags)
sre_compile.py(82):                 if fixes and lo in fixes:
sre_compile.py(93):                     emit(OPCODES[OP_IGNORE[op]])
sre_compile.py(94):                     emit(lo)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(81):                 lo = _sre.getlower(av, flags)
sre_compile.py(82):                 if fixes and lo in fixes:
sre_compile.py(93):                     emit(OPCODES[OP_IGNORE[op]])
sre_compile.py(94):                     emit(lo)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(81):                 lo = _sre.getlower(av, flags)
sre_compile.py(82):                 if fixes and lo in fixes:
sre_compile.py(93):                     emit(OPCODES[OP_IGNORE[op]])
sre_compile.py(94):                     emit(lo)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(81):                 lo = _sre.getlower(av, flags)
sre_compile.py(82):                 if fixes and lo in fixes:
sre_compile.py(93):                     emit(OPCODES[OP_IGNORE[op]])
sre_compile.py(94):                     emit(lo)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(81):                 lo = _sre.getlower(av, flags)
sre_compile.py(82):                 if fixes and lo in fixes:
sre_compile.py(93):                     emit(OPCODES[OP_IGNORE[op]])
sre_compile.py(94):                     emit(lo)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(81):                 lo = _sre.getlower(av, flags)
sre_compile.py(82):                 if fixes and lo in fixes:
sre_compile.py(93):                     emit(OPCODES[OP_IGNORE[op]])
sre_compile.py(94):                     emit(lo)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(81):                 lo = _sre.getlower(av, flags)
sre_compile.py(82):                 if fixes and lo in fixes:
sre_compile.py(93):                     emit(OPCODES[OP_IGNORE[op]])
sre_compile.py(94):                     emit(lo)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(81):                 lo = _sre.getlower(av, flags)
sre_compile.py(82):                 if fixes and lo in fixes:
sre_compile.py(93):                     emit(OPCODES[OP_IGNORE[op]])
sre_compile.py(94):                     emit(lo)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(81):                 lo = _sre.getlower(av, flags)
sre_compile.py(82):                 if fixes and lo in fixes:
sre_compile.py(93):                     emit(OPCODES[OP_IGNORE[op]])
sre_compile.py(94):                     emit(lo)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(73):             not (flags & SRE_FLAG_LOCALE) and
sre_compile.py(74):             flags & SRE_FLAG_UNICODE):
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(100):                 emit(OPCODES[OP_IGNORE[op]])
sre_compile.py(101):                 def fixup(literal, flags=flags):
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(337):             return out
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(81):                 lo = _sre.getlower(av, flags)
sre_compile.py(82):                 if fixes and lo in fixes:
sre_compile.py(93):                     emit(OPCODES[OP_IGNORE[op]])
sre_compile.py(94):                     emit(lo)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(73):             not (flags & SRE_FLAG_LOCALE) and
sre_compile.py(74):             flags & SRE_FLAG_UNICODE):
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(100):                 emit(OPCODES[OP_IGNORE[op]])
sre_compile.py(101):                 def fixup(literal, flags=flags):
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(337):             return out
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(73):             not (flags & SRE_FLAG_LOCALE) and
sre_compile.py(74):             flags & SRE_FLAG_UNICODE):
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(73):             not (flags & SRE_FLAG_LOCALE) and
sre_compile.py(74):             flags & SRE_FLAG_UNICODE):
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(110):             if flags & SRE_FLAG_DOTALL:
sre_compile.py(113):                 emit(OPCODES[ANY])
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(563):     code.append(OPCODES[SUCCESS])
sre_compile.py(565):     return code
sre_compile.py(581):     if p.pattern.groups > 100:
sre_compile.py(587):     groupindex = p.pattern.groupdict
sre_compile.py(588):     indexgroup = [None] * p.pattern.groups
sre_compile.py(589):     for k, i in groupindex.items():
sre_compile.py(592):     return _sre.compile(
sre_compile.py(593):         pattern, flags | p.pattern.flags, code,
sre_compile.py(594):         p.pattern.groups-1,
sre_compile.py(595):         groupindex, indexgroup
re.py(252):     if not bypass_cache:
re.py(253):         if len(_cache) >= _MAXCACHE:
re.py(255):         if p.flags & LOCALE:
re.py(260):             loc = None
re.py(261):         _cache[cachekey] = p, loc
re.py(262):     return p
platform.py(294): _release_file_re = re.compile("(?:DISTRIB_RELEASE\s*=)\s*(.*)", re.I)
 --- modulename: re, funcname: compile
re.py(194):     return _compile(pattern, flags)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(240):         except KeyError:
re.py(241):             pass
re.py(242):     if isinstance(pattern, _pattern_type):
re.py(246):     if not sre_compile.isstring(pattern):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
re.py(248):     try:
re.py(249):         p = sre_compile.compile(pattern, flags)
 --- modulename: sre_compile, funcname: compile
sre_compile.py(570):     if isstring(p):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
sre_compile.py(571):         pattern = p
sre_compile.py(572):         p = sre_parse.parse(p, flags)
 --- modulename: sre_parse, funcname: parse
sre_parse.py(709):     source = Tokenizer(str)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(190):         self.string = string
sre_parse.py(191):         self.index = 0
sre_parse.py(192):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(711):     if pattern is None:
sre_parse.py(712):         pattern = Pattern()
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(68):         self.flags = 0
sre_parse.py(69):         self.open = []
sre_parse.py(70):         self.groups = 1
sre_parse.py(71):         self.groupdict = {}
sre_parse.py(72):         self.lookbehind = 0
sre_parse.py(713):     pattern.flags = flags
sre_parse.py(714):     pattern.str = str
sre_parse.py(716):     p = _parse_sub(source, pattern, 0)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(549):                 group = 0
sre_parse.py(551):                 if sourcematch("P"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(600):                 elif sourcematch(":"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(602):                     group = 2
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(670):                     group = None
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(272):         return code
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(493):                 min, max = 0, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(272):         return code
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(493):                 min, max = 0, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(542):             subpatternappend((ANY, None))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(493):                 min, max = 0, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(415):             break # end of pattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(328):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(718):     tail = source.get()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(719):     if tail == ")":
sre_parse.py(721):     elif tail:
sre_parse.py(724):     if flags & SRE_FLAG_DEBUG:
sre_parse.py(727):     if not (flags & SRE_FLAG_VERBOSE) and p.pattern.flags & SRE_FLAG_VERBOSE:
sre_parse.py(732):     return p
sre_compile.py(576):     code = _code(p, flags)
 --- modulename: sre_compile, funcname: _code
sre_compile.py(554):     flags = p.pattern.flags | flags
sre_compile.py(555):     code = []
sre_compile.py(558):     _compile_info(code, p, flags)
 --- modulename: sre_compile, funcname: _compile_info
sre_compile.py(437):     lo, hi = pattern.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_compile.py(438):     if lo == 0:
sre_compile.py(441):     prefix = []
sre_compile.py(442):     prefixappend = prefix.append
sre_compile.py(443):     prefix_skip = 0
sre_compile.py(444):     charset = [] # not used
sre_compile.py(445):     charsetappend = charset.append
sre_compile.py(446):     if not (flags & SRE_FLAG_IGNORECASE):
sre_compile.py(501):     emit = code.append
sre_compile.py(502):     emit(OPCODES[INFO])
sre_compile.py(503):     skip = len(code); emit(0)
sre_compile.py(505):     mask = 0
sre_compile.py(506):     if prefix:
sre_compile.py(510):     elif charset:
sre_compile.py(512):     emit(mask)
sre_compile.py(514):     if lo < MAXCODE:
sre_compile.py(515):         emit(lo)
sre_compile.py(519):     if hi < MAXCODE:
sre_compile.py(522):         emit(0)
sre_compile.py(524):     if prefix:
sre_compile.py(535):     elif charset:
sre_compile.py(537):     code[skip] = len(code) - skip
sre_compile.py(561):     _compile(code, p.data, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(73):             not (flags & SRE_FLAG_LOCALE) and
sre_compile.py(74):             flags & SRE_FLAG_UNICODE):
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(73):             not (flags & SRE_FLAG_LOCALE) and
sre_compile.py(74):             flags & SRE_FLAG_UNICODE):
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(81):                 lo = _sre.getlower(av, flags)
sre_compile.py(82):                 if fixes and lo in fixes:
sre_compile.py(93):                     emit(OPCODES[OP_IGNORE[op]])
sre_compile.py(94):                     emit(lo)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(81):                 lo = _sre.getlower(av, flags)
sre_compile.py(82):                 if fixes and lo in fixes:
sre_compile.py(93):                     emit(OPCODES[OP_IGNORE[op]])
sre_compile.py(94):                     emit(lo)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(81):                 lo = _sre.getlower(av, flags)
sre_compile.py(82):                 if fixes and lo in fixes:
sre_compile.py(93):                     emit(OPCODES[OP_IGNORE[op]])
sre_compile.py(94):                     emit(lo)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(81):                 lo = _sre.getlower(av, flags)
sre_compile.py(82):                 if fixes and lo in fixes:
sre_compile.py(93):                     emit(OPCODES[OP_IGNORE[op]])
sre_compile.py(94):                     emit(lo)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(81):                 lo = _sre.getlower(av, flags)
sre_compile.py(82):                 if fixes and lo in fixes:
sre_compile.py(93):                     emit(OPCODES[OP_IGNORE[op]])
sre_compile.py(94):                     emit(lo)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(81):                 lo = _sre.getlower(av, flags)
sre_compile.py(82):                 if fixes and lo in fixes:
sre_compile.py(93):                     emit(OPCODES[OP_IGNORE[op]])
sre_compile.py(94):                     emit(lo)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(81):                 lo = _sre.getlower(av, flags)
sre_compile.py(82):                 if fixes and lo in fixes:
sre_compile.py(93):                     emit(OPCODES[OP_IGNORE[op]])
sre_compile.py(94):                     emit(lo)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(81):                 lo = _sre.getlower(av, flags)
sre_compile.py(82):                 if fixes and lo in fixes:
sre_compile.py(93):                     emit(OPCODES[OP_IGNORE[op]])
sre_compile.py(94):                     emit(lo)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(81):                 lo = _sre.getlower(av, flags)
sre_compile.py(82):                 if fixes and lo in fixes:
sre_compile.py(93):                     emit(OPCODES[OP_IGNORE[op]])
sre_compile.py(94):                     emit(lo)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(81):                 lo = _sre.getlower(av, flags)
sre_compile.py(82):                 if fixes and lo in fixes:
sre_compile.py(93):                     emit(OPCODES[OP_IGNORE[op]])
sre_compile.py(94):                     emit(lo)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(81):                 lo = _sre.getlower(av, flags)
sre_compile.py(82):                 if fixes and lo in fixes:
sre_compile.py(93):                     emit(OPCODES[OP_IGNORE[op]])
sre_compile.py(94):                     emit(lo)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(81):                 lo = _sre.getlower(av, flags)
sre_compile.py(82):                 if fixes and lo in fixes:
sre_compile.py(93):                     emit(OPCODES[OP_IGNORE[op]])
sre_compile.py(94):                     emit(lo)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(81):                 lo = _sre.getlower(av, flags)
sre_compile.py(82):                 if fixes and lo in fixes:
sre_compile.py(93):                     emit(OPCODES[OP_IGNORE[op]])
sre_compile.py(94):                     emit(lo)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(81):                 lo = _sre.getlower(av, flags)
sre_compile.py(82):                 if fixes and lo in fixes:
sre_compile.py(93):                     emit(OPCODES[OP_IGNORE[op]])
sre_compile.py(94):                     emit(lo)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(81):                 lo = _sre.getlower(av, flags)
sre_compile.py(82):                 if fixes and lo in fixes:
sre_compile.py(93):                     emit(OPCODES[OP_IGNORE[op]])
sre_compile.py(94):                     emit(lo)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(73):             not (flags & SRE_FLAG_LOCALE) and
sre_compile.py(74):             flags & SRE_FLAG_UNICODE):
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(100):                 emit(OPCODES[OP_IGNORE[op]])
sre_compile.py(101):                 def fixup(literal, flags=flags):
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(337):             return out
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(81):                 lo = _sre.getlower(av, flags)
sre_compile.py(82):                 if fixes and lo in fixes:
sre_compile.py(93):                     emit(OPCODES[OP_IGNORE[op]])
sre_compile.py(94):                     emit(lo)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(73):             not (flags & SRE_FLAG_LOCALE) and
sre_compile.py(74):             flags & SRE_FLAG_UNICODE):
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(100):                 emit(OPCODES[OP_IGNORE[op]])
sre_compile.py(101):                 def fixup(literal, flags=flags):
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(337):             return out
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(73):             not (flags & SRE_FLAG_LOCALE) and
sre_compile.py(74):             flags & SRE_FLAG_UNICODE):
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(73):             not (flags & SRE_FLAG_LOCALE) and
sre_compile.py(74):             flags & SRE_FLAG_UNICODE):
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(110):             if flags & SRE_FLAG_DOTALL:
sre_compile.py(113):                 emit(OPCODES[ANY])
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(563):     code.append(OPCODES[SUCCESS])
sre_compile.py(565):     return code
sre_compile.py(581):     if p.pattern.groups > 100:
sre_compile.py(587):     groupindex = p.pattern.groupdict
sre_compile.py(588):     indexgroup = [None] * p.pattern.groups
sre_compile.py(589):     for k, i in groupindex.items():
sre_compile.py(592):     return _sre.compile(
sre_compile.py(593):         pattern, flags | p.pattern.flags, code,
sre_compile.py(594):         p.pattern.groups-1,
sre_compile.py(595):         groupindex, indexgroup
re.py(252):     if not bypass_cache:
re.py(253):         if len(_cache) >= _MAXCACHE:
re.py(255):         if p.flags & LOCALE:
re.py(260):             loc = None
re.py(261):         _cache[cachekey] = p, loc
re.py(262):     return p
platform.py(295): _codename_file_re = re.compile("(?:DISTRIB_CODENAME\s*=)\s*(.*)", re.I)
 --- modulename: re, funcname: compile
re.py(194):     return _compile(pattern, flags)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(240):         except KeyError:
re.py(241):             pass
re.py(242):     if isinstance(pattern, _pattern_type):
re.py(246):     if not sre_compile.isstring(pattern):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
re.py(248):     try:
re.py(249):         p = sre_compile.compile(pattern, flags)
 --- modulename: sre_compile, funcname: compile
sre_compile.py(570):     if isstring(p):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
sre_compile.py(571):         pattern = p
sre_compile.py(572):         p = sre_parse.parse(p, flags)
 --- modulename: sre_parse, funcname: parse
sre_parse.py(709):     source = Tokenizer(str)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(190):         self.string = string
sre_parse.py(191):         self.index = 0
sre_parse.py(192):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(711):     if pattern is None:
sre_parse.py(712):         pattern = Pattern()
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(68):         self.flags = 0
sre_parse.py(69):         self.open = []
sre_parse.py(70):         self.groups = 1
sre_parse.py(71):         self.groupdict = {}
sre_parse.py(72):         self.lookbehind = 0
sre_parse.py(713):     pattern.flags = flags
sre_parse.py(714):     pattern.str = str
sre_parse.py(716):     p = _parse_sub(source, pattern, 0)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(549):                 group = 0
sre_parse.py(551):                 if sourcematch("P"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(600):                 elif sourcematch(":"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(602):                     group = 2
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(670):                     group = None
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(272):         return code
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(493):                 min, max = 0, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(272):         return code
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(493):                 min, max = 0, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(542):             subpatternappend((ANY, None))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(493):                 min, max = 0, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(415):             break # end of pattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(328):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(718):     tail = source.get()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(719):     if tail == ")":
sre_parse.py(721):     elif tail:
sre_parse.py(724):     if flags & SRE_FLAG_DEBUG:
sre_parse.py(727):     if not (flags & SRE_FLAG_VERBOSE) and p.pattern.flags & SRE_FLAG_VERBOSE:
sre_parse.py(732):     return p
sre_compile.py(576):     code = _code(p, flags)
 --- modulename: sre_compile, funcname: _code
sre_compile.py(554):     flags = p.pattern.flags | flags
sre_compile.py(555):     code = []
sre_compile.py(558):     _compile_info(code, p, flags)
 --- modulename: sre_compile, funcname: _compile_info
sre_compile.py(437):     lo, hi = pattern.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_compile.py(438):     if lo == 0:
sre_compile.py(441):     prefix = []
sre_compile.py(442):     prefixappend = prefix.append
sre_compile.py(443):     prefix_skip = 0
sre_compile.py(444):     charset = [] # not used
sre_compile.py(445):     charsetappend = charset.append
sre_compile.py(446):     if not (flags & SRE_FLAG_IGNORECASE):
sre_compile.py(501):     emit = code.append
sre_compile.py(502):     emit(OPCODES[INFO])
sre_compile.py(503):     skip = len(code); emit(0)
sre_compile.py(505):     mask = 0
sre_compile.py(506):     if prefix:
sre_compile.py(510):     elif charset:
sre_compile.py(512):     emit(mask)
sre_compile.py(514):     if lo < MAXCODE:
sre_compile.py(515):         emit(lo)
sre_compile.py(519):     if hi < MAXCODE:
sre_compile.py(522):         emit(0)
sre_compile.py(524):     if prefix:
sre_compile.py(535):     elif charset:
sre_compile.py(537):     code[skip] = len(code) - skip
sre_compile.py(561):     _compile(code, p.data, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(73):             not (flags & SRE_FLAG_LOCALE) and
sre_compile.py(74):             flags & SRE_FLAG_UNICODE):
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(73):             not (flags & SRE_FLAG_LOCALE) and
sre_compile.py(74):             flags & SRE_FLAG_UNICODE):
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(81):                 lo = _sre.getlower(av, flags)
sre_compile.py(82):                 if fixes and lo in fixes:
sre_compile.py(93):                     emit(OPCODES[OP_IGNORE[op]])
sre_compile.py(94):                     emit(lo)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(81):                 lo = _sre.getlower(av, flags)
sre_compile.py(82):                 if fixes and lo in fixes:
sre_compile.py(93):                     emit(OPCODES[OP_IGNORE[op]])
sre_compile.py(94):                     emit(lo)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(81):                 lo = _sre.getlower(av, flags)
sre_compile.py(82):                 if fixes and lo in fixes:
sre_compile.py(93):                     emit(OPCODES[OP_IGNORE[op]])
sre_compile.py(94):                     emit(lo)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(81):                 lo = _sre.getlower(av, flags)
sre_compile.py(82):                 if fixes and lo in fixes:
sre_compile.py(93):                     emit(OPCODES[OP_IGNORE[op]])
sre_compile.py(94):                     emit(lo)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(81):                 lo = _sre.getlower(av, flags)
sre_compile.py(82):                 if fixes and lo in fixes:
sre_compile.py(93):                     emit(OPCODES[OP_IGNORE[op]])
sre_compile.py(94):                     emit(lo)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(81):                 lo = _sre.getlower(av, flags)
sre_compile.py(82):                 if fixes and lo in fixes:
sre_compile.py(93):                     emit(OPCODES[OP_IGNORE[op]])
sre_compile.py(94):                     emit(lo)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(81):                 lo = _sre.getlower(av, flags)
sre_compile.py(82):                 if fixes and lo in fixes:
sre_compile.py(93):                     emit(OPCODES[OP_IGNORE[op]])
sre_compile.py(94):                     emit(lo)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(81):                 lo = _sre.getlower(av, flags)
sre_compile.py(82):                 if fixes and lo in fixes:
sre_compile.py(93):                     emit(OPCODES[OP_IGNORE[op]])
sre_compile.py(94):                     emit(lo)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(81):                 lo = _sre.getlower(av, flags)
sre_compile.py(82):                 if fixes and lo in fixes:
sre_compile.py(93):                     emit(OPCODES[OP_IGNORE[op]])
sre_compile.py(94):                     emit(lo)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(81):                 lo = _sre.getlower(av, flags)
sre_compile.py(82):                 if fixes and lo in fixes:
sre_compile.py(93):                     emit(OPCODES[OP_IGNORE[op]])
sre_compile.py(94):                     emit(lo)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(81):                 lo = _sre.getlower(av, flags)
sre_compile.py(82):                 if fixes and lo in fixes:
sre_compile.py(93):                     emit(OPCODES[OP_IGNORE[op]])
sre_compile.py(94):                     emit(lo)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(81):                 lo = _sre.getlower(av, flags)
sre_compile.py(82):                 if fixes and lo in fixes:
sre_compile.py(93):                     emit(OPCODES[OP_IGNORE[op]])
sre_compile.py(94):                     emit(lo)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(81):                 lo = _sre.getlower(av, flags)
sre_compile.py(82):                 if fixes and lo in fixes:
sre_compile.py(93):                     emit(OPCODES[OP_IGNORE[op]])
sre_compile.py(94):                     emit(lo)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(81):                 lo = _sre.getlower(av, flags)
sre_compile.py(82):                 if fixes and lo in fixes:
sre_compile.py(93):                     emit(OPCODES[OP_IGNORE[op]])
sre_compile.py(94):                     emit(lo)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(81):                 lo = _sre.getlower(av, flags)
sre_compile.py(82):                 if fixes and lo in fixes:
sre_compile.py(93):                     emit(OPCODES[OP_IGNORE[op]])
sre_compile.py(94):                     emit(lo)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(81):                 lo = _sre.getlower(av, flags)
sre_compile.py(82):                 if fixes and lo in fixes:
sre_compile.py(93):                     emit(OPCODES[OP_IGNORE[op]])
sre_compile.py(94):                     emit(lo)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(73):             not (flags & SRE_FLAG_LOCALE) and
sre_compile.py(74):             flags & SRE_FLAG_UNICODE):
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(100):                 emit(OPCODES[OP_IGNORE[op]])
sre_compile.py(101):                 def fixup(literal, flags=flags):
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(337):             return out
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(81):                 lo = _sre.getlower(av, flags)
sre_compile.py(82):                 if fixes and lo in fixes:
sre_compile.py(93):                     emit(OPCODES[OP_IGNORE[op]])
sre_compile.py(94):                     emit(lo)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(73):             not (flags & SRE_FLAG_LOCALE) and
sre_compile.py(74):             flags & SRE_FLAG_UNICODE):
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(100):                 emit(OPCODES[OP_IGNORE[op]])
sre_compile.py(101):                 def fixup(literal, flags=flags):
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(337):             return out
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(73):             not (flags & SRE_FLAG_LOCALE) and
sre_compile.py(74):             flags & SRE_FLAG_UNICODE):
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(73):             not (flags & SRE_FLAG_LOCALE) and
sre_compile.py(74):             flags & SRE_FLAG_UNICODE):
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(110):             if flags & SRE_FLAG_DOTALL:
sre_compile.py(113):                 emit(OPCODES[ANY])
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(563):     code.append(OPCODES[SUCCESS])
sre_compile.py(565):     return code
sre_compile.py(581):     if p.pattern.groups > 100:
sre_compile.py(587):     groupindex = p.pattern.groupdict
sre_compile.py(588):     indexgroup = [None] * p.pattern.groups
sre_compile.py(589):     for k, i in groupindex.items():
sre_compile.py(592):     return _sre.compile(
sre_compile.py(593):         pattern, flags | p.pattern.flags, code,
sre_compile.py(594):         p.pattern.groups-1,
sre_compile.py(595):         groupindex, indexgroup
re.py(252):     if not bypass_cache:
re.py(253):         if len(_cache) >= _MAXCACHE:
re.py(255):         if p.flags & LOCALE:
re.py(260):             loc = None
re.py(261):         _cache[cachekey] = p, loc
re.py(262):     return p
platform.py(297): def linux_distribution(distname='', version='', id='',
platform.py(299):                        supported_dists=_supported_dists,
platform.py(300):                        full_distribution_name=1):
platform.py(372): def dist(distname='',version='',id='',
platform.py(374):          supported_dists=_supported_dists):
platform.py(390): class _popen:
 --- modulename: platform, funcname: _popen
platform.py(390): class _popen:
platform.py(400):     """
platform.py(401):     tmpfile = ''
platform.py(402):     pipe = None
platform.py(403):     bufsize = None
platform.py(404):     mode = 'r'
platform.py(406):     def __init__(self,cmd,mode='r',bufsize=None):
platform.py(417):     def read(self):
platform.py(421):     def readlines(self):
platform.py(428):               remove=os.unlink,error=os.error):
platform.py(442):     __del__ = close
platform.py(444): def popen(cmd, mode='r', bufsize=None):
platform.py(477): def _norm_version(version, build=''):
platform.py(494): _ver_output = re.compile(r'(?:([\w ]+) ([\w.]+) '
 --- modulename: re, funcname: compile
re.py(194):     return _compile(pattern, flags)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(240):         except KeyError:
re.py(241):             pass
re.py(242):     if isinstance(pattern, _pattern_type):
re.py(246):     if not sre_compile.isstring(pattern):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
re.py(248):     try:
re.py(249):         p = sre_compile.compile(pattern, flags)
 --- modulename: sre_compile, funcname: compile
sre_compile.py(570):     if isstring(p):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
sre_compile.py(571):         pattern = p
sre_compile.py(572):         p = sre_parse.parse(p, flags)
 --- modulename: sre_parse, funcname: parse
sre_parse.py(709):     source = Tokenizer(str)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(190):         self.string = string
sre_parse.py(191):         self.index = 0
sre_parse.py(192):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(711):     if pattern is None:
sre_parse.py(712):         pattern = Pattern()
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(68):         self.flags = 0
sre_parse.py(69):         self.open = []
sre_parse.py(70):         self.groups = 1
sre_parse.py(71):         self.groupdict = {}
sre_parse.py(72):         self.lookbehind = 0
sre_parse.py(713):     pattern.flags = flags
sre_parse.py(714):     pattern.str = str
sre_parse.py(716):     p = _parse_sub(source, pattern, 0)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(549):                 group = 0
sre_parse.py(551):                 if sourcematch("P"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(600):                 elif sourcematch(":"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(602):                     group = 2
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(670):                     group = None
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(241):     code = CATEGORIES.get(escape)
sre_parse.py(242):     if code and code[0] == IN:
sre_parse.py(243):         return code
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(476):                         code1 = code1[1][0]
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(495):             elif this == "+":
sre_parse.py(496):                 min, max = 1, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(241):     code = CATEGORIES.get(escape)
sre_parse.py(242):     if code and code[0] == IN:
sre_parse.py(243):         return code
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(476):                         code1 = code1[1][0]
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(495):             elif this == "+":
sre_parse.py(496):                 min, max = 1, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(542):             subpatternappend((ANY, None))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(493):                 min, max = 0, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(273):     code = ESCAPES.get(escape)
sre_parse.py(274):     if code:
sre_parse.py(276):     try:
sre_parse.py(277):         c = escape[1:2]
sre_parse.py(278):         if c == "x":
sre_parse.py(285):         elif c == "0":
sre_parse.py(290):         elif c in DIGITS:
sre_parse.py(311):         if len(escape) == 2:
sre_parse.py(312):             return LITERAL, ord(escape[1])
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(542):             subpatternappend((ANY, None))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(493):                 min, max = 0, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(241):     code = CATEGORIES.get(escape)
sre_parse.py(242):     if code and code[0] == IN:
sre_parse.py(243):         return code
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(476):                         code1 = code1[1][0]
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(495):             elif this == "+":
sre_parse.py(496):                 min, max = 1, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(273):     code = ESCAPES.get(escape)
sre_parse.py(274):     if code:
sre_parse.py(276):     try:
sre_parse.py(277):         c = escape[1:2]
sre_parse.py(278):         if c == "x":
sre_parse.py(285):         elif c == "0":
sre_parse.py(290):         elif c in DIGITS:
sre_parse.py(311):         if len(escape) == 2:
sre_parse.py(312):             return LITERAL, ord(escape[1])
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(415):             break # end of pattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(328):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(718):     tail = source.get()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(719):     if tail == ")":
sre_parse.py(721):     elif tail:
sre_parse.py(724):     if flags & SRE_FLAG_DEBUG:
sre_parse.py(727):     if not (flags & SRE_FLAG_VERBOSE) and p.pattern.flags & SRE_FLAG_VERBOSE:
sre_parse.py(732):     return p
sre_compile.py(576):     code = _code(p, flags)
 --- modulename: sre_compile, funcname: _code
sre_compile.py(554):     flags = p.pattern.flags | flags
sre_compile.py(555):     code = []
sre_compile.py(558):     _compile_info(code, p, flags)
 --- modulename: sre_compile, funcname: _compile_info
sre_compile.py(437):     lo, hi = pattern.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_compile.py(438):     if lo == 0:
sre_compile.py(441):     prefix = []
sre_compile.py(442):     prefixappend = prefix.append
sre_compile.py(443):     prefix_skip = 0
sre_compile.py(444):     charset = [] # not used
sre_compile.py(445):     charsetappend = charset.append
sre_compile.py(446):     if not (flags & SRE_FLAG_IGNORECASE):
sre_compile.py(448):         for op, av in pattern.data:
sre_compile.py(449):             if op is LITERAL:
sre_compile.py(453):             elif op is SUBPATTERN and len(av[1]) == 1:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_compile.py(460):                 break
sre_compile.py(462):         if not prefix and pattern.data:
sre_compile.py(463):             op, av = pattern.data[0]
sre_compile.py(464):             if op is SUBPATTERN and av[1]:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_compile.py(465):                 op, av = av[1][0]
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(466):                 if op is LITERAL:
sre_compile.py(468):                 elif op is BRANCH:
sre_compile.py(501):     emit = code.append
sre_compile.py(502):     emit(OPCODES[INFO])
sre_compile.py(503):     skip = len(code); emit(0)
sre_compile.py(505):     mask = 0
sre_compile.py(506):     if prefix:
sre_compile.py(510):     elif charset:
sre_compile.py(512):     emit(mask)
sre_compile.py(514):     if lo < MAXCODE:
sre_compile.py(515):         emit(lo)
sre_compile.py(519):     if hi < MAXCODE:
sre_compile.py(522):         emit(0)
sre_compile.py(524):     if prefix:
sre_compile.py(535):     elif charset:
sre_compile.py(537):     code[skip] = len(code) - skip
sre_compile.py(561):     _compile(code, p.data, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(110):             if flags & SRE_FLAG_DOTALL:
sre_compile.py(113):                 emit(OPCODES[ANY])
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(110):             if flags & SRE_FLAG_DOTALL:
sre_compile.py(113):                 emit(OPCODES[ANY])
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(563):     code.append(OPCODES[SUCCESS])
sre_compile.py(565):     return code
sre_compile.py(581):     if p.pattern.groups > 100:
sre_compile.py(587):     groupindex = p.pattern.groupdict
sre_compile.py(588):     indexgroup = [None] * p.pattern.groups
sre_compile.py(589):     for k, i in groupindex.items():
sre_compile.py(592):     return _sre.compile(
sre_compile.py(593):         pattern, flags | p.pattern.flags, code,
sre_compile.py(594):         p.pattern.groups-1,
sre_compile.py(595):         groupindex, indexgroup
re.py(252):     if not bypass_cache:
re.py(253):         if len(_cache) >= _MAXCACHE:
re.py(255):         if p.flags & LOCALE:
re.py(260):             loc = None
re.py(261):         _cache[cachekey] = p, loc
re.py(262):     return p
platform.py(507): def _syscmd_ver(system='', release='', version='',
platform.py(509):                supported_platforms=('win32','win16','dos','os2')):
platform.py(559): _WIN32_CLIENT_RELEASES = {
platform.py(560):     (5, 0): "2000",
platform.py(561):     (5, 1): "XP",
platform.py(564):     (5, 2): "2003Server",
platform.py(565):     (5, None): "post2003",
platform.py(567):     (6, 0): "Vista",
platform.py(568):     (6, 1): "7",
platform.py(569):     (6, 2): "8",
platform.py(570):     (6, 3): "8.1",
platform.py(571):     (6, None): "post8.1",
platform.py(573):     (10, 0): "10",
platform.py(574):     (10, None): "post10",
platform.py(578): _WIN32_SERVER_RELEASES = {
platform.py(579):     (5, 2): "2003Server",
platform.py(581):     (6, 0): "2008Server",
platform.py(582):     (6, 1): "2008ServerR2",
platform.py(583):     (6, 2): "2012Server",
platform.py(584):     (6, 3): "2012ServerR2",
platform.py(585):     (6, None): "post2012ServerR2",
platform.py(588): def _get_real_winver(maj, min, build):
platform.py(647): def win32_ver(release='', version='', csd='', ptype=''):
platform.py(694): def _mac_ver_lookup(selectors,default=None):
platform.py(707): def _bcd2str(bcd):
platform.py(711): def _mac_ver_gestalt():
platform.py(752): def _mac_ver_xml():
platform.py(773): def mac_ver(release='',versioninfo=('','',''),machine=''):
platform.py(798): def _java_getprop(name,default):
platform.py(809): def java_ver(release='',vendor='',vminfo=('','',''),osinfo=('','','')):
platform.py(844): def system_alias(system,release,version):
platform.py(898): def _platform(*args):
platform.py(934): def _node(default=''):
platform.py(950): if not hasattr(os.path,'abspath'):
platform.py(963):     _abspath = os.path.abspath
platform.py(965): def _follow_symlinks(filepath):
platform.py(976): def _syscmd_uname(option,default=''):
platform.py(994): def _syscmd_file(target,default=''):
platform.py(1045): _default_architecture = {
platform.py(1046):     'win32': ('','WindowsPE'),
platform.py(1047):     'win16': ('','Windows'),
platform.py(1048):     'dos': ('','MSDOS'),
platform.py(1051): _architecture_split = re.compile(r'[\s,]').split
 --- modulename: re, funcname: compile
re.py(194):     return _compile(pattern, flags)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(240):         except KeyError:
re.py(241):             pass
re.py(242):     if isinstance(pattern, _pattern_type):
re.py(246):     if not sre_compile.isstring(pattern):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
re.py(248):     try:
re.py(249):         p = sre_compile.compile(pattern, flags)
 --- modulename: sre_compile, funcname: compile
sre_compile.py(570):     if isstring(p):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
sre_compile.py(571):         pattern = p
sre_compile.py(572):         p = sre_parse.parse(p, flags)
 --- modulename: sre_parse, funcname: parse
sre_parse.py(709):     source = Tokenizer(str)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(190):         self.string = string
sre_parse.py(191):         self.index = 0
sre_parse.py(192):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(711):     if pattern is None:
sre_parse.py(712):         pattern = Pattern()
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(68):         self.flags = 0
sre_parse.py(69):         self.open = []
sre_parse.py(70):         self.groups = 1
sre_parse.py(71):         self.groupdict = {}
sre_parse.py(72):         self.lookbehind = 0
sre_parse.py(713):     pattern.flags = flags
sre_parse.py(714):     pattern.str = str
sre_parse.py(716):     p = _parse_sub(source, pattern, 0)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(241):     code = CATEGORIES.get(escape)
sre_parse.py(242):     if code and code[0] == IN:
sre_parse.py(243):         return code
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(476):                         code1 = code1[1][0]
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(415):             break # end of pattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(328):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(718):     tail = source.get()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(719):     if tail == ")":
sre_parse.py(721):     elif tail:
sre_parse.py(724):     if flags & SRE_FLAG_DEBUG:
sre_parse.py(727):     if not (flags & SRE_FLAG_VERBOSE) and p.pattern.flags & SRE_FLAG_VERBOSE:
sre_parse.py(732):     return p
sre_compile.py(576):     code = _code(p, flags)
 --- modulename: sre_compile, funcname: _code
sre_compile.py(554):     flags = p.pattern.flags | flags
sre_compile.py(555):     code = []
sre_compile.py(558):     _compile_info(code, p, flags)
 --- modulename: sre_compile, funcname: _compile_info
sre_compile.py(437):     lo, hi = pattern.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_compile.py(438):     if lo == 0:
sre_compile.py(441):     prefix = []
sre_compile.py(442):     prefixappend = prefix.append
sre_compile.py(443):     prefix_skip = 0
sre_compile.py(444):     charset = [] # not used
sre_compile.py(445):     charsetappend = charset.append
sre_compile.py(446):     if not (flags & SRE_FLAG_IGNORECASE):
sre_compile.py(448):         for op, av in pattern.data:
sre_compile.py(449):             if op is LITERAL:
sre_compile.py(453):             elif op is SUBPATTERN and len(av[1]) == 1:
sre_compile.py(460):                 break
sre_compile.py(462):         if not prefix and pattern.data:
sre_compile.py(463):             op, av = pattern.data[0]
sre_compile.py(464):             if op is SUBPATTERN and av[1]:
sre_compile.py(481):             elif op is BRANCH:
sre_compile.py(494):             elif op is IN:
sre_compile.py(495):                 charset = av
sre_compile.py(501):     emit = code.append
sre_compile.py(502):     emit(OPCODES[INFO])
sre_compile.py(503):     skip = len(code); emit(0)
sre_compile.py(505):     mask = 0
sre_compile.py(506):     if prefix:
sre_compile.py(510):     elif charset:
sre_compile.py(511):         mask = mask + SRE_INFO_CHARSET
sre_compile.py(512):     emit(mask)
sre_compile.py(514):     if lo < MAXCODE:
sre_compile.py(515):         emit(lo)
sre_compile.py(519):     if hi < MAXCODE:
sre_compile.py(520):         emit(hi)
sre_compile.py(524):     if prefix:
sre_compile.py(535):     elif charset:
sre_compile.py(536):         _compile_charset(charset, flags, code)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(537):     code[skip] = len(code) - skip
sre_compile.py(561):     _compile(code, p.data, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(563):     code.append(OPCODES[SUCCESS])
sre_compile.py(565):     return code
sre_compile.py(581):     if p.pattern.groups > 100:
sre_compile.py(587):     groupindex = p.pattern.groupdict
sre_compile.py(588):     indexgroup = [None] * p.pattern.groups
sre_compile.py(589):     for k, i in groupindex.items():
sre_compile.py(592):     return _sre.compile(
sre_compile.py(593):         pattern, flags | p.pattern.flags, code,
sre_compile.py(594):         p.pattern.groups-1,
sre_compile.py(595):         groupindex, indexgroup
re.py(252):     if not bypass_cache:
re.py(253):         if len(_cache) >= _MAXCACHE:
re.py(255):         if p.flags & LOCALE:
re.py(260):             loc = None
re.py(261):         _cache[cachekey] = p, loc
re.py(262):     return p
platform.py(1053): def architecture(executable=sys.executable,bits='',linkage=''):
platform.py(1140): _uname_cache = None
platform.py(1142): def uname():
platform.py(1279): def system():
platform.py(1288): def node():
platform.py(1298): def release():
platform.py(1307): def version():
platform.py(1316): def machine():
platform.py(1325): def processor():
platform.py(1339): _sys_version_parser = re.compile(
platform.py(1340):     r'([\w.+]+)\s*'
 --- modulename: re, funcname: compile
re.py(194):     return _compile(pattern, flags)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(240):         except KeyError:
re.py(241):             pass
re.py(242):     if isinstance(pattern, _pattern_type):
re.py(246):     if not sre_compile.isstring(pattern):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
re.py(248):     try:
re.py(249):         p = sre_compile.compile(pattern, flags)
 --- modulename: sre_compile, funcname: compile
sre_compile.py(570):     if isstring(p):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
sre_compile.py(571):         pattern = p
sre_compile.py(572):         p = sre_parse.parse(p, flags)
 --- modulename: sre_parse, funcname: parse
sre_parse.py(709):     source = Tokenizer(str)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(190):         self.string = string
sre_parse.py(191):         self.index = 0
sre_parse.py(192):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(711):     if pattern is None:
sre_parse.py(712):         pattern = Pattern()
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(68):         self.flags = 0
sre_parse.py(69):         self.open = []
sre_parse.py(70):         self.groups = 1
sre_parse.py(71):         self.groupdict = {}
sre_parse.py(72):         self.lookbehind = 0
sre_parse.py(713):     pattern.flags = flags
sre_parse.py(714):     pattern.str = str
sre_parse.py(716):     p = _parse_sub(source, pattern, 0)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(241):     code = CATEGORIES.get(escape)
sre_parse.py(242):     if code and code[0] == IN:
sre_parse.py(243):         return code
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(476):                         code1 = code1[1][0]
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(495):             elif this == "+":
sre_parse.py(496):                 min, max = 1, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(272):         return code
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(493):                 min, max = 0, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(273):     code = ESCAPES.get(escape)
sre_parse.py(274):     if code:
sre_parse.py(276):     try:
sre_parse.py(277):         c = escape[1:2]
sre_parse.py(278):         if c == "x":
sre_parse.py(285):         elif c == "0":
sre_parse.py(290):         elif c in DIGITS:
sre_parse.py(311):         if len(escape) == 2:
sre_parse.py(312):             return LITERAL, ord(escape[1])
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(491):                 min, max = 0, 1
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(438):                 setappend((NEGATE, None))
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(483):                 subpatternappend((NOT_LITERAL, set[1][1])) # optimization
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(495):             elif this == "+":
sre_parse.py(496):                 min, max = 1, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(272):         return code
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(493):                 min, max = 0, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(241):     code = CATEGORIES.get(escape)
sre_parse.py(242):     if code and code[0] == IN:
sre_parse.py(243):         return code
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(476):                         code1 = code1[1][0]
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(495):             elif this == "+":
sre_parse.py(496):                 min, max = 1, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(272):         return code
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(493):                 min, max = 0, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(241):     code = CATEGORIES.get(escape)
sre_parse.py(242):     if code and code[0] == IN:
sre_parse.py(243):         return code
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(476):                         code1 = code1[1][0]
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(495):             elif this == "+":
sre_parse.py(496):                 min, max = 1, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(273):     code = ESCAPES.get(escape)
sre_parse.py(274):     if code:
sre_parse.py(276):     try:
sre_parse.py(277):         c = escape[1:2]
sre_parse.py(278):         if c == "x":
sre_parse.py(285):         elif c == "0":
sre_parse.py(290):         elif c in DIGITS:
sre_parse.py(311):         if len(escape) == 2:
sre_parse.py(312):             return LITERAL, ord(escape[1])
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(272):         return code
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(493):                 min, max = 0, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(273):     code = ESCAPES.get(escape)
sre_parse.py(274):     if code:
sre_parse.py(276):     try:
sre_parse.py(277):         c = escape[1:2]
sre_parse.py(278):         if c == "x":
sre_parse.py(285):         elif c == "0":
sre_parse.py(290):         elif c in DIGITS:
sre_parse.py(311):         if len(escape) == 2:
sre_parse.py(312):             return LITERAL, ord(escape[1])
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(438):                 setappend((NEGATE, None))
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(241):     code = CATEGORIES.get(escape)
sre_parse.py(242):     if code and code[0] == IN:
sre_parse.py(244):     try:
sre_parse.py(245):         c = escape[1:2]
sre_parse.py(246):         if c == "x":
sre_parse.py(254):         elif c in OCTDIGITS:
sre_parse.py(260):         elif c in DIGITS:
sre_parse.py(262):         if len(escape) == 2:
sre_parse.py(263):             return LITERAL, ord(escape[1])
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(483):                 subpatternappend((NOT_LITERAL, set[1][1])) # optimization
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(495):             elif this == "+":
sre_parse.py(496):                 min, max = 1, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(273):     code = ESCAPES.get(escape)
sre_parse.py(274):     if code:
sre_parse.py(276):     try:
sre_parse.py(277):         c = escape[1:2]
sre_parse.py(278):         if c == "x":
sre_parse.py(285):         elif c == "0":
sre_parse.py(290):         elif c in DIGITS:
sre_parse.py(311):         if len(escape) == 2:
sre_parse.py(312):             return LITERAL, ord(escape[1])
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(491):                 min, max = 0, 1
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(415):             break # end of pattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(328):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(718):     tail = source.get()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(719):     if tail == ")":
sre_parse.py(721):     elif tail:
sre_parse.py(724):     if flags & SRE_FLAG_DEBUG:
sre_parse.py(727):     if not (flags & SRE_FLAG_VERBOSE) and p.pattern.flags & SRE_FLAG_VERBOSE:
sre_parse.py(732):     return p
sre_compile.py(576):     code = _code(p, flags)
 --- modulename: sre_compile, funcname: _code
sre_compile.py(554):     flags = p.pattern.flags | flags
sre_compile.py(555):     code = []
sre_compile.py(558):     _compile_info(code, p, flags)
 --- modulename: sre_compile, funcname: _compile_info
sre_compile.py(437):     lo, hi = pattern.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_compile.py(438):     if lo == 0:
sre_compile.py(441):     prefix = []
sre_compile.py(442):     prefixappend = prefix.append
sre_compile.py(443):     prefix_skip = 0
sre_compile.py(444):     charset = [] # not used
sre_compile.py(445):     charsetappend = charset.append
sre_compile.py(446):     if not (flags & SRE_FLAG_IGNORECASE):
sre_compile.py(448):         for op, av in pattern.data:
sre_compile.py(449):             if op is LITERAL:
sre_compile.py(453):             elif op is SUBPATTERN and len(av[1]) == 1:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_compile.py(454):                 op, av = av[1][0]
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(455):                 if op is LITERAL:
sre_compile.py(458):                     break
sre_compile.py(462):         if not prefix and pattern.data:
sre_compile.py(463):             op, av = pattern.data[0]
sre_compile.py(464):             if op is SUBPATTERN and av[1]:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_compile.py(465):                 op, av = av[1][0]
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(466):                 if op is LITERAL:
sre_compile.py(468):                 elif op is BRANCH:
sre_compile.py(501):     emit = code.append
sre_compile.py(502):     emit(OPCODES[INFO])
sre_compile.py(503):     skip = len(code); emit(0)
sre_compile.py(505):     mask = 0
sre_compile.py(506):     if prefix:
sre_compile.py(510):     elif charset:
sre_compile.py(512):     emit(mask)
sre_compile.py(514):     if lo < MAXCODE:
sre_compile.py(515):         emit(lo)
sre_compile.py(519):     if hi < MAXCODE:
sre_compile.py(522):         emit(0)
sre_compile.py(524):     if prefix:
sre_compile.py(535):     elif charset:
sre_compile.py(537):     code[skip] = len(code) - skip
sre_compile.py(561):     _compile(code, p.data, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(563):     code.append(OPCODES[SUCCESS])
sre_compile.py(565):     return code
sre_compile.py(581):     if p.pattern.groups > 100:
sre_compile.py(587):     groupindex = p.pattern.groupdict
sre_compile.py(588):     indexgroup = [None] * p.pattern.groups
sre_compile.py(589):     for k, i in groupindex.items():
sre_compile.py(592):     return _sre.compile(
sre_compile.py(593):         pattern, flags | p.pattern.flags, code,
sre_compile.py(594):         p.pattern.groups-1,
sre_compile.py(595):         groupindex, indexgroup
re.py(252):     if not bypass_cache:
re.py(253):         if len(_cache) >= _MAXCACHE:
re.py(255):         if p.flags & LOCALE:
re.py(260):             loc = None
re.py(261):         _cache[cachekey] = p, loc
re.py(262):     return p
platform.py(1344): _ironpython_sys_version_parser = re.compile(
platform.py(1345):     r'IronPython\s*'
 --- modulename: re, funcname: compile
re.py(194):     return _compile(pattern, flags)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(240):         except KeyError:
re.py(241):             pass
re.py(242):     if isinstance(pattern, _pattern_type):
re.py(246):     if not sre_compile.isstring(pattern):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
re.py(248):     try:
re.py(249):         p = sre_compile.compile(pattern, flags)
 --- modulename: sre_compile, funcname: compile
sre_compile.py(570):     if isstring(p):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
sre_compile.py(571):         pattern = p
sre_compile.py(572):         p = sre_parse.parse(p, flags)
 --- modulename: sre_parse, funcname: parse
sre_parse.py(709):     source = Tokenizer(str)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(190):         self.string = string
sre_parse.py(191):         self.index = 0
sre_parse.py(192):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(711):     if pattern is None:
sre_parse.py(712):         pattern = Pattern()
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(68):         self.flags = 0
sre_parse.py(69):         self.open = []
sre_parse.py(70):         self.groups = 1
sre_parse.py(71):         self.groupdict = {}
sre_parse.py(72):         self.lookbehind = 0
sre_parse.py(713):     pattern.flags = flags
sre_parse.py(714):     pattern.str = str
sre_parse.py(716):     p = _parse_sub(source, pattern, 0)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(272):         return code
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(493):                 min, max = 0, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(241):     code = CATEGORIES.get(escape)
sre_parse.py(242):     if code and code[0] == IN:
sre_parse.py(243):         return code
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(476):                         code1 = code1[1][0]
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(241):     code = CATEGORIES.get(escape)
sre_parse.py(242):     if code and code[0] == IN:
sre_parse.py(244):     try:
sre_parse.py(245):         c = escape[1:2]
sre_parse.py(246):         if c == "x":
sre_parse.py(254):         elif c in OCTDIGITS:
sre_parse.py(260):         elif c in DIGITS:
sre_parse.py(262):         if len(escape) == 2:
sre_parse.py(263):             return LITERAL, ord(escape[1])
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(495):             elif this == "+":
sre_parse.py(496):                 min, max = 1, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(549):                 group = 0
sre_parse.py(551):                 if sourcematch("P"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(600):                 elif sourcematch(":"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(602):                     group = 2
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(670):                     group = None
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(273):     code = ESCAPES.get(escape)
sre_parse.py(274):     if code:
sre_parse.py(276):     try:
sre_parse.py(277):         c = escape[1:2]
sre_parse.py(278):         if c == "x":
sre_parse.py(285):         elif c == "0":
sre_parse.py(290):         elif c in DIGITS:
sre_parse.py(311):         if len(escape) == 2:
sre_parse.py(312):             return LITERAL, ord(escape[1])
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(241):     code = CATEGORIES.get(escape)
sre_parse.py(242):     if code and code[0] == IN:
sre_parse.py(243):         return code
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(476):                         code1 = code1[1][0]
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(241):     code = CATEGORIES.get(escape)
sre_parse.py(242):     if code and code[0] == IN:
sre_parse.py(244):     try:
sre_parse.py(245):         c = escape[1:2]
sre_parse.py(246):         if c == "x":
sre_parse.py(254):         elif c in OCTDIGITS:
sre_parse.py(260):         elif c in DIGITS:
sre_parse.py(262):         if len(escape) == 2:
sre_parse.py(263):             return LITERAL, ord(escape[1])
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(495):             elif this == "+":
sre_parse.py(496):                 min, max = 1, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(273):     code = ESCAPES.get(escape)
sre_parse.py(274):     if code:
sre_parse.py(276):     try:
sre_parse.py(277):         c = escape[1:2]
sre_parse.py(278):         if c == "x":
sre_parse.py(285):         elif c == "0":
sre_parse.py(290):         elif c in DIGITS:
sre_parse.py(311):         if len(escape) == 2:
sre_parse.py(312):             return LITERAL, ord(escape[1])
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(491):                 min, max = 0, 1
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(542):             subpatternappend((ANY, None))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(241):     code = CATEGORIES.get(escape)
sre_parse.py(242):     if code and code[0] == IN:
sre_parse.py(243):         return code
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(476):                         code1 = code1[1][0]
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(241):     code = CATEGORIES.get(escape)
sre_parse.py(242):     if code and code[0] == IN:
sre_parse.py(244):     try:
sre_parse.py(245):         c = escape[1:2]
sre_parse.py(246):         if c == "x":
sre_parse.py(254):         elif c in OCTDIGITS:
sre_parse.py(260):         elif c in DIGITS:
sre_parse.py(262):         if len(escape) == 2:
sre_parse.py(263):             return LITERAL, ord(escape[1])
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(495):             elif this == "+":
sre_parse.py(496):                 min, max = 1, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(415):             break # end of pattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(328):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(718):     tail = source.get()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(719):     if tail == ")":
sre_parse.py(721):     elif tail:
sre_parse.py(724):     if flags & SRE_FLAG_DEBUG:
sre_parse.py(727):     if not (flags & SRE_FLAG_VERBOSE) and p.pattern.flags & SRE_FLAG_VERBOSE:
sre_parse.py(732):     return p
sre_compile.py(576):     code = _code(p, flags)
 --- modulename: sre_compile, funcname: _code
sre_compile.py(554):     flags = p.pattern.flags | flags
sre_compile.py(555):     code = []
sre_compile.py(558):     _compile_info(code, p, flags)
 --- modulename: sre_compile, funcname: _compile_info
sre_compile.py(437):     lo, hi = pattern.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_compile.py(438):     if lo == 0:
sre_compile.py(441):     prefix = []
sre_compile.py(442):     prefixappend = prefix.append
sre_compile.py(443):     prefix_skip = 0
sre_compile.py(444):     charset = [] # not used
sre_compile.py(445):     charsetappend = charset.append
sre_compile.py(446):     if not (flags & SRE_FLAG_IGNORECASE):
sre_compile.py(448):         for op, av in pattern.data:
sre_compile.py(449):             if op is LITERAL:
sre_compile.py(450):                 if len(prefix) == prefix_skip:
sre_compile.py(451):                     prefix_skip = prefix_skip + 1
sre_compile.py(452):                 prefixappend(av)
sre_compile.py(448):         for op, av in pattern.data:
sre_compile.py(449):             if op is LITERAL:
sre_compile.py(450):                 if len(prefix) == prefix_skip:
sre_compile.py(451):                     prefix_skip = prefix_skip + 1
sre_compile.py(452):                 prefixappend(av)
sre_compile.py(448):         for op, av in pattern.data:
sre_compile.py(449):             if op is LITERAL:
sre_compile.py(450):                 if len(prefix) == prefix_skip:
sre_compile.py(451):                     prefix_skip = prefix_skip + 1
sre_compile.py(452):                 prefixappend(av)
sre_compile.py(448):         for op, av in pattern.data:
sre_compile.py(449):             if op is LITERAL:
sre_compile.py(450):                 if len(prefix) == prefix_skip:
sre_compile.py(451):                     prefix_skip = prefix_skip + 1
sre_compile.py(452):                 prefixappend(av)
sre_compile.py(448):         for op, av in pattern.data:
sre_compile.py(449):             if op is LITERAL:
sre_compile.py(450):                 if len(prefix) == prefix_skip:
sre_compile.py(451):                     prefix_skip = prefix_skip + 1
sre_compile.py(452):                 prefixappend(av)
sre_compile.py(448):         for op, av in pattern.data:
sre_compile.py(449):             if op is LITERAL:
sre_compile.py(450):                 if len(prefix) == prefix_skip:
sre_compile.py(451):                     prefix_skip = prefix_skip + 1
sre_compile.py(452):                 prefixappend(av)
sre_compile.py(448):         for op, av in pattern.data:
sre_compile.py(449):             if op is LITERAL:
sre_compile.py(450):                 if len(prefix) == prefix_skip:
sre_compile.py(451):                     prefix_skip = prefix_skip + 1
sre_compile.py(452):                 prefixappend(av)
sre_compile.py(448):         for op, av in pattern.data:
sre_compile.py(449):             if op is LITERAL:
sre_compile.py(450):                 if len(prefix) == prefix_skip:
sre_compile.py(451):                     prefix_skip = prefix_skip + 1
sre_compile.py(452):                 prefixappend(av)
sre_compile.py(448):         for op, av in pattern.data:
sre_compile.py(449):             if op is LITERAL:
sre_compile.py(450):                 if len(prefix) == prefix_skip:
sre_compile.py(451):                     prefix_skip = prefix_skip + 1
sre_compile.py(452):                 prefixappend(av)
sre_compile.py(448):         for op, av in pattern.data:
sre_compile.py(449):             if op is LITERAL:
sre_compile.py(450):                 if len(prefix) == prefix_skip:
sre_compile.py(451):                     prefix_skip = prefix_skip + 1
sre_compile.py(452):                 prefixappend(av)
sre_compile.py(448):         for op, av in pattern.data:
sre_compile.py(449):             if op is LITERAL:
sre_compile.py(453):             elif op is SUBPATTERN and len(av[1]) == 1:
sre_compile.py(460):                 break
sre_compile.py(462):         if not prefix and pattern.data:
sre_compile.py(501):     emit = code.append
sre_compile.py(502):     emit(OPCODES[INFO])
sre_compile.py(503):     skip = len(code); emit(0)
sre_compile.py(505):     mask = 0
sre_compile.py(506):     if prefix:
sre_compile.py(507):         mask = SRE_INFO_PREFIX
sre_compile.py(508):         if len(prefix) == prefix_skip == len(pattern.data):
sre_compile.py(512):     emit(mask)
sre_compile.py(514):     if lo < MAXCODE:
sre_compile.py(515):         emit(lo)
sre_compile.py(519):     if hi < MAXCODE:
sre_compile.py(522):         emit(0)
sre_compile.py(524):     if prefix:
sre_compile.py(525):         emit(len(prefix)) # length
sre_compile.py(526):         emit(prefix_skip) # skip
sre_compile.py(527):         code.extend(prefix)
sre_compile.py(529):         table = [-1] + ([0]*len(prefix))
sre_compile.py(530):         for i in xrange(len(prefix)):
sre_compile.py(531):             table[i+1] = table[i]+1
sre_compile.py(532):             while table[i+1] > 0 and prefix[i] != prefix[table[i+1]-1]:
sre_compile.py(530):         for i in xrange(len(prefix)):
sre_compile.py(531):             table[i+1] = table[i]+1
sre_compile.py(532):             while table[i+1] > 0 and prefix[i] != prefix[table[i+1]-1]:
sre_compile.py(533):                 table[i+1] = table[table[i+1]-1]+1
sre_compile.py(532):             while table[i+1] > 0 and prefix[i] != prefix[table[i+1]-1]:
sre_compile.py(530):         for i in xrange(len(prefix)):
sre_compile.py(531):             table[i+1] = table[i]+1
sre_compile.py(532):             while table[i+1] > 0 and prefix[i] != prefix[table[i+1]-1]:
sre_compile.py(533):                 table[i+1] = table[table[i+1]-1]+1
sre_compile.py(532):             while table[i+1] > 0 and prefix[i] != prefix[table[i+1]-1]:
sre_compile.py(530):         for i in xrange(len(prefix)):
sre_compile.py(531):             table[i+1] = table[i]+1
sre_compile.py(532):             while table[i+1] > 0 and prefix[i] != prefix[table[i+1]-1]:
sre_compile.py(533):                 table[i+1] = table[table[i+1]-1]+1
sre_compile.py(532):             while table[i+1] > 0 and prefix[i] != prefix[table[i+1]-1]:
sre_compile.py(530):         for i in xrange(len(prefix)):
sre_compile.py(531):             table[i+1] = table[i]+1
sre_compile.py(532):             while table[i+1] > 0 and prefix[i] != prefix[table[i+1]-1]:
sre_compile.py(533):                 table[i+1] = table[table[i+1]-1]+1
sre_compile.py(532):             while table[i+1] > 0 and prefix[i] != prefix[table[i+1]-1]:
sre_compile.py(530):         for i in xrange(len(prefix)):
sre_compile.py(531):             table[i+1] = table[i]+1
sre_compile.py(532):             while table[i+1] > 0 and prefix[i] != prefix[table[i+1]-1]:
sre_compile.py(533):                 table[i+1] = table[table[i+1]-1]+1
sre_compile.py(532):             while table[i+1] > 0 and prefix[i] != prefix[table[i+1]-1]:
sre_compile.py(530):         for i in xrange(len(prefix)):
sre_compile.py(531):             table[i+1] = table[i]+1
sre_compile.py(532):             while table[i+1] > 0 and prefix[i] != prefix[table[i+1]-1]:
sre_compile.py(533):                 table[i+1] = table[table[i+1]-1]+1
sre_compile.py(532):             while table[i+1] > 0 and prefix[i] != prefix[table[i+1]-1]:
sre_compile.py(530):         for i in xrange(len(prefix)):
sre_compile.py(531):             table[i+1] = table[i]+1
sre_compile.py(532):             while table[i+1] > 0 and prefix[i] != prefix[table[i+1]-1]:
sre_compile.py(533):                 table[i+1] = table[table[i+1]-1]+1
sre_compile.py(532):             while table[i+1] > 0 and prefix[i] != prefix[table[i+1]-1]:
sre_compile.py(530):         for i in xrange(len(prefix)):
sre_compile.py(531):             table[i+1] = table[i]+1
sre_compile.py(532):             while table[i+1] > 0 and prefix[i] != prefix[table[i+1]-1]:
sre_compile.py(533):                 table[i+1] = table[table[i+1]-1]+1
sre_compile.py(532):             while table[i+1] > 0 and prefix[i] != prefix[table[i+1]-1]:
sre_compile.py(530):         for i in xrange(len(prefix)):
sre_compile.py(531):             table[i+1] = table[i]+1
sre_compile.py(532):             while table[i+1] > 0 and prefix[i] != prefix[table[i+1]-1]:
sre_compile.py(533):                 table[i+1] = table[table[i+1]-1]+1
sre_compile.py(532):             while table[i+1] > 0 and prefix[i] != prefix[table[i+1]-1]:
sre_compile.py(530):         for i in xrange(len(prefix)):
sre_compile.py(534):         code.extend(table[1:]) # don't store first entry
sre_compile.py(537):     code[skip] = len(code) - skip
sre_compile.py(561):     _compile(code, p.data, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
sre_compile.py(136):                 emit(OPCODES[REPEAT])
sre_compile.py(137):                 skip = _len(code); emit(0)
sre_compile.py(138):                 emit(av[0])
sre_compile.py(139):                 emit(av[1])
sre_compile.py(140):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(141):                 code[skip] = _len(code) - skip
sre_compile.py(142):                 if op is MAX_REPEAT:
sre_compile.py(143):                     emit(OPCODES[MAX_UNTIL])
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(110):             if flags & SRE_FLAG_DOTALL:
sre_compile.py(113):                 emit(OPCODES[ANY])
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(563):     code.append(OPCODES[SUCCESS])
sre_compile.py(565):     return code
sre_compile.py(581):     if p.pattern.groups > 100:
sre_compile.py(587):     groupindex = p.pattern.groupdict
sre_compile.py(588):     indexgroup = [None] * p.pattern.groups
sre_compile.py(589):     for k, i in groupindex.items():
sre_compile.py(592):     return _sre.compile(
sre_compile.py(593):         pattern, flags | p.pattern.flags, code,
sre_compile.py(594):         p.pattern.groups-1,
sre_compile.py(595):         groupindex, indexgroup
re.py(252):     if not bypass_cache:
re.py(253):         if len(_cache) >= _MAXCACHE:
re.py(255):         if p.flags & LOCALE:
re.py(260):             loc = None
re.py(261):         _cache[cachekey] = p, loc
re.py(262):     return p
platform.py(1351): _ironpython26_sys_version_parser = re.compile(
platform.py(1352):     r'([\d.]+)\s*'
 --- modulename: re, funcname: compile
re.py(194):     return _compile(pattern, flags)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(240):         except KeyError:
re.py(241):             pass
re.py(242):     if isinstance(pattern, _pattern_type):
re.py(246):     if not sre_compile.isstring(pattern):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
re.py(248):     try:
re.py(249):         p = sre_compile.compile(pattern, flags)
 --- modulename: sre_compile, funcname: compile
sre_compile.py(570):     if isstring(p):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
sre_compile.py(571):         pattern = p
sre_compile.py(572):         p = sre_parse.parse(p, flags)
 --- modulename: sre_parse, funcname: parse
sre_parse.py(709):     source = Tokenizer(str)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(190):         self.string = string
sre_parse.py(191):         self.index = 0
sre_parse.py(192):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(711):     if pattern is None:
sre_parse.py(712):         pattern = Pattern()
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(68):         self.flags = 0
sre_parse.py(69):         self.open = []
sre_parse.py(70):         self.groups = 1
sre_parse.py(71):         self.groupdict = {}
sre_parse.py(72):         self.lookbehind = 0
sre_parse.py(713):     pattern.flags = flags
sre_parse.py(714):     pattern.str = str
sre_parse.py(716):     p = _parse_sub(source, pattern, 0)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(241):     code = CATEGORIES.get(escape)
sre_parse.py(242):     if code and code[0] == IN:
sre_parse.py(243):         return code
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(476):                         code1 = code1[1][0]
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(495):             elif this == "+":
sre_parse.py(496):                 min, max = 1, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(272):         return code
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(493):                 min, max = 0, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(273):     code = ESCAPES.get(escape)
sre_parse.py(274):     if code:
sre_parse.py(276):     try:
sre_parse.py(277):         c = escape[1:2]
sre_parse.py(278):         if c == "x":
sre_parse.py(285):         elif c == "0":
sre_parse.py(290):         elif c in DIGITS:
sre_parse.py(311):         if len(escape) == 2:
sre_parse.py(312):             return LITERAL, ord(escape[1])
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(272):         return code
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(493):                 min, max = 0, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(241):     code = CATEGORIES.get(escape)
sre_parse.py(242):     if code and code[0] == IN:
sre_parse.py(243):         return code
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(476):                         code1 = code1[1][0]
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(495):             elif this == "+":
sre_parse.py(496):                 min, max = 1, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(272):         return code
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(493):                 min, max = 0, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(273):     code = ESCAPES.get(escape)
sre_parse.py(274):     if code:
sre_parse.py(276):     try:
sre_parse.py(277):         c = escape[1:2]
sre_parse.py(278):         if c == "x":
sre_parse.py(285):         elif c == "0":
sre_parse.py(290):         elif c in DIGITS:
sre_parse.py(311):         if len(escape) == 2:
sre_parse.py(312):             return LITERAL, ord(escape[1])
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(241):     code = CATEGORIES.get(escape)
sre_parse.py(242):     if code and code[0] == IN:
sre_parse.py(243):         return code
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(476):                         code1 = code1[1][0]
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(495):             elif this == "+":
sre_parse.py(496):                 min, max = 1, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(273):     code = ESCAPES.get(escape)
sre_parse.py(274):     if code:
sre_parse.py(276):     try:
sre_parse.py(277):         c = escape[1:2]
sre_parse.py(278):         if c == "x":
sre_parse.py(285):         elif c == "0":
sre_parse.py(290):         elif c in DIGITS:
sre_parse.py(311):         if len(escape) == 2:
sre_parse.py(312):             return LITERAL, ord(escape[1])
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(241):     code = CATEGORIES.get(escape)
sre_parse.py(242):     if code and code[0] == IN:
sre_parse.py(243):         return code
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(476):                         code1 = code1[1][0]
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(495):             elif this == "+":
sre_parse.py(496):                 min, max = 1, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(241):     code = CATEGORIES.get(escape)
sre_parse.py(242):     if code and code[0] == IN:
sre_parse.py(243):         return code
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(476):                         code1 = code1[1][0]
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(495):             elif this == "+":
sre_parse.py(496):                 min, max = 1, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(549):                 group = 0
sre_parse.py(551):                 if sourcematch("P"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(600):                 elif sourcematch(":"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(602):                     group = 2
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(670):                     group = None
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(273):     code = ESCAPES.get(escape)
sre_parse.py(274):     if code:
sre_parse.py(276):     try:
sre_parse.py(277):         c = escape[1:2]
sre_parse.py(278):         if c == "x":
sre_parse.py(285):         elif c == "0":
sre_parse.py(290):         elif c in DIGITS:
sre_parse.py(311):         if len(escape) == 2:
sre_parse.py(312):             return LITERAL, ord(escape[1])
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(272):         return code
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(495):             elif this == "+":
sre_parse.py(496):                 min, max = 1, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(273):     code = ESCAPES.get(escape)
sre_parse.py(274):     if code:
sre_parse.py(276):     try:
sre_parse.py(277):         c = escape[1:2]
sre_parse.py(278):         if c == "x":
sre_parse.py(285):         elif c == "0":
sre_parse.py(290):         elif c in DIGITS:
sre_parse.py(311):         if len(escape) == 2:
sre_parse.py(312):             return LITERAL, ord(escape[1])
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(491):                 min, max = 0, 1
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(273):     code = ESCAPES.get(escape)
sre_parse.py(274):     if code:
sre_parse.py(276):     try:
sre_parse.py(277):         c = escape[1:2]
sre_parse.py(278):         if c == "x":
sre_parse.py(285):         elif c == "0":
sre_parse.py(290):         elif c in DIGITS:
sre_parse.py(311):         if len(escape) == 2:
sre_parse.py(312):             return LITERAL, ord(escape[1])
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(415):             break # end of pattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(328):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(718):     tail = source.get()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(719):     if tail == ")":
sre_parse.py(721):     elif tail:
sre_parse.py(724):     if flags & SRE_FLAG_DEBUG:
sre_parse.py(727):     if not (flags & SRE_FLAG_VERBOSE) and p.pattern.flags & SRE_FLAG_VERBOSE:
sre_parse.py(732):     return p
sre_compile.py(576):     code = _code(p, flags)
 --- modulename: sre_compile, funcname: _code
sre_compile.py(554):     flags = p.pattern.flags | flags
sre_compile.py(555):     code = []
sre_compile.py(558):     _compile_info(code, p, flags)
 --- modulename: sre_compile, funcname: _compile_info
sre_compile.py(437):     lo, hi = pattern.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_compile.py(438):     if lo == 0:
sre_compile.py(441):     prefix = []
sre_compile.py(442):     prefixappend = prefix.append
sre_compile.py(443):     prefix_skip = 0
sre_compile.py(444):     charset = [] # not used
sre_compile.py(445):     charsetappend = charset.append
sre_compile.py(446):     if not (flags & SRE_FLAG_IGNORECASE):
sre_compile.py(448):         for op, av in pattern.data:
sre_compile.py(449):             if op is LITERAL:
sre_compile.py(453):             elif op is SUBPATTERN and len(av[1]) == 1:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_compile.py(454):                 op, av = av[1][0]
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(455):                 if op is LITERAL:
sre_compile.py(458):                     break
sre_compile.py(462):         if not prefix and pattern.data:
sre_compile.py(463):             op, av = pattern.data[0]
sre_compile.py(464):             if op is SUBPATTERN and av[1]:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_compile.py(465):                 op, av = av[1][0]
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(466):                 if op is LITERAL:
sre_compile.py(468):                 elif op is BRANCH:
sre_compile.py(501):     emit = code.append
sre_compile.py(502):     emit(OPCODES[INFO])
sre_compile.py(503):     skip = len(code); emit(0)
sre_compile.py(505):     mask = 0
sre_compile.py(506):     if prefix:
sre_compile.py(510):     elif charset:
sre_compile.py(512):     emit(mask)
sre_compile.py(514):     if lo < MAXCODE:
sre_compile.py(515):         emit(lo)
sre_compile.py(519):     if hi < MAXCODE:
sre_compile.py(522):         emit(0)
sre_compile.py(524):     if prefix:
sre_compile.py(535):     elif charset:
sre_compile.py(537):     code[skip] = len(code) - skip
sre_compile.py(561):     _compile(code, p.data, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
sre_compile.py(136):                 emit(OPCODES[REPEAT])
sre_compile.py(137):                 skip = _len(code); emit(0)
sre_compile.py(138):                 emit(av[0])
sre_compile.py(139):                 emit(av[1])
sre_compile.py(140):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(141):                 code[skip] = _len(code) - skip
sre_compile.py(142):                 if op is MAX_REPEAT:
sre_compile.py(143):                     emit(OPCODES[MAX_UNTIL])
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(563):     code.append(OPCODES[SUCCESS])
sre_compile.py(565):     return code
sre_compile.py(581):     if p.pattern.groups > 100:
sre_compile.py(587):     groupindex = p.pattern.groupdict
sre_compile.py(588):     indexgroup = [None] * p.pattern.groups
sre_compile.py(589):     for k, i in groupindex.items():
sre_compile.py(592):     return _sre.compile(
sre_compile.py(593):         pattern, flags | p.pattern.flags, code,
sre_compile.py(594):         p.pattern.groups-1,
sre_compile.py(595):         groupindex, indexgroup
re.py(252):     if not bypass_cache:
re.py(253):         if len(_cache) >= _MAXCACHE:
re.py(255):         if p.flags & LOCALE:
re.py(260):             loc = None
re.py(261):         _cache[cachekey] = p, loc
re.py(262):     return p
platform.py(1358): _pypy_sys_version_parser = re.compile(
platform.py(1359):     r'([\w.+]+)\s*'
 --- modulename: re, funcname: compile
re.py(194):     return _compile(pattern, flags)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(240):         except KeyError:
re.py(241):             pass
re.py(242):     if isinstance(pattern, _pattern_type):
re.py(246):     if not sre_compile.isstring(pattern):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
re.py(248):     try:
re.py(249):         p = sre_compile.compile(pattern, flags)
 --- modulename: sre_compile, funcname: compile
sre_compile.py(570):     if isstring(p):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
sre_compile.py(571):         pattern = p
sre_compile.py(572):         p = sre_parse.parse(p, flags)
 --- modulename: sre_parse, funcname: parse
sre_parse.py(709):     source = Tokenizer(str)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(190):         self.string = string
sre_parse.py(191):         self.index = 0
sre_parse.py(192):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(711):     if pattern is None:
sre_parse.py(712):         pattern = Pattern()
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(68):         self.flags = 0
sre_parse.py(69):         self.open = []
sre_parse.py(70):         self.groups = 1
sre_parse.py(71):         self.groupdict = {}
sre_parse.py(72):         self.lookbehind = 0
sre_parse.py(713):     pattern.flags = flags
sre_parse.py(714):     pattern.str = str
sre_parse.py(716):     p = _parse_sub(source, pattern, 0)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(241):     code = CATEGORIES.get(escape)
sre_parse.py(242):     if code and code[0] == IN:
sre_parse.py(243):         return code
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(476):                         code1 = code1[1][0]
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(495):             elif this == "+":
sre_parse.py(496):                 min, max = 1, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(272):         return code
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(493):                 min, max = 0, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(273):     code = ESCAPES.get(escape)
sre_parse.py(274):     if code:
sre_parse.py(276):     try:
sre_parse.py(277):         c = escape[1:2]
sre_parse.py(278):         if c == "x":
sre_parse.py(285):         elif c == "0":
sre_parse.py(290):         elif c in DIGITS:
sre_parse.py(311):         if len(escape) == 2:
sre_parse.py(312):             return LITERAL, ord(escape[1])
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(491):                 min, max = 0, 1
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(438):                 setappend((NEGATE, None))
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(483):                 subpatternappend((NOT_LITERAL, set[1][1])) # optimization
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(495):             elif this == "+":
sre_parse.py(496):                 min, max = 1, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(272):         return code
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(493):                 min, max = 0, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(241):     code = CATEGORIES.get(escape)
sre_parse.py(242):     if code and code[0] == IN:
sre_parse.py(243):         return code
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(476):                         code1 = code1[1][0]
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(495):             elif this == "+":
sre_parse.py(496):                 min, max = 1, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(272):         return code
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(493):                 min, max = 0, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(241):     code = CATEGORIES.get(escape)
sre_parse.py(242):     if code and code[0] == IN:
sre_parse.py(243):         return code
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(476):                         code1 = code1[1][0]
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(495):             elif this == "+":
sre_parse.py(496):                 min, max = 1, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(273):     code = ESCAPES.get(escape)
sre_parse.py(274):     if code:
sre_parse.py(276):     try:
sre_parse.py(277):         c = escape[1:2]
sre_parse.py(278):         if c == "x":
sre_parse.py(285):         elif c == "0":
sre_parse.py(290):         elif c in DIGITS:
sre_parse.py(311):         if len(escape) == 2:
sre_parse.py(312):             return LITERAL, ord(escape[1])
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(272):         return code
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(493):                 min, max = 0, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(273):     code = ESCAPES.get(escape)
sre_parse.py(274):     if code:
sre_parse.py(276):     try:
sre_parse.py(277):         c = escape[1:2]
sre_parse.py(278):         if c == "x":
sre_parse.py(285):         elif c == "0":
sre_parse.py(290):         elif c in DIGITS:
sre_parse.py(311):         if len(escape) == 2:
sre_parse.py(312):             return LITERAL, ord(escape[1])
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(438):                 setappend((NEGATE, None))
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(241):     code = CATEGORIES.get(escape)
sre_parse.py(242):     if code and code[0] == IN:
sre_parse.py(244):     try:
sre_parse.py(245):         c = escape[1:2]
sre_parse.py(246):         if c == "x":
sre_parse.py(254):         elif c in OCTDIGITS:
sre_parse.py(260):         elif c in DIGITS:
sre_parse.py(262):         if len(escape) == 2:
sre_parse.py(263):             return LITERAL, ord(escape[1])
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(483):                 subpatternappend((NOT_LITERAL, set[1][1])) # optimization
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(495):             elif this == "+":
sre_parse.py(496):                 min, max = 1, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(273):     code = ESCAPES.get(escape)
sre_parse.py(274):     if code:
sre_parse.py(276):     try:
sre_parse.py(277):         c = escape[1:2]
sre_parse.py(278):         if c == "x":
sre_parse.py(285):         elif c == "0":
sre_parse.py(290):         elif c in DIGITS:
sre_parse.py(311):         if len(escape) == 2:
sre_parse.py(312):             return LITERAL, ord(escape[1])
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(491):                 min, max = 0, 1
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(415):             break # end of pattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(328):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(718):     tail = source.get()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(719):     if tail == ")":
sre_parse.py(721):     elif tail:
sre_parse.py(724):     if flags & SRE_FLAG_DEBUG:
sre_parse.py(727):     if not (flags & SRE_FLAG_VERBOSE) and p.pattern.flags & SRE_FLAG_VERBOSE:
sre_parse.py(732):     return p
sre_compile.py(576):     code = _code(p, flags)
 --- modulename: sre_compile, funcname: _code
sre_compile.py(554):     flags = p.pattern.flags | flags
sre_compile.py(555):     code = []
sre_compile.py(558):     _compile_info(code, p, flags)
 --- modulename: sre_compile, funcname: _compile_info
sre_compile.py(437):     lo, hi = pattern.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_compile.py(438):     if lo == 0:
sre_compile.py(441):     prefix = []
sre_compile.py(442):     prefixappend = prefix.append
sre_compile.py(443):     prefix_skip = 0
sre_compile.py(444):     charset = [] # not used
sre_compile.py(445):     charsetappend = charset.append
sre_compile.py(446):     if not (flags & SRE_FLAG_IGNORECASE):
sre_compile.py(448):         for op, av in pattern.data:
sre_compile.py(449):             if op is LITERAL:
sre_compile.py(453):             elif op is SUBPATTERN and len(av[1]) == 1:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_compile.py(454):                 op, av = av[1][0]
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(455):                 if op is LITERAL:
sre_compile.py(458):                     break
sre_compile.py(462):         if not prefix and pattern.data:
sre_compile.py(463):             op, av = pattern.data[0]
sre_compile.py(464):             if op is SUBPATTERN and av[1]:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_compile.py(465):                 op, av = av[1][0]
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(466):                 if op is LITERAL:
sre_compile.py(468):                 elif op is BRANCH:
sre_compile.py(501):     emit = code.append
sre_compile.py(502):     emit(OPCODES[INFO])
sre_compile.py(503):     skip = len(code); emit(0)
sre_compile.py(505):     mask = 0
sre_compile.py(506):     if prefix:
sre_compile.py(510):     elif charset:
sre_compile.py(512):     emit(mask)
sre_compile.py(514):     if lo < MAXCODE:
sre_compile.py(515):         emit(lo)
sre_compile.py(519):     if hi < MAXCODE:
sre_compile.py(522):         emit(0)
sre_compile.py(524):     if prefix:
sre_compile.py(535):     elif charset:
sre_compile.py(537):     code[skip] = len(code) - skip
sre_compile.py(561):     _compile(code, p.data, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(563):     code.append(OPCODES[SUCCESS])
sre_compile.py(565):     return code
sre_compile.py(581):     if p.pattern.groups > 100:
sre_compile.py(587):     groupindex = p.pattern.groupdict
sre_compile.py(588):     indexgroup = [None] * p.pattern.groups
sre_compile.py(589):     for k, i in groupindex.items():
sre_compile.py(592):     return _sre.compile(
sre_compile.py(593):         pattern, flags | p.pattern.flags, code,
sre_compile.py(594):         p.pattern.groups-1,
sre_compile.py(595):         groupindex, indexgroup
re.py(252):     if not bypass_cache:
re.py(253):         if len(_cache) >= _MAXCACHE:
re.py(255):         if p.flags & LOCALE:
re.py(260):             loc = None
re.py(261):         _cache[cachekey] = p, loc
re.py(262):     return p
platform.py(1363): _sys_version_cache = {}
platform.py(1365): def _sys_version(sys_version=None):
platform.py(1463): def python_implementation():
platform.py(1476): def python_version():
platform.py(1486): def python_version_tuple():
platform.py(1497): def python_branch():
platform.py(1511): def python_revision():
platform.py(1524): def python_build():
platform.py(1532): def python_compiler():
platform.py(1542): _platform_cache = {}
platform.py(1544): def platform(aliased=0, terse=0):
platform.py(1626): if __name__ == '__main__':
control.py(10): import re
control.py(11): import sys
control.py(12): import traceback
control.py(14): from coverage import env, files
 --- modulename: env, funcname: <module>
env.py(4): """Determine facts about the environment."""
env.py(6): import os
env.py(7): import sys
env.py(10): WINDOWS = sys.platform == "win32"
env.py(11): LINUX = sys.platform == "linux2"
env.py(14): PYPY = '__pypy__' in sys.builtin_module_names
env.py(17): PYVERSION = sys.version_info
env.py(18): PY2 = PYVERSION < (3, 0)
env.py(19): PY3 = PYVERSION >= (3, 0)
env.py(24): C_TRACER = os.getenv('COVERAGE_TEST_TRACER', 'c') == 'c'
 --- modulename: os, funcname: getenv
os.py(515):     return environ.get(key, default)
 --- modulename: UserDict, funcname: get
UserDict.py(92):         if key not in self:
 --- modulename: UserDict, funcname: __contains__
UserDict.py(104):         return key in self.data
UserDict.py(93):             return failobj
env.py(27): METACOV = os.getenv('COVERAGE_COVERAGE', '') != ''
 --- modulename: os, funcname: getenv
os.py(515):     return environ.get(key, default)
 --- modulename: UserDict, funcname: get
UserDict.py(92):         if key not in self:
 --- modulename: UserDict, funcname: __contains__
UserDict.py(104):         return key in self.data
UserDict.py(93):             return failobj
env.py(32): TESTING = os.getenv('COVERAGE_TESTING', '') == 'True'
 --- modulename: os, funcname: getenv
os.py(515):     return environ.get(key, default)
 --- modulename: UserDict, funcname: get
UserDict.py(92):         if key not in self:
 --- modulename: UserDict, funcname: __contains__
UserDict.py(104):         return key in self.data
UserDict.py(93):             return failobj
 --- modulename: files, funcname: <module>
files.py(4): """File wrangling."""
files.py(6): import fnmatch
 --- modulename: fnmatch, funcname: <module>
fnmatch.py(11): """
fnmatch.py(13): import re
fnmatch.py(15): __all__ = ["filter", "fnmatch", "fnmatchcase", "translate"]
fnmatch.py(17): _cache = {}
fnmatch.py(18): _MAXCACHE = 100
fnmatch.py(20): def _purge():
fnmatch.py(24): def fnmatch(name, pat):
fnmatch.py(45): def filter(names, pat):
fnmatch.py(69): def fnmatchcase(name, pat):
fnmatch.py(85): def translate(pat):
files.py(7): import ntpath
 --- modulename: ntpath, funcname: <module>
ntpath.py(6): """
ntpath.py(8): import os
ntpath.py(9): import sys
ntpath.py(10): import stat
ntpath.py(11): import genericpath
ntpath.py(12): import warnings
ntpath.py(14): from genericpath import *
ntpath.py(15): from genericpath import _unicode
ntpath.py(17): __all__ = ["normcase","isabs","join","splitdrive","split","splitext",
ntpath.py(18):            "basename","dirname","commonprefix","getsize","getmtime",
ntpath.py(19):            "getatime","getctime", "islink","exists","lexists","isdir","isfile",
ntpath.py(20):            "ismount","walk","expanduser","expandvars","normpath","abspath",
ntpath.py(21):            "splitunc","curdir","pardir","sep","pathsep","defpath","altsep",
ntpath.py(22):            "extsep","devnull","realpath","supports_unicode_filenames","relpath"]
ntpath.py(25): curdir = '.'
ntpath.py(26): pardir = '..'
ntpath.py(27): extsep = '.'
ntpath.py(28): sep = '\\'
ntpath.py(29): pathsep = ';'
ntpath.py(30): altsep = '/'
ntpath.py(31): defpath = '.;C:\\bin'
ntpath.py(32): if 'ce' in sys.builtin_module_names:
ntpath.py(34): elif 'os2' in sys.builtin_module_names:
ntpath.py(37): devnull = 'nul'
ntpath.py(43): def normcase(s):
ntpath.py(56): def isabs(s):
ntpath.py(63): def join(path, *paths):
ntpath.py(96): def splitdrive(p):
ntpath.py(138): def splitunc(p):
ntpath.py(174): def split(p):
ntpath.py(199): def splitext(p):
ntpath.py(201): splitext.__doc__ = genericpath._splitext.__doc__
ntpath.py(206): def basename(p):
ntpath.py(213): def dirname(p):
ntpath.py(220): def islink(path):
ntpath.py(227): lexists = exists
ntpath.py(232): def ismount(path):
ntpath.py(249): def walk(top, func, arg):
ntpath.py(285): def expanduser(path):
ntpath.py(327): def expandvars(path):
ntpath.py(415): def normpath(path):
ntpath.py(468): try:
ntpath.py(469):     from nt import _getfullpathname
ntpath.py(471): except ImportError: # not running on Windows - mock up something sensible
ntpath.py(472):     def abspath(path):
ntpath.py(498): realpath = abspath
ntpath.py(500): supports_unicode_filenames = (hasattr(sys, "getwindowsversion") and
ntpath.py(503): def _abspath_split(path):
ntpath.py(511): def relpath(path, start=curdir):
ntpath.py(542): try:
ntpath.py(547):     from nt import _isdir as isdir
ntpath.py(548): except ImportError:
ntpath.py(550):     pass
files.py(8): import os
files.py(9): import os.path
files.py(10): import posixpath
files.py(11): import re
files.py(12): import sys
files.py(14): from coverage import env
files.py(15): from coverage.backward import unicode_class
 --- modulename: backward, funcname: <module>
backward.py(4): """Add things to old Pythons so I can pretend they are newer."""
backward.py(11): import sys
backward.py(13): from coverage import env
backward.py(17): try:
backward.py(18):     from cStringIO import StringIO
backward.py(23): try:
backward.py(24):     import configparser
backward.py(25): except ImportError:
backward.py(26):     import ConfigParser as configparser
 --- modulename: ConfigParser, funcname: <module>
ConfigParser.py(88): """
ConfigParser.py(90): try:
ConfigParser.py(91):     from collections import OrderedDict as _default_dict
ConfigParser.py(96): import re
ConfigParser.py(98): __all__ = ["NoSectionError", "DuplicateSectionError", "NoOptionError",
ConfigParser.py(99):            "InterpolationError", "InterpolationDepthError",
ConfigParser.py(100):            "InterpolationSyntaxError", "ParsingError",
ConfigParser.py(101):            "MissingSectionHeaderError",
ConfigParser.py(102):            "ConfigParser", "SafeConfigParser", "RawConfigParser",
ConfigParser.py(103):            "DEFAULTSECT", "MAX_INTERPOLATION_DEPTH"]
ConfigParser.py(105): DEFAULTSECT = "DEFAULT"
ConfigParser.py(107): MAX_INTERPOLATION_DEPTH = 10
ConfigParser.py(112): class Error(Exception):
 --- modulename: ConfigParser, funcname: Error
ConfigParser.py(112): class Error(Exception):
ConfigParser.py(113):     """Base class for ConfigParser exceptions."""
ConfigParser.py(115):     def _get_message(self):
ConfigParser.py(120):     def _set_message(self, value):
ConfigParser.py(128):     message = property(_get_message, _set_message)
ConfigParser.py(130):     def __init__(self, msg=''):
ConfigParser.py(134):     def __repr__(self):
ConfigParser.py(137):     __str__ = __repr__
ConfigParser.py(139): class NoSectionError(Error):
 --- modulename: ConfigParser, funcname: NoSectionError
ConfigParser.py(139): class NoSectionError(Error):
ConfigParser.py(140):     """Raised when no section matches a requested option."""
ConfigParser.py(142):     def __init__(self, section):
ConfigParser.py(147): class DuplicateSectionError(Error):
 --- modulename: ConfigParser, funcname: DuplicateSectionError
ConfigParser.py(147): class DuplicateSectionError(Error):
ConfigParser.py(148):     """Raised when a section is multiply-created."""
ConfigParser.py(150):     def __init__(self, section):
ConfigParser.py(155): class NoOptionError(Error):
 --- modulename: ConfigParser, funcname: NoOptionError
ConfigParser.py(155): class NoOptionError(Error):
ConfigParser.py(156):     """A requested option was not found."""
ConfigParser.py(158):     def __init__(self, option, section):
ConfigParser.py(165): class InterpolationError(Error):
 --- modulename: ConfigParser, funcname: InterpolationError
ConfigParser.py(165): class InterpolationError(Error):
ConfigParser.py(166):     """Base class for interpolation-related exceptions."""
ConfigParser.py(168):     def __init__(self, option, section, msg):
ConfigParser.py(174): class InterpolationMissingOptionError(InterpolationError):
 --- modulename: ConfigParser, funcname: InterpolationMissingOptionError
ConfigParser.py(174): class InterpolationMissingOptionError(InterpolationError):
ConfigParser.py(175):     """A string substitution required a setting which was not available."""
ConfigParser.py(177):     def __init__(self, option, section, rawval, reference):
ConfigParser.py(188): class InterpolationSyntaxError(InterpolationError):
 --- modulename: ConfigParser, funcname: InterpolationSyntaxError
ConfigParser.py(188): class InterpolationSyntaxError(InterpolationError):
ConfigParser.py(190):     does not conform to the required syntax."""
ConfigParser.py(192): class InterpolationDepthError(InterpolationError):
 --- modulename: ConfigParser, funcname: InterpolationDepthError
ConfigParser.py(192): class InterpolationDepthError(InterpolationError):
ConfigParser.py(193):     """Raised when substitutions are nested too deeply."""
ConfigParser.py(195):     def __init__(self, option, section, rawval):
ConfigParser.py(204): class ParsingError(Error):
 --- modulename: ConfigParser, funcname: ParsingError
ConfigParser.py(204): class ParsingError(Error):
ConfigParser.py(205):     """Raised when a configuration file does not follow legal syntax."""
ConfigParser.py(207):     def __init__(self, filename):
ConfigParser.py(213):     def append(self, lineno, line):
ConfigParser.py(217): class MissingSectionHeaderError(ParsingError):
 --- modulename: ConfigParser, funcname: MissingSectionHeaderError
ConfigParser.py(217): class MissingSectionHeaderError(ParsingError):
ConfigParser.py(218):     """Raised when a key-value pair is found before any section header."""
ConfigParser.py(220):     def __init__(self, filename, lineno, line):
ConfigParser.py(231): class RawConfigParser:
 --- modulename: ConfigParser, funcname: RawConfigParser
ConfigParser.py(231): class RawConfigParser:
ConfigParser.py(232):     def __init__(self, defaults=None, dict_type=_default_dict,
ConfigParser.py(233):                  allow_no_value=False):
ConfigParser.py(245):     def defaults(self):
ConfigParser.py(248):     def sections(self):
ConfigParser.py(253):     def add_section(self, section):
ConfigParser.py(267):     def has_section(self, section):
ConfigParser.py(274):     def options(self, section):
ConfigParser.py(285):     def read(self, filenames):
ConfigParser.py(310):     def readfp(self, fp, filename=None):
ConfigParser.py(326):     def get(self, section, option):
ConfigParser.py(342):     def items(self, section):
ConfigParser.py(355):     def _get(self, section, conv, option):
ConfigParser.py(358):     def getint(self, section, option):
ConfigParser.py(361):     def getfloat(self, section, option):
ConfigParser.py(364):     _boolean_states = {'1': True, 'yes': True, 'true': True, 'on': True,
ConfigParser.py(365):                        '0': False, 'no': False, 'false': False, 'off': False}
ConfigParser.py(367):     def getboolean(self, section, option):
ConfigParser.py(373):     def optionxform(self, optionstr):
ConfigParser.py(376):     def has_option(self, section, option):
ConfigParser.py(388):     def set(self, section, option, value=None):
ConfigParser.py(399):     def write(self, fp):
ConfigParser.py(416):     def remove_option(self, section, option):
ConfigParser.py(431):     def remove_section(self, section):
ConfigParser.py(441):     SECTCRE = re.compile(
ConfigParser.py(442):         r'\['                                 # [
 --- modulename: re, funcname: compile
re.py(194):     return _compile(pattern, flags)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(240):         except KeyError:
re.py(241):             pass
re.py(242):     if isinstance(pattern, _pattern_type):
re.py(246):     if not sre_compile.isstring(pattern):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
re.py(248):     try:
re.py(249):         p = sre_compile.compile(pattern, flags)
 --- modulename: sre_compile, funcname: compile
sre_compile.py(570):     if isstring(p):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
sre_compile.py(571):         pattern = p
sre_compile.py(572):         p = sre_parse.parse(p, flags)
 --- modulename: sre_parse, funcname: parse
sre_parse.py(709):     source = Tokenizer(str)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(190):         self.string = string
sre_parse.py(191):         self.index = 0
sre_parse.py(192):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(711):     if pattern is None:
sre_parse.py(712):         pattern = Pattern()
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(68):         self.flags = 0
sre_parse.py(69):         self.open = []
sre_parse.py(70):         self.groups = 1
sre_parse.py(71):         self.groupdict = {}
sre_parse.py(72):         self.lookbehind = 0
sre_parse.py(713):     pattern.flags = flags
sre_parse.py(714):     pattern.str = str
sre_parse.py(716):     p = _parse_sub(source, pattern, 0)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(273):     code = ESCAPES.get(escape)
sre_parse.py(274):     if code:
sre_parse.py(276):     try:
sre_parse.py(277):         c = escape[1:2]
sre_parse.py(278):         if c == "x":
sre_parse.py(285):         elif c == "0":
sre_parse.py(290):         elif c in DIGITS:
sre_parse.py(311):         if len(escape) == 2:
sre_parse.py(312):             return LITERAL, ord(escape[1])
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(549):                 group = 0
sre_parse.py(551):                 if sourcematch("P"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(553):                     if sourcematch("<"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(555):                         name = ""
sre_parse.py(556):                         while 1:
sre_parse.py(557):                             char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(558):                             if char is None:
sre_parse.py(560):                             if char == ">":
sre_parse.py(562):                             name = name + char
sre_parse.py(557):                             char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(558):                             if char is None:
sre_parse.py(560):                             if char == ">":
sre_parse.py(562):                             name = name + char
sre_parse.py(557):                             char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(558):                             if char is None:
sre_parse.py(560):                             if char == ">":
sre_parse.py(562):                             name = name + char
sre_parse.py(557):                             char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(558):                             if char is None:
sre_parse.py(560):                             if char == ">":
sre_parse.py(562):                             name = name + char
sre_parse.py(557):                             char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(558):                             if char is None:
sre_parse.py(560):                             if char == ">":
sre_parse.py(562):                             name = name + char
sre_parse.py(557):                             char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(558):                             if char is None:
sre_parse.py(560):                             if char == ">":
sre_parse.py(562):                             name = name + char
sre_parse.py(557):                             char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(558):                             if char is None:
sre_parse.py(560):                             if char == ">":
sre_parse.py(561):                                 break
sre_parse.py(563):                         group = 1
sre_parse.py(564):                         if not name:
sre_parse.py(566):                         if not isname(name):
 --- modulename: sre_parse, funcname: isname
sre_parse.py(229):     if not isident(name[0]):
 --- modulename: sre_parse, funcname: isident
sre_parse.py(222):     return "a" <= char <= "z" or "A" <= char <= "Z" or char == "_"
sre_parse.py(231):     for char in name[1:]:
sre_parse.py(232):         if not isident(char) and not isdigit(char):
 --- modulename: sre_parse, funcname: isident
sre_parse.py(222):     return "a" <= char <= "z" or "A" <= char <= "Z" or char == "_"
sre_parse.py(231):     for char in name[1:]:
sre_parse.py(232):         if not isident(char) and not isdigit(char):
 --- modulename: sre_parse, funcname: isident
sre_parse.py(222):     return "a" <= char <= "z" or "A" <= char <= "Z" or char == "_"
sre_parse.py(231):     for char in name[1:]:
sre_parse.py(232):         if not isident(char) and not isdigit(char):
 --- modulename: sre_parse, funcname: isident
sre_parse.py(222):     return "a" <= char <= "z" or "A" <= char <= "Z" or char == "_"
sre_parse.py(231):     for char in name[1:]:
sre_parse.py(232):         if not isident(char) and not isdigit(char):
 --- modulename: sre_parse, funcname: isident
sre_parse.py(222):     return "a" <= char <= "z" or "A" <= char <= "Z" or char == "_"
sre_parse.py(231):     for char in name[1:]:
sre_parse.py(232):         if not isident(char) and not isdigit(char):
 --- modulename: sre_parse, funcname: isident
sre_parse.py(222):     return "a" <= char <= "z" or "A" <= char <= "Z" or char == "_"
sre_parse.py(231):     for char in name[1:]:
sre_parse.py(234):     return True
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(78):             ogid = self.groupdict.get(name, None)
sre_parse.py(79):             if ogid is not None:
sre_parse.py(82):             self.groupdict[name] = gid
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(438):                 setappend((NEGATE, None))
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(483):                 subpatternappend((NOT_LITERAL, set[1][1])) # optimization
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(495):             elif this == "+":
sre_parse.py(496):                 min, max = 1, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(273):     code = ESCAPES.get(escape)
sre_parse.py(274):     if code:
sre_parse.py(276):     try:
sre_parse.py(277):         c = escape[1:2]
sre_parse.py(278):         if c == "x":
sre_parse.py(285):         elif c == "0":
sre_parse.py(290):         elif c in DIGITS:
sre_parse.py(311):         if len(escape) == 2:
sre_parse.py(312):             return LITERAL, ord(escape[1])
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(415):             break # end of pattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(328):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(718):     tail = source.get()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(719):     if tail == ")":
sre_parse.py(721):     elif tail:
sre_parse.py(724):     if flags & SRE_FLAG_DEBUG:
sre_parse.py(727):     if not (flags & SRE_FLAG_VERBOSE) and p.pattern.flags & SRE_FLAG_VERBOSE:
sre_parse.py(732):     return p
sre_compile.py(576):     code = _code(p, flags)
 --- modulename: sre_compile, funcname: _code
sre_compile.py(554):     flags = p.pattern.flags | flags
sre_compile.py(555):     code = []
sre_compile.py(558):     _compile_info(code, p, flags)
 --- modulename: sre_compile, funcname: _compile_info
sre_compile.py(437):     lo, hi = pattern.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_compile.py(438):     if lo == 0:
sre_compile.py(441):     prefix = []
sre_compile.py(442):     prefixappend = prefix.append
sre_compile.py(443):     prefix_skip = 0
sre_compile.py(444):     charset = [] # not used
sre_compile.py(445):     charsetappend = charset.append
sre_compile.py(446):     if not (flags & SRE_FLAG_IGNORECASE):
sre_compile.py(448):         for op, av in pattern.data:
sre_compile.py(449):             if op is LITERAL:
sre_compile.py(450):                 if len(prefix) == prefix_skip:
sre_compile.py(451):                     prefix_skip = prefix_skip + 1
sre_compile.py(452):                 prefixappend(av)
sre_compile.py(448):         for op, av in pattern.data:
sre_compile.py(449):             if op is LITERAL:
sre_compile.py(453):             elif op is SUBPATTERN and len(av[1]) == 1:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_compile.py(454):                 op, av = av[1][0]
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(455):                 if op is LITERAL:
sre_compile.py(458):                     break
sre_compile.py(462):         if not prefix and pattern.data:
sre_compile.py(501):     emit = code.append
sre_compile.py(502):     emit(OPCODES[INFO])
sre_compile.py(503):     skip = len(code); emit(0)
sre_compile.py(505):     mask = 0
sre_compile.py(506):     if prefix:
sre_compile.py(507):         mask = SRE_INFO_PREFIX
sre_compile.py(508):         if len(prefix) == prefix_skip == len(pattern.data):
sre_compile.py(512):     emit(mask)
sre_compile.py(514):     if lo < MAXCODE:
sre_compile.py(515):         emit(lo)
sre_compile.py(519):     if hi < MAXCODE:
sre_compile.py(522):         emit(0)
sre_compile.py(524):     if prefix:
sre_compile.py(525):         emit(len(prefix)) # length
sre_compile.py(526):         emit(prefix_skip) # skip
sre_compile.py(527):         code.extend(prefix)
sre_compile.py(529):         table = [-1] + ([0]*len(prefix))
sre_compile.py(530):         for i in xrange(len(prefix)):
sre_compile.py(531):             table[i+1] = table[i]+1
sre_compile.py(532):             while table[i+1] > 0 and prefix[i] != prefix[table[i+1]-1]:
sre_compile.py(530):         for i in xrange(len(prefix)):
sre_compile.py(534):         code.extend(table[1:]) # don't store first entry
sre_compile.py(537):     code[skip] = len(code) - skip
sre_compile.py(561):     _compile(code, p.data, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(563):     code.append(OPCODES[SUCCESS])
sre_compile.py(565):     return code
sre_compile.py(581):     if p.pattern.groups > 100:
sre_compile.py(587):     groupindex = p.pattern.groupdict
sre_compile.py(588):     indexgroup = [None] * p.pattern.groups
sre_compile.py(589):     for k, i in groupindex.items():
sre_compile.py(590):         indexgroup[i] = k
sre_compile.py(589):     for k, i in groupindex.items():
sre_compile.py(592):     return _sre.compile(
sre_compile.py(593):         pattern, flags | p.pattern.flags, code,
sre_compile.py(594):         p.pattern.groups-1,
sre_compile.py(595):         groupindex, indexgroup
re.py(252):     if not bypass_cache:
re.py(253):         if len(_cache) >= _MAXCACHE:
re.py(255):         if p.flags & LOCALE:
re.py(260):             loc = None
re.py(261):         _cache[cachekey] = p, loc
re.py(262):     return p
ConfigParser.py(446):     OPTCRE = re.compile(
ConfigParser.py(447):         r'(?P<option>[^:=\s][^:=]*)'          # very permissive!
 --- modulename: re, funcname: compile
re.py(194):     return _compile(pattern, flags)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(240):         except KeyError:
re.py(241):             pass
re.py(242):     if isinstance(pattern, _pattern_type):
re.py(246):     if not sre_compile.isstring(pattern):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
re.py(248):     try:
re.py(249):         p = sre_compile.compile(pattern, flags)
 --- modulename: sre_compile, funcname: compile
sre_compile.py(570):     if isstring(p):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
sre_compile.py(571):         pattern = p
sre_compile.py(572):         p = sre_parse.parse(p, flags)
 --- modulename: sre_parse, funcname: parse
sre_parse.py(709):     source = Tokenizer(str)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(190):         self.string = string
sre_parse.py(191):         self.index = 0
sre_parse.py(192):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(711):     if pattern is None:
sre_parse.py(712):         pattern = Pattern()
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(68):         self.flags = 0
sre_parse.py(69):         self.open = []
sre_parse.py(70):         self.groups = 1
sre_parse.py(71):         self.groupdict = {}
sre_parse.py(72):         self.lookbehind = 0
sre_parse.py(713):     pattern.flags = flags
sre_parse.py(714):     pattern.str = str
sre_parse.py(716):     p = _parse_sub(source, pattern, 0)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(549):                 group = 0
sre_parse.py(551):                 if sourcematch("P"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(553):                     if sourcematch("<"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(555):                         name = ""
sre_parse.py(556):                         while 1:
sre_parse.py(557):                             char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(558):                             if char is None:
sre_parse.py(560):                             if char == ">":
sre_parse.py(562):                             name = name + char
sre_parse.py(557):                             char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(558):                             if char is None:
sre_parse.py(560):                             if char == ">":
sre_parse.py(562):                             name = name + char
sre_parse.py(557):                             char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(558):                             if char is None:
sre_parse.py(560):                             if char == ">":
sre_parse.py(562):                             name = name + char
sre_parse.py(557):                             char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(558):                             if char is None:
sre_parse.py(560):                             if char == ">":
sre_parse.py(562):                             name = name + char
sre_parse.py(557):                             char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(558):                             if char is None:
sre_parse.py(560):                             if char == ">":
sre_parse.py(562):                             name = name + char
sre_parse.py(557):                             char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(558):                             if char is None:
sre_parse.py(560):                             if char == ">":
sre_parse.py(562):                             name = name + char
sre_parse.py(557):                             char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(558):                             if char is None:
sre_parse.py(560):                             if char == ">":
sre_parse.py(561):                                 break
sre_parse.py(563):                         group = 1
sre_parse.py(564):                         if not name:
sre_parse.py(566):                         if not isname(name):
 --- modulename: sre_parse, funcname: isname
sre_parse.py(229):     if not isident(name[0]):
 --- modulename: sre_parse, funcname: isident
sre_parse.py(222):     return "a" <= char <= "z" or "A" <= char <= "Z" or char == "_"
sre_parse.py(231):     for char in name[1:]:
sre_parse.py(232):         if not isident(char) and not isdigit(char):
 --- modulename: sre_parse, funcname: isident
sre_parse.py(222):     return "a" <= char <= "z" or "A" <= char <= "Z" or char == "_"
sre_parse.py(231):     for char in name[1:]:
sre_parse.py(232):         if not isident(char) and not isdigit(char):
 --- modulename: sre_parse, funcname: isident
sre_parse.py(222):     return "a" <= char <= "z" or "A" <= char <= "Z" or char == "_"
sre_parse.py(231):     for char in name[1:]:
sre_parse.py(232):         if not isident(char) and not isdigit(char):
 --- modulename: sre_parse, funcname: isident
sre_parse.py(222):     return "a" <= char <= "z" or "A" <= char <= "Z" or char == "_"
sre_parse.py(231):     for char in name[1:]:
sre_parse.py(232):         if not isident(char) and not isdigit(char):
 --- modulename: sre_parse, funcname: isident
sre_parse.py(222):     return "a" <= char <= "z" or "A" <= char <= "Z" or char == "_"
sre_parse.py(231):     for char in name[1:]:
sre_parse.py(232):         if not isident(char) and not isdigit(char):
 --- modulename: sre_parse, funcname: isident
sre_parse.py(222):     return "a" <= char <= "z" or "A" <= char <= "Z" or char == "_"
sre_parse.py(231):     for char in name[1:]:
sre_parse.py(234):     return True
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(78):             ogid = self.groupdict.get(name, None)
sre_parse.py(79):             if ogid is not None:
sre_parse.py(82):             self.groupdict[name] = gid
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(438):                 setappend((NEGATE, None))
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(241):     code = CATEGORIES.get(escape)
sre_parse.py(242):     if code and code[0] == IN:
sre_parse.py(243):         return code
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(476):                         code1 = code1[1][0]
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(438):                 setappend((NEGATE, None))
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(493):                 min, max = 0, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(272):         return code
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(493):                 min, max = 0, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(549):                 group = 0
sre_parse.py(551):                 if sourcematch("P"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(553):                     if sourcematch("<"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(555):                         name = ""
sre_parse.py(556):                         while 1:
sre_parse.py(557):                             char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(558):                             if char is None:
sre_parse.py(560):                             if char == ">":
sre_parse.py(562):                             name = name + char
sre_parse.py(557):                             char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(558):                             if char is None:
sre_parse.py(560):                             if char == ">":
sre_parse.py(562):                             name = name + char
sre_parse.py(557):                             char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(558):                             if char is None:
sre_parse.py(560):                             if char == ">":
sre_parse.py(561):                                 break
sre_parse.py(563):                         group = 1
sre_parse.py(564):                         if not name:
sre_parse.py(566):                         if not isname(name):
 --- modulename: sre_parse, funcname: isname
sre_parse.py(229):     if not isident(name[0]):
 --- modulename: sre_parse, funcname: isident
sre_parse.py(222):     return "a" <= char <= "z" or "A" <= char <= "Z" or char == "_"
sre_parse.py(231):     for char in name[1:]:
sre_parse.py(232):         if not isident(char) and not isdigit(char):
 --- modulename: sre_parse, funcname: isident
sre_parse.py(222):     return "a" <= char <= "z" or "A" <= char <= "Z" or char == "_"
sre_parse.py(231):     for char in name[1:]:
sre_parse.py(234):     return True
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(78):             ogid = self.groupdict.get(name, None)
sre_parse.py(79):             if ogid is not None:
sre_parse.py(82):             self.groupdict[name] = gid
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(272):         return code
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(493):                 min, max = 0, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(549):                 group = 0
sre_parse.py(551):                 if sourcematch("P"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(553):                     if sourcematch("<"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(555):                         name = ""
sre_parse.py(556):                         while 1:
sre_parse.py(557):                             char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(558):                             if char is None:
sre_parse.py(560):                             if char == ">":
sre_parse.py(562):                             name = name + char
sre_parse.py(557):                             char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(558):                             if char is None:
sre_parse.py(560):                             if char == ">":
sre_parse.py(562):                             name = name + char
sre_parse.py(557):                             char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(558):                             if char is None:
sre_parse.py(560):                             if char == ">":
sre_parse.py(562):                             name = name + char
sre_parse.py(557):                             char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(558):                             if char is None:
sre_parse.py(560):                             if char == ">":
sre_parse.py(562):                             name = name + char
sre_parse.py(557):                             char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(558):                             if char is None:
sre_parse.py(560):                             if char == ">":
sre_parse.py(562):                             name = name + char
sre_parse.py(557):                             char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(558):                             if char is None:
sre_parse.py(560):                             if char == ">":
sre_parse.py(561):                                 break
sre_parse.py(563):                         group = 1
sre_parse.py(564):                         if not name:
sre_parse.py(566):                         if not isname(name):
 --- modulename: sre_parse, funcname: isname
sre_parse.py(229):     if not isident(name[0]):
 --- modulename: sre_parse, funcname: isident
sre_parse.py(222):     return "a" <= char <= "z" or "A" <= char <= "Z" or char == "_"
sre_parse.py(231):     for char in name[1:]:
sre_parse.py(232):         if not isident(char) and not isdigit(char):
 --- modulename: sre_parse, funcname: isident
sre_parse.py(222):     return "a" <= char <= "z" or "A" <= char <= "Z" or char == "_"
sre_parse.py(231):     for char in name[1:]:
sre_parse.py(232):         if not isident(char) and not isdigit(char):
 --- modulename: sre_parse, funcname: isident
sre_parse.py(222):     return "a" <= char <= "z" or "A" <= char <= "Z" or char == "_"
sre_parse.py(231):     for char in name[1:]:
sre_parse.py(232):         if not isident(char) and not isdigit(char):
 --- modulename: sre_parse, funcname: isident
sre_parse.py(222):     return "a" <= char <= "z" or "A" <= char <= "Z" or char == "_"
sre_parse.py(231):     for char in name[1:]:
sre_parse.py(232):         if not isident(char) and not isdigit(char):
 --- modulename: sre_parse, funcname: isident
sre_parse.py(222):     return "a" <= char <= "z" or "A" <= char <= "Z" or char == "_"
sre_parse.py(231):     for char in name[1:]:
sre_parse.py(234):     return True
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(78):             ogid = self.groupdict.get(name, None)
sre_parse.py(79):             if ogid is not None:
sre_parse.py(82):             self.groupdict[name] = gid
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(542):             subpatternappend((ANY, None))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(493):                 min, max = 0, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(695):             subpattern.append((AT, AT_END))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(415):             break # end of pattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(328):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(718):     tail = source.get()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(719):     if tail == ")":
sre_parse.py(721):     elif tail:
sre_parse.py(724):     if flags & SRE_FLAG_DEBUG:
sre_parse.py(727):     if not (flags & SRE_FLAG_VERBOSE) and p.pattern.flags & SRE_FLAG_VERBOSE:
sre_parse.py(732):     return p
sre_compile.py(576):     code = _code(p, flags)
 --- modulename: sre_compile, funcname: _code
sre_compile.py(554):     flags = p.pattern.flags | flags
sre_compile.py(555):     code = []
sre_compile.py(558):     _compile_info(code, p, flags)
 --- modulename: sre_compile, funcname: _compile_info
sre_compile.py(437):     lo, hi = pattern.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(183):             elif op == SUCCESS:
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_compile.py(438):     if lo == 0:
sre_compile.py(441):     prefix = []
sre_compile.py(442):     prefixappend = prefix.append
sre_compile.py(443):     prefix_skip = 0
sre_compile.py(444):     charset = [] # not used
sre_compile.py(445):     charsetappend = charset.append
sre_compile.py(446):     if not (flags & SRE_FLAG_IGNORECASE):
sre_compile.py(448):         for op, av in pattern.data:
sre_compile.py(449):             if op is LITERAL:
sre_compile.py(453):             elif op is SUBPATTERN and len(av[1]) == 1:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_compile.py(460):                 break
sre_compile.py(462):         if not prefix and pattern.data:
sre_compile.py(463):             op, av = pattern.data[0]
sre_compile.py(464):             if op is SUBPATTERN and av[1]:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_compile.py(465):                 op, av = av[1][0]
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(466):                 if op is LITERAL:
sre_compile.py(468):                 elif op is BRANCH:
sre_compile.py(501):     emit = code.append
sre_compile.py(502):     emit(OPCODES[INFO])
sre_compile.py(503):     skip = len(code); emit(0)
sre_compile.py(505):     mask = 0
sre_compile.py(506):     if prefix:
sre_compile.py(510):     elif charset:
sre_compile.py(512):     emit(mask)
sre_compile.py(514):     if lo < MAXCODE:
sre_compile.py(515):         emit(lo)
sre_compile.py(519):     if hi < MAXCODE:
sre_compile.py(522):         emit(0)
sre_compile.py(524):     if prefix:
sre_compile.py(535):     elif charset:
sre_compile.py(537):     code[skip] = len(code) - skip
sre_compile.py(561):     _compile(code, p.data, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(287):                     out.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(235):             pass
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(287):                     out.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(235):             pass
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(110):             if flags & SRE_FLAG_DOTALL:
sre_compile.py(113):                 emit(OPCODES[ANY])
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(155):         elif op in SUCCESS_CODES:
sre_compile.py(157):         elif op in ASSERT_CODES:
sre_compile.py(170):         elif op is CALL:
sre_compile.py(176):         elif op is AT:
sre_compile.py(177):             emit(OPCODES[op])
sre_compile.py(178):             if flags & SRE_FLAG_MULTILINE:
sre_compile.py(180):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(182):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(184):             emit(ATCODES[av])
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(563):     code.append(OPCODES[SUCCESS])
sre_compile.py(565):     return code
sre_compile.py(581):     if p.pattern.groups > 100:
sre_compile.py(587):     groupindex = p.pattern.groupdict
sre_compile.py(588):     indexgroup = [None] * p.pattern.groups
sre_compile.py(589):     for k, i in groupindex.items():
sre_compile.py(590):         indexgroup[i] = k
sre_compile.py(589):     for k, i in groupindex.items():
sre_compile.py(590):         indexgroup[i] = k
sre_compile.py(589):     for k, i in groupindex.items():
sre_compile.py(590):         indexgroup[i] = k
sre_compile.py(589):     for k, i in groupindex.items():
sre_compile.py(592):     return _sre.compile(
sre_compile.py(593):         pattern, flags | p.pattern.flags, code,
sre_compile.py(594):         p.pattern.groups-1,
sre_compile.py(595):         groupindex, indexgroup
re.py(252):     if not bypass_cache:
re.py(253):         if len(_cache) >= _MAXCACHE:
re.py(255):         if p.flags & LOCALE:
re.py(260):             loc = None
re.py(261):         _cache[cachekey] = p, loc
re.py(262):     return p
ConfigParser.py(454):     OPTCRE_NV = re.compile(
ConfigParser.py(455):         r'(?P<option>[^:=\s][^:=]*)'          # very permissive!
 --- modulename: re, funcname: compile
re.py(194):     return _compile(pattern, flags)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(240):         except KeyError:
re.py(241):             pass
re.py(242):     if isinstance(pattern, _pattern_type):
re.py(246):     if not sre_compile.isstring(pattern):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
re.py(248):     try:
re.py(249):         p = sre_compile.compile(pattern, flags)
 --- modulename: sre_compile, funcname: compile
sre_compile.py(570):     if isstring(p):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
sre_compile.py(571):         pattern = p
sre_compile.py(572):         p = sre_parse.parse(p, flags)
 --- modulename: sre_parse, funcname: parse
sre_parse.py(709):     source = Tokenizer(str)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(190):         self.string = string
sre_parse.py(191):         self.index = 0
sre_parse.py(192):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(711):     if pattern is None:
sre_parse.py(712):         pattern = Pattern()
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(68):         self.flags = 0
sre_parse.py(69):         self.open = []
sre_parse.py(70):         self.groups = 1
sre_parse.py(71):         self.groupdict = {}
sre_parse.py(72):         self.lookbehind = 0
sre_parse.py(713):     pattern.flags = flags
sre_parse.py(714):     pattern.str = str
sre_parse.py(716):     p = _parse_sub(source, pattern, 0)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(549):                 group = 0
sre_parse.py(551):                 if sourcematch("P"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(553):                     if sourcematch("<"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(555):                         name = ""
sre_parse.py(556):                         while 1:
sre_parse.py(557):                             char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(558):                             if char is None:
sre_parse.py(560):                             if char == ">":
sre_parse.py(562):                             name = name + char
sre_parse.py(557):                             char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(558):                             if char is None:
sre_parse.py(560):                             if char == ">":
sre_parse.py(562):                             name = name + char
sre_parse.py(557):                             char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(558):                             if char is None:
sre_parse.py(560):                             if char == ">":
sre_parse.py(562):                             name = name + char
sre_parse.py(557):                             char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(558):                             if char is None:
sre_parse.py(560):                             if char == ">":
sre_parse.py(562):                             name = name + char
sre_parse.py(557):                             char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(558):                             if char is None:
sre_parse.py(560):                             if char == ">":
sre_parse.py(562):                             name = name + char
sre_parse.py(557):                             char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(558):                             if char is None:
sre_parse.py(560):                             if char == ">":
sre_parse.py(562):                             name = name + char
sre_parse.py(557):                             char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(558):                             if char is None:
sre_parse.py(560):                             if char == ">":
sre_parse.py(561):                                 break
sre_parse.py(563):                         group = 1
sre_parse.py(564):                         if not name:
sre_parse.py(566):                         if not isname(name):
 --- modulename: sre_parse, funcname: isname
sre_parse.py(229):     if not isident(name[0]):
 --- modulename: sre_parse, funcname: isident
sre_parse.py(222):     return "a" <= char <= "z" or "A" <= char <= "Z" or char == "_"
sre_parse.py(231):     for char in name[1:]:
sre_parse.py(232):         if not isident(char) and not isdigit(char):
 --- modulename: sre_parse, funcname: isident
sre_parse.py(222):     return "a" <= char <= "z" or "A" <= char <= "Z" or char == "_"
sre_parse.py(231):     for char in name[1:]:
sre_parse.py(232):         if not isident(char) and not isdigit(char):
 --- modulename: sre_parse, funcname: isident
sre_parse.py(222):     return "a" <= char <= "z" or "A" <= char <= "Z" or char == "_"
sre_parse.py(231):     for char in name[1:]:
sre_parse.py(232):         if not isident(char) and not isdigit(char):
 --- modulename: sre_parse, funcname: isident
sre_parse.py(222):     return "a" <= char <= "z" or "A" <= char <= "Z" or char == "_"
sre_parse.py(231):     for char in name[1:]:
sre_parse.py(232):         if not isident(char) and not isdigit(char):
 --- modulename: sre_parse, funcname: isident
sre_parse.py(222):     return "a" <= char <= "z" or "A" <= char <= "Z" or char == "_"
sre_parse.py(231):     for char in name[1:]:
sre_parse.py(232):         if not isident(char) and not isdigit(char):
 --- modulename: sre_parse, funcname: isident
sre_parse.py(222):     return "a" <= char <= "z" or "A" <= char <= "Z" or char == "_"
sre_parse.py(231):     for char in name[1:]:
sre_parse.py(234):     return True
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(78):             ogid = self.groupdict.get(name, None)
sre_parse.py(79):             if ogid is not None:
sre_parse.py(82):             self.groupdict[name] = gid
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(438):                 setappend((NEGATE, None))
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(241):     code = CATEGORIES.get(escape)
sre_parse.py(242):     if code and code[0] == IN:
sre_parse.py(243):         return code
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(476):                         code1 = code1[1][0]
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(438):                 setappend((NEGATE, None))
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(493):                 min, max = 0, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(272):         return code
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(493):                 min, max = 0, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(549):                 group = 0
sre_parse.py(551):                 if sourcematch("P"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(600):                 elif sourcematch(":"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(602):                     group = 2
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(670):                     group = None
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(549):                 group = 0
sre_parse.py(551):                 if sourcematch("P"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(553):                     if sourcematch("<"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(555):                         name = ""
sre_parse.py(556):                         while 1:
sre_parse.py(557):                             char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(558):                             if char is None:
sre_parse.py(560):                             if char == ">":
sre_parse.py(562):                             name = name + char
sre_parse.py(557):                             char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(558):                             if char is None:
sre_parse.py(560):                             if char == ">":
sre_parse.py(562):                             name = name + char
sre_parse.py(557):                             char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(558):                             if char is None:
sre_parse.py(560):                             if char == ">":
sre_parse.py(561):                                 break
sre_parse.py(563):                         group = 1
sre_parse.py(564):                         if not name:
sre_parse.py(566):                         if not isname(name):
 --- modulename: sre_parse, funcname: isname
sre_parse.py(229):     if not isident(name[0]):
 --- modulename: sre_parse, funcname: isident
sre_parse.py(222):     return "a" <= char <= "z" or "A" <= char <= "Z" or char == "_"
sre_parse.py(231):     for char in name[1:]:
sre_parse.py(232):         if not isident(char) and not isdigit(char):
 --- modulename: sre_parse, funcname: isident
sre_parse.py(222):     return "a" <= char <= "z" or "A" <= char <= "Z" or char == "_"
sre_parse.py(231):     for char in name[1:]:
sre_parse.py(234):     return True
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(78):             ogid = self.groupdict.get(name, None)
sre_parse.py(79):             if ogid is not None:
sre_parse.py(82):             self.groupdict[name] = gid
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(272):         return code
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(493):                 min, max = 0, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(549):                 group = 0
sre_parse.py(551):                 if sourcematch("P"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(553):                     if sourcematch("<"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(555):                         name = ""
sre_parse.py(556):                         while 1:
sre_parse.py(557):                             char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(558):                             if char is None:
sre_parse.py(560):                             if char == ">":
sre_parse.py(562):                             name = name + char
sre_parse.py(557):                             char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(558):                             if char is None:
sre_parse.py(560):                             if char == ">":
sre_parse.py(562):                             name = name + char
sre_parse.py(557):                             char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(558):                             if char is None:
sre_parse.py(560):                             if char == ">":
sre_parse.py(562):                             name = name + char
sre_parse.py(557):                             char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(558):                             if char is None:
sre_parse.py(560):                             if char == ">":
sre_parse.py(562):                             name = name + char
sre_parse.py(557):                             char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(558):                             if char is None:
sre_parse.py(560):                             if char == ">":
sre_parse.py(562):                             name = name + char
sre_parse.py(557):                             char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(558):                             if char is None:
sre_parse.py(560):                             if char == ">":
sre_parse.py(561):                                 break
sre_parse.py(563):                         group = 1
sre_parse.py(564):                         if not name:
sre_parse.py(566):                         if not isname(name):
 --- modulename: sre_parse, funcname: isname
sre_parse.py(229):     if not isident(name[0]):
 --- modulename: sre_parse, funcname: isident
sre_parse.py(222):     return "a" <= char <= "z" or "A" <= char <= "Z" or char == "_"
sre_parse.py(231):     for char in name[1:]:
sre_parse.py(232):         if not isident(char) and not isdigit(char):
 --- modulename: sre_parse, funcname: isident
sre_parse.py(222):     return "a" <= char <= "z" or "A" <= char <= "Z" or char == "_"
sre_parse.py(231):     for char in name[1:]:
sre_parse.py(232):         if not isident(char) and not isdigit(char):
 --- modulename: sre_parse, funcname: isident
sre_parse.py(222):     return "a" <= char <= "z" or "A" <= char <= "Z" or char == "_"
sre_parse.py(231):     for char in name[1:]:
sre_parse.py(232):         if not isident(char) and not isdigit(char):
 --- modulename: sre_parse, funcname: isident
sre_parse.py(222):     return "a" <= char <= "z" or "A" <= char <= "Z" or char == "_"
sre_parse.py(231):     for char in name[1:]:
sre_parse.py(232):         if not isident(char) and not isdigit(char):
 --- modulename: sre_parse, funcname: isident
sre_parse.py(222):     return "a" <= char <= "z" or "A" <= char <= "Z" or char == "_"
sre_parse.py(231):     for char in name[1:]:
sre_parse.py(234):     return True
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(78):             ogid = self.groupdict.get(name, None)
sre_parse.py(79):             if ogid is not None:
sre_parse.py(82):             self.groupdict[name] = gid
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(542):             subpatternappend((ANY, None))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(493):                 min, max = 0, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(491):                 min, max = 0, 1
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(695):             subpattern.append((AT, AT_END))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(415):             break # end of pattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(328):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(718):     tail = source.get()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(719):     if tail == ")":
sre_parse.py(721):     elif tail:
sre_parse.py(724):     if flags & SRE_FLAG_DEBUG:
sre_parse.py(727):     if not (flags & SRE_FLAG_VERBOSE) and p.pattern.flags & SRE_FLAG_VERBOSE:
sre_parse.py(732):     return p
sre_compile.py(576):     code = _code(p, flags)
 --- modulename: sre_compile, funcname: _code
sre_compile.py(554):     flags = p.pattern.flags | flags
sre_compile.py(555):     code = []
sre_compile.py(558):     _compile_info(code, p, flags)
 --- modulename: sre_compile, funcname: _compile_info
sre_compile.py(437):     lo, hi = pattern.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(183):             elif op == SUCCESS:
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_compile.py(438):     if lo == 0:
sre_compile.py(441):     prefix = []
sre_compile.py(442):     prefixappend = prefix.append
sre_compile.py(443):     prefix_skip = 0
sre_compile.py(444):     charset = [] # not used
sre_compile.py(445):     charsetappend = charset.append
sre_compile.py(446):     if not (flags & SRE_FLAG_IGNORECASE):
sre_compile.py(448):         for op, av in pattern.data:
sre_compile.py(449):             if op is LITERAL:
sre_compile.py(453):             elif op is SUBPATTERN and len(av[1]) == 1:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_compile.py(460):                 break
sre_compile.py(462):         if not prefix and pattern.data:
sre_compile.py(463):             op, av = pattern.data[0]
sre_compile.py(464):             if op is SUBPATTERN and av[1]:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_compile.py(465):                 op, av = av[1][0]
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(466):                 if op is LITERAL:
sre_compile.py(468):                 elif op is BRANCH:
sre_compile.py(501):     emit = code.append
sre_compile.py(502):     emit(OPCODES[INFO])
sre_compile.py(503):     skip = len(code); emit(0)
sre_compile.py(505):     mask = 0
sre_compile.py(506):     if prefix:
sre_compile.py(510):     elif charset:
sre_compile.py(512):     emit(mask)
sre_compile.py(514):     if lo < MAXCODE:
sre_compile.py(515):         emit(lo)
sre_compile.py(519):     if hi < MAXCODE:
sre_compile.py(522):         emit(0)
sre_compile.py(524):     if prefix:
sre_compile.py(535):     elif charset:
sre_compile.py(537):     code[skip] = len(code) - skip
sre_compile.py(561):     _compile(code, p.data, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(287):                     out.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(235):             pass
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(287):                     out.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(235):             pass
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
sre_compile.py(136):                 emit(OPCODES[REPEAT])
sre_compile.py(137):                 skip = _len(code); emit(0)
sre_compile.py(138):                 emit(av[0])
sre_compile.py(139):                 emit(av[1])
sre_compile.py(140):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(110):             if flags & SRE_FLAG_DOTALL:
sre_compile.py(113):                 emit(OPCODES[ANY])
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(141):                 code[skip] = _len(code) - skip
sre_compile.py(142):                 if op is MAX_REPEAT:
sre_compile.py(143):                     emit(OPCODES[MAX_UNTIL])
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(155):         elif op in SUCCESS_CODES:
sre_compile.py(157):         elif op in ASSERT_CODES:
sre_compile.py(170):         elif op is CALL:
sre_compile.py(176):         elif op is AT:
sre_compile.py(177):             emit(OPCODES[op])
sre_compile.py(178):             if flags & SRE_FLAG_MULTILINE:
sre_compile.py(180):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(182):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(184):             emit(ATCODES[av])
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(563):     code.append(OPCODES[SUCCESS])
sre_compile.py(565):     return code
sre_compile.py(581):     if p.pattern.groups > 100:
sre_compile.py(587):     groupindex = p.pattern.groupdict
sre_compile.py(588):     indexgroup = [None] * p.pattern.groups
sre_compile.py(589):     for k, i in groupindex.items():
sre_compile.py(590):         indexgroup[i] = k
sre_compile.py(589):     for k, i in groupindex.items():
sre_compile.py(590):         indexgroup[i] = k
sre_compile.py(589):     for k, i in groupindex.items():
sre_compile.py(590):         indexgroup[i] = k
sre_compile.py(589):     for k, i in groupindex.items():
sre_compile.py(592):     return _sre.compile(
sre_compile.py(593):         pattern, flags | p.pattern.flags, code,
sre_compile.py(594):         p.pattern.groups-1,
sre_compile.py(595):         groupindex, indexgroup
re.py(252):     if not bypass_cache:
re.py(253):         if len(_cache) >= _MAXCACHE:
re.py(255):         if p.flags & LOCALE:
re.py(260):             loc = None
re.py(261):         _cache[cachekey] = p, loc
re.py(262):     return p
ConfigParser.py(464):     def _read(self, fp, fpname):
ConfigParser.py(556): import UserDict as _UserDict
ConfigParser.py(558): class _Chainmap(_UserDict.DictMixin):
 --- modulename: ConfigParser, funcname: _Chainmap
ConfigParser.py(558): class _Chainmap(_UserDict.DictMixin):
ConfigParser.py(565):     """
ConfigParser.py(567):     def __init__(self, *maps):
ConfigParser.py(570):     def __getitem__(self, key):
ConfigParser.py(578):     def keys(self):
ConfigParser.py(588): class ConfigParser(RawConfigParser):
 --- modulename: ConfigParser, funcname: ConfigParser
ConfigParser.py(588): class ConfigParser(RawConfigParser):
ConfigParser.py(590):     def get(self, section, option, raw=False, vars=None):
ConfigParser.py(625):     def items(self, section, raw=False, vars=None):
ConfigParser.py(657):     def _interpolate(self, section, option, rawval, vars):
ConfigParser.py(676):     _KEYCRE = re.compile(r"%\(([^)]*)\)s|.")
 --- modulename: re, funcname: compile
re.py(194):     return _compile(pattern, flags)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(240):         except KeyError:
re.py(241):             pass
re.py(242):     if isinstance(pattern, _pattern_type):
re.py(246):     if not sre_compile.isstring(pattern):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
re.py(248):     try:
re.py(249):         p = sre_compile.compile(pattern, flags)
 --- modulename: sre_compile, funcname: compile
sre_compile.py(570):     if isstring(p):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
sre_compile.py(571):         pattern = p
sre_compile.py(572):         p = sre_parse.parse(p, flags)
 --- modulename: sre_parse, funcname: parse
sre_parse.py(709):     source = Tokenizer(str)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(190):         self.string = string
sre_parse.py(191):         self.index = 0
sre_parse.py(192):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(711):     if pattern is None:
sre_parse.py(712):         pattern = Pattern()
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(68):         self.flags = 0
sre_parse.py(69):         self.open = []
sre_parse.py(70):         self.groups = 1
sre_parse.py(71):         self.groupdict = {}
sre_parse.py(72):         self.lookbehind = 0
sre_parse.py(713):     pattern.flags = flags
sre_parse.py(714):     pattern.str = str
sre_parse.py(716):     p = _parse_sub(source, pattern, 0)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(273):     code = ESCAPES.get(escape)
sre_parse.py(274):     if code:
sre_parse.py(276):     try:
sre_parse.py(277):         c = escape[1:2]
sre_parse.py(278):         if c == "x":
sre_parse.py(285):         elif c == "0":
sre_parse.py(290):         elif c in DIGITS:
sre_parse.py(311):         if len(escape) == 2:
sre_parse.py(312):             return LITERAL, ord(escape[1])
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(438):                 setappend((NEGATE, None))
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(483):                 subpatternappend((NOT_LITERAL, set[1][1])) # optimization
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(493):                 min, max = 0, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(273):     code = ESCAPES.get(escape)
sre_parse.py(274):     if code:
sre_parse.py(276):     try:
sre_parse.py(277):         c = escape[1:2]
sre_parse.py(278):         if c == "x":
sre_parse.py(285):         elif c == "0":
sre_parse.py(290):         elif c in DIGITS:
sre_parse.py(311):         if len(escape) == 2:
sre_parse.py(312):             return LITERAL, ord(escape[1])
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(326):             continue
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(542):             subpatternappend((ANY, None))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(415):             break # end of pattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(328):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(337):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(338):     subpatternappend = subpattern.append
sre_parse.py(341):     while 1:
sre_parse.py(342):         prefix = None
sre_parse.py(343):         for item in items:
sre_parse.py(344):             if not item:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(346):             if prefix is None:
sre_parse.py(347):                 prefix = item[0]
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(343):         for item in items:
sre_parse.py(344):             if not item:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(346):             if prefix is None:
sre_parse.py(348):             elif item[0] != prefix:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(349):                 break
sre_parse.py(357):         break
sre_parse.py(360):     for item in items:
sre_parse.py(361):         if len(item) != 1 or item[0][0] != LITERAL:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(362):             break
sre_parse.py(373):     subpattern.append((BRANCH, (None, items)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(374):     return subpattern
sre_parse.py(718):     tail = source.get()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(719):     if tail == ")":
sre_parse.py(721):     elif tail:
sre_parse.py(724):     if flags & SRE_FLAG_DEBUG:
sre_parse.py(727):     if not (flags & SRE_FLAG_VERBOSE) and p.pattern.flags & SRE_FLAG_VERBOSE:
sre_parse.py(732):     return p
sre_compile.py(576):     code = _code(p, flags)
 --- modulename: sre_compile, funcname: _code
sre_compile.py(554):     flags = p.pattern.flags | flags
sre_compile.py(555):     code = []
sre_compile.py(558):     _compile_info(code, p, flags)
 --- modulename: sre_compile, funcname: _compile_info
sre_compile.py(437):     lo, hi = pattern.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(160):                 i = MAXREPEAT - 1
sre_parse.py(161):                 j = 0
sre_parse.py(162):                 for av in av[1]:
sre_parse.py(163):                     l, h = av.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(164):                     i = min(i, l)
sre_parse.py(165):                     j = max(j, h)
sre_parse.py(162):                 for av in av[1]:
sre_parse.py(163):                     l, h = av.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(164):                     i = min(i, l)
sre_parse.py(165):                     j = max(j, h)
sre_parse.py(162):                 for av in av[1]:
sre_parse.py(166):                 lo = lo + i
sre_parse.py(167):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_compile.py(438):     if lo == 0:
sre_compile.py(441):     prefix = []
sre_compile.py(442):     prefixappend = prefix.append
sre_compile.py(443):     prefix_skip = 0
sre_compile.py(444):     charset = [] # not used
sre_compile.py(445):     charsetappend = charset.append
sre_compile.py(446):     if not (flags & SRE_FLAG_IGNORECASE):
sre_compile.py(448):         for op, av in pattern.data:
sre_compile.py(449):             if op is LITERAL:
sre_compile.py(453):             elif op is SUBPATTERN and len(av[1]) == 1:
sre_compile.py(460):                 break
sre_compile.py(462):         if not prefix and pattern.data:
sre_compile.py(463):             op, av = pattern.data[0]
sre_compile.py(464):             if op is SUBPATTERN and av[1]:
sre_compile.py(481):             elif op is BRANCH:
sre_compile.py(482):                 c = []
sre_compile.py(483):                 cappend = c.append
sre_compile.py(484):                 for p in av[1]:
sre_compile.py(485):                     if not p:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_compile.py(487):                     op, av = p[0]
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(488):                     if op is LITERAL:
sre_compile.py(489):                         cappend((op, av))
sre_compile.py(484):                 for p in av[1]:
sre_compile.py(485):                     if not p:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_compile.py(487):                     op, av = p[0]
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(488):                     if op is LITERAL:
sre_compile.py(491):                         break
sre_compile.py(501):     emit = code.append
sre_compile.py(502):     emit(OPCODES[INFO])
sre_compile.py(503):     skip = len(code); emit(0)
sre_compile.py(505):     mask = 0
sre_compile.py(506):     if prefix:
sre_compile.py(510):     elif charset:
sre_compile.py(512):     emit(mask)
sre_compile.py(514):     if lo < MAXCODE:
sre_compile.py(515):         emit(lo)
sre_compile.py(519):     if hi < MAXCODE:
sre_compile.py(522):         emit(0)
sre_compile.py(524):     if prefix:
sre_compile.py(535):     elif charset:
sre_compile.py(537):     code[skip] = len(code) - skip
sre_compile.py(561):     _compile(code, p.data, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(155):         elif op in SUCCESS_CODES:
sre_compile.py(157):         elif op in ASSERT_CODES:
sre_compile.py(170):         elif op is CALL:
sre_compile.py(176):         elif op is AT:
sre_compile.py(185):         elif op is BRANCH:
sre_compile.py(186):             emit(OPCODES[op])
sre_compile.py(187):             tail = []
sre_compile.py(188):             tailappend = tail.append
sre_compile.py(189):             for av in av[1]:
sre_compile.py(190):                 skip = _len(code); emit(0)
sre_compile.py(192):                 _compile(code, av, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(193):                 emit(OPCODES[JUMP])
sre_compile.py(194):                 tailappend(_len(code)); emit(0)
sre_compile.py(195):                 code[skip] = _len(code) - skip
sre_compile.py(189):             for av in av[1]:
sre_compile.py(190):                 skip = _len(code); emit(0)
sre_compile.py(192):                 _compile(code, av, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(110):             if flags & SRE_FLAG_DOTALL:
sre_compile.py(113):                 emit(OPCODES[ANY])
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(193):                 emit(OPCODES[JUMP])
sre_compile.py(194):                 tailappend(_len(code)); emit(0)
sre_compile.py(195):                 code[skip] = _len(code) - skip
sre_compile.py(189):             for av in av[1]:
sre_compile.py(196):             emit(0) # end of branch
sre_compile.py(197):             for tail in tail:
sre_compile.py(198):                 code[tail] = _len(code) - tail
sre_compile.py(197):             for tail in tail:
sre_compile.py(198):                 code[tail] = _len(code) - tail
sre_compile.py(197):             for tail in tail:
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(563):     code.append(OPCODES[SUCCESS])
sre_compile.py(565):     return code
sre_compile.py(581):     if p.pattern.groups > 100:
sre_compile.py(587):     groupindex = p.pattern.groupdict
sre_compile.py(588):     indexgroup = [None] * p.pattern.groups
sre_compile.py(589):     for k, i in groupindex.items():
sre_compile.py(592):     return _sre.compile(
sre_compile.py(593):         pattern, flags | p.pattern.flags, code,
sre_compile.py(594):         p.pattern.groups-1,
sre_compile.py(595):         groupindex, indexgroup
re.py(252):     if not bypass_cache:
re.py(253):         if len(_cache) >= _MAXCACHE:
re.py(255):         if p.flags & LOCALE:
re.py(260):             loc = None
re.py(261):         _cache[cachekey] = p, loc
re.py(262):     return p
ConfigParser.py(678):     def _interpolation_replace(self, match):
ConfigParser.py(686): class SafeConfigParser(ConfigParser):
 --- modulename: ConfigParser, funcname: SafeConfigParser
ConfigParser.py(686): class SafeConfigParser(ConfigParser):
ConfigParser.py(688):     def _interpolate(self, section, option, rawval, vars):
ConfigParser.py(694):     _interpvar_re = re.compile(r"%\(([^)]+)\)s")
 --- modulename: re, funcname: compile
re.py(194):     return _compile(pattern, flags)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(240):         except KeyError:
re.py(241):             pass
re.py(242):     if isinstance(pattern, _pattern_type):
re.py(246):     if not sre_compile.isstring(pattern):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
re.py(248):     try:
re.py(249):         p = sre_compile.compile(pattern, flags)
 --- modulename: sre_compile, funcname: compile
sre_compile.py(570):     if isstring(p):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
sre_compile.py(571):         pattern = p
sre_compile.py(572):         p = sre_parse.parse(p, flags)
 --- modulename: sre_parse, funcname: parse
sre_parse.py(709):     source = Tokenizer(str)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(190):         self.string = string
sre_parse.py(191):         self.index = 0
sre_parse.py(192):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(711):     if pattern is None:
sre_parse.py(712):         pattern = Pattern()
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(68):         self.flags = 0
sre_parse.py(69):         self.open = []
sre_parse.py(70):         self.groups = 1
sre_parse.py(71):         self.groupdict = {}
sre_parse.py(72):         self.lookbehind = 0
sre_parse.py(713):     pattern.flags = flags
sre_parse.py(714):     pattern.str = str
sre_parse.py(716):     p = _parse_sub(source, pattern, 0)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(273):     code = ESCAPES.get(escape)
sre_parse.py(274):     if code:
sre_parse.py(276):     try:
sre_parse.py(277):         c = escape[1:2]
sre_parse.py(278):         if c == "x":
sre_parse.py(285):         elif c == "0":
sre_parse.py(290):         elif c in DIGITS:
sre_parse.py(311):         if len(escape) == 2:
sre_parse.py(312):             return LITERAL, ord(escape[1])
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(438):                 setappend((NEGATE, None))
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(483):                 subpatternappend((NOT_LITERAL, set[1][1])) # optimization
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(495):             elif this == "+":
sre_parse.py(496):                 min, max = 1, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(273):     code = ESCAPES.get(escape)
sre_parse.py(274):     if code:
sre_parse.py(276):     try:
sre_parse.py(277):         c = escape[1:2]
sre_parse.py(278):         if c == "x":
sre_parse.py(285):         elif c == "0":
sre_parse.py(290):         elif c in DIGITS:
sre_parse.py(311):         if len(escape) == 2:
sre_parse.py(312):             return LITERAL, ord(escape[1])
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(415):             break # end of pattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(328):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(718):     tail = source.get()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(719):     if tail == ")":
sre_parse.py(721):     elif tail:
sre_parse.py(724):     if flags & SRE_FLAG_DEBUG:
sre_parse.py(727):     if not (flags & SRE_FLAG_VERBOSE) and p.pattern.flags & SRE_FLAG_VERBOSE:
sre_parse.py(732):     return p
sre_compile.py(576):     code = _code(p, flags)
 --- modulename: sre_compile, funcname: _code
sre_compile.py(554):     flags = p.pattern.flags | flags
sre_compile.py(555):     code = []
sre_compile.py(558):     _compile_info(code, p, flags)
 --- modulename: sre_compile, funcname: _compile_info
sre_compile.py(437):     lo, hi = pattern.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_compile.py(438):     if lo == 0:
sre_compile.py(441):     prefix = []
sre_compile.py(442):     prefixappend = prefix.append
sre_compile.py(443):     prefix_skip = 0
sre_compile.py(444):     charset = [] # not used
sre_compile.py(445):     charsetappend = charset.append
sre_compile.py(446):     if not (flags & SRE_FLAG_IGNORECASE):
sre_compile.py(448):         for op, av in pattern.data:
sre_compile.py(449):             if op is LITERAL:
sre_compile.py(450):                 if len(prefix) == prefix_skip:
sre_compile.py(451):                     prefix_skip = prefix_skip + 1
sre_compile.py(452):                 prefixappend(av)
sre_compile.py(448):         for op, av in pattern.data:
sre_compile.py(449):             if op is LITERAL:
sre_compile.py(450):                 if len(prefix) == prefix_skip:
sre_compile.py(451):                     prefix_skip = prefix_skip + 1
sre_compile.py(452):                 prefixappend(av)
sre_compile.py(448):         for op, av in pattern.data:
sre_compile.py(449):             if op is LITERAL:
sre_compile.py(453):             elif op is SUBPATTERN and len(av[1]) == 1:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_compile.py(454):                 op, av = av[1][0]
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(455):                 if op is LITERAL:
sre_compile.py(458):                     break
sre_compile.py(462):         if not prefix and pattern.data:
sre_compile.py(501):     emit = code.append
sre_compile.py(502):     emit(OPCODES[INFO])
sre_compile.py(503):     skip = len(code); emit(0)
sre_compile.py(505):     mask = 0
sre_compile.py(506):     if prefix:
sre_compile.py(507):         mask = SRE_INFO_PREFIX
sre_compile.py(508):         if len(prefix) == prefix_skip == len(pattern.data):
sre_compile.py(512):     emit(mask)
sre_compile.py(514):     if lo < MAXCODE:
sre_compile.py(515):         emit(lo)
sre_compile.py(519):     if hi < MAXCODE:
sre_compile.py(522):         emit(0)
sre_compile.py(524):     if prefix:
sre_compile.py(525):         emit(len(prefix)) # length
sre_compile.py(526):         emit(prefix_skip) # skip
sre_compile.py(527):         code.extend(prefix)
sre_compile.py(529):         table = [-1] + ([0]*len(prefix))
sre_compile.py(530):         for i in xrange(len(prefix)):
sre_compile.py(531):             table[i+1] = table[i]+1
sre_compile.py(532):             while table[i+1] > 0 and prefix[i] != prefix[table[i+1]-1]:
sre_compile.py(530):         for i in xrange(len(prefix)):
sre_compile.py(531):             table[i+1] = table[i]+1
sre_compile.py(532):             while table[i+1] > 0 and prefix[i] != prefix[table[i+1]-1]:
sre_compile.py(533):                 table[i+1] = table[table[i+1]-1]+1
sre_compile.py(532):             while table[i+1] > 0 and prefix[i] != prefix[table[i+1]-1]:
sre_compile.py(530):         for i in xrange(len(prefix)):
sre_compile.py(534):         code.extend(table[1:]) # don't store first entry
sre_compile.py(537):     code[skip] = len(code) - skip
sre_compile.py(561):     _compile(code, p.data, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(563):     code.append(OPCODES[SUCCESS])
sre_compile.py(565):     return code
sre_compile.py(581):     if p.pattern.groups > 100:
sre_compile.py(587):     groupindex = p.pattern.groupdict
sre_compile.py(588):     indexgroup = [None] * p.pattern.groups
sre_compile.py(589):     for k, i in groupindex.items():
sre_compile.py(592):     return _sre.compile(
sre_compile.py(593):         pattern, flags | p.pattern.flags, code,
sre_compile.py(594):         p.pattern.groups-1,
sre_compile.py(595):         groupindex, indexgroup
re.py(252):     if not bypass_cache:
re.py(253):         if len(_cache) >= _MAXCACHE:
re.py(255):         if p.flags & LOCALE:
re.py(260):             loc = None
re.py(261):         _cache[cachekey] = p, loc
re.py(262):     return p
ConfigParser.py(696):     def _interpolate_some(self, option, accum, rest, section, map, depth):
ConfigParser.py(734):     def set(self, section, option, value=None):
backward.py(29): try:
backward.py(30):     string_class = basestring
backward.py(35): try:
backward.py(36):     unicode_class = unicode
backward.py(41): try:
backward.py(42):     import cPickle as pickle
backward.py(47): try:
backward.py(48):     range = xrange
backward.py(54): try:
backward.py(55):     from shlex import quote as shlex_quote
 --- modulename: shlex, funcname: <module>
shlex.py(2): """A lexical analyzer class for simple shell-like syntaxes."""
shlex.py(10): import os.path
shlex.py(11): import sys
shlex.py(12): from collections import deque
shlex.py(14): try:
shlex.py(15):     from cStringIO import StringIO
shlex.py(19): __all__ = ["shlex", "split"]
shlex.py(21): class shlex:
 --- modulename: shlex, funcname: shlex
shlex.py(21): class shlex:
shlex.py(22):     "A lexical analyzer class for simple shell-like syntaxes."
shlex.py(23):     def __init__(self, instream=None, infile=None, posix=False):
shlex.py(59):     def push_token(self, tok):
shlex.py(65):     def push_source(self, newstream, newfile=None):
shlex.py(79):     def pop_source(self):
shlex.py(88):     def get_token(self):
shlex.py(120):     def read_token(self):
shlex.py(248):     def sourcehook(self, newfile):
shlex.py(257):     def error_leader(self, infile=None, lineno=None):
shlex.py(265):     def __iter__(self):
shlex.py(268):     def next(self):
shlex.py(274): def split(s, comments=False, posix=True):
shlex.py(281): if __name__ == '__main__':
backward.py(56): except ImportError:
backward.py(59):     from pipes import quote as shlex_quote
 --- modulename: pipes, funcname: <module>
pipes.py(57): """                                     # '
pipes.py(60): import re
pipes.py(61): import os
pipes.py(62): import tempfile
 --- modulename: tempfile, funcname: <module>
tempfile.py(18): """
tempfile.py(21):     "NamedTemporaryFile", "TemporaryFile", # high level safe interfaces
tempfile.py(22):     "SpooledTemporaryFile",
tempfile.py(23):     "mkstemp", "mkdtemp",                  # low level safe interfaces
tempfile.py(24):     "mktemp",                              # deprecated unsafe interface
tempfile.py(25):     "TMP_MAX", "gettempprefix",            # constants
tempfile.py(26):     "tempdir", "gettempdir"
tempfile.py(32): import io as _io
 --- modulename: io, funcname: <module>
io.py(34): """
io.py(37): __author__ = ("Guido van Rossum <guido@python.org>, "
io.py(44): __all__ = ["BlockingIOError", "open", "IOBase", "RawIOBase", "FileIO",
io.py(45):            "BytesIO", "StringIO", "BufferedIOBase",
io.py(46):            "BufferedReader", "BufferedWriter", "BufferedRWPair",
io.py(47):            "BufferedRandom", "TextIOBase", "TextIOWrapper",
io.py(48):            "UnsupportedOperation", "SEEK_SET", "SEEK_CUR", "SEEK_END"]
io.py(51): import _io
io.py(52): import abc
io.py(54): from _io import (DEFAULT_BUFFER_SIZE, BlockingIOError, UnsupportedOperation,
io.py(59): OpenWrapper = _io.open # for compatibility with _pyio
io.py(62): SEEK_SET = 0
io.py(63): SEEK_CUR = 1
io.py(64): SEEK_END = 2
io.py(69): class IOBase(_io._IOBase):
 --- modulename: io, funcname: IOBase
io.py(69): class IOBase(_io._IOBase):
io.py(70):     __metaclass__ = abc.ABCMeta
io.py(71):     __doc__ = _io._IOBase.__doc__
 --- modulename: abc, funcname: __new__
abc.py(87):         cls = super(ABCMeta, mcls).__new__(mcls, name, bases, namespace)
abc.py(89):         abstracts = set(name
abc.py(90):                      for name, value in namespace.items()
 --- modulename: abc, funcname: <genexpr>
abc.py(89):         abstracts = set(name
abc.py(90):                      for name, value in namespace.items()
abc.py(91):                      if getattr(value, "__isabstractmethod__", False))
abc.py(89):         abstracts = set(name
abc.py(90):                      for name, value in namespace.items()
abc.py(91):                      if getattr(value, "__isabstractmethod__", False))
abc.py(89):         abstracts = set(name
abc.py(90):                      for name, value in namespace.items()
abc.py(91):                      if getattr(value, "__isabstractmethod__", False))
abc.py(89):         abstracts = set(name
abc.py(92):         for base in bases:
abc.py(93):             for name in getattr(base, "__abstractmethods__", set()):
abc.py(92):         for base in bases:
abc.py(97):         cls.__abstractmethods__ = frozenset(abstracts)
abc.py(99):         cls._abc_registry = WeakSet()
 --- modulename: _weakrefset, funcname: __init__
_weakrefset.py(37):         self.data = set()
_weakrefset.py(38):         def _remove(item, selfref=ref(self)):
_weakrefset.py(45):         self._remove = _remove
_weakrefset.py(47):         self._pending_removals = []
_weakrefset.py(48):         self._iterating = set()
_weakrefset.py(49):         if data is not None:
abc.py(100):         cls._abc_cache = WeakSet()
 --- modulename: _weakrefset, funcname: __init__
_weakrefset.py(37):         self.data = set()
_weakrefset.py(38):         def _remove(item, selfref=ref(self)):
_weakrefset.py(45):         self._remove = _remove
_weakrefset.py(47):         self._pending_removals = []
_weakrefset.py(48):         self._iterating = set()
_weakrefset.py(49):         if data is not None:
abc.py(101):         cls._abc_negative_cache = WeakSet()
 --- modulename: _weakrefset, funcname: __init__
_weakrefset.py(37):         self.data = set()
_weakrefset.py(38):         def _remove(item, selfref=ref(self)):
_weakrefset.py(45):         self._remove = _remove
_weakrefset.py(47):         self._pending_removals = []
_weakrefset.py(48):         self._iterating = set()
_weakrefset.py(49):         if data is not None:
abc.py(102):         cls._abc_negative_cache_version = ABCMeta._abc_invalidation_counter
abc.py(103):         return cls
io.py(73): class RawIOBase(_io._RawIOBase, IOBase):
 --- modulename: io, funcname: RawIOBase
io.py(73): class RawIOBase(_io._RawIOBase, IOBase):
io.py(74):     __doc__ = _io._RawIOBase.__doc__
 --- modulename: abc, funcname: __new__
abc.py(87):         cls = super(ABCMeta, mcls).__new__(mcls, name, bases, namespace)
abc.py(89):         abstracts = set(name
abc.py(90):                      for name, value in namespace.items()
 --- modulename: abc, funcname: <genexpr>
abc.py(89):         abstracts = set(name
abc.py(90):                      for name, value in namespace.items()
abc.py(91):                      if getattr(value, "__isabstractmethod__", False))
abc.py(89):         abstracts = set(name
abc.py(90):                      for name, value in namespace.items()
abc.py(91):                      if getattr(value, "__isabstractmethod__", False))
abc.py(89):         abstracts = set(name
abc.py(92):         for base in bases:
abc.py(93):             for name in getattr(base, "__abstractmethods__", set()):
abc.py(92):         for base in bases:
abc.py(93):             for name in getattr(base, "__abstractmethods__", set()):
abc.py(92):         for base in bases:
abc.py(97):         cls.__abstractmethods__ = frozenset(abstracts)
abc.py(99):         cls._abc_registry = WeakSet()
 --- modulename: _weakrefset, funcname: __init__
_weakrefset.py(37):         self.data = set()
_weakrefset.py(38):         def _remove(item, selfref=ref(self)):
_weakrefset.py(45):         self._remove = _remove
_weakrefset.py(47):         self._pending_removals = []
_weakrefset.py(48):         self._iterating = set()
_weakrefset.py(49):         if data is not None:
abc.py(100):         cls._abc_cache = WeakSet()
 --- modulename: _weakrefset, funcname: __init__
_weakrefset.py(37):         self.data = set()
_weakrefset.py(38):         def _remove(item, selfref=ref(self)):
_weakrefset.py(45):         self._remove = _remove
_weakrefset.py(47):         self._pending_removals = []
_weakrefset.py(48):         self._iterating = set()
_weakrefset.py(49):         if data is not None:
abc.py(101):         cls._abc_negative_cache = WeakSet()
 --- modulename: _weakrefset, funcname: __init__
_weakrefset.py(37):         self.data = set()
_weakrefset.py(38):         def _remove(item, selfref=ref(self)):
_weakrefset.py(45):         self._remove = _remove
_weakrefset.py(47):         self._pending_removals = []
_weakrefset.py(48):         self._iterating = set()
_weakrefset.py(49):         if data is not None:
abc.py(102):         cls._abc_negative_cache_version = ABCMeta._abc_invalidation_counter
abc.py(103):         return cls
io.py(76): class BufferedIOBase(_io._BufferedIOBase, IOBase):
 --- modulename: io, funcname: BufferedIOBase
io.py(76): class BufferedIOBase(_io._BufferedIOBase, IOBase):
io.py(77):     __doc__ = _io._BufferedIOBase.__doc__
 --- modulename: abc, funcname: __new__
abc.py(87):         cls = super(ABCMeta, mcls).__new__(mcls, name, bases, namespace)
abc.py(89):         abstracts = set(name
abc.py(90):                      for name, value in namespace.items()
 --- modulename: abc, funcname: <genexpr>
abc.py(89):         abstracts = set(name
abc.py(90):                      for name, value in namespace.items()
abc.py(91):                      if getattr(value, "__isabstractmethod__", False))
abc.py(89):         abstracts = set(name
abc.py(90):                      for name, value in namespace.items()
abc.py(91):                      if getattr(value, "__isabstractmethod__", False))
abc.py(89):         abstracts = set(name
abc.py(92):         for base in bases:
abc.py(93):             for name in getattr(base, "__abstractmethods__", set()):
abc.py(92):         for base in bases:
abc.py(93):             for name in getattr(base, "__abstractmethods__", set()):
abc.py(92):         for base in bases:
abc.py(97):         cls.__abstractmethods__ = frozenset(abstracts)
abc.py(99):         cls._abc_registry = WeakSet()
 --- modulename: _weakrefset, funcname: __init__
_weakrefset.py(37):         self.data = set()
_weakrefset.py(38):         def _remove(item, selfref=ref(self)):
_weakrefset.py(45):         self._remove = _remove
_weakrefset.py(47):         self._pending_removals = []
_weakrefset.py(48):         self._iterating = set()
_weakrefset.py(49):         if data is not None:
abc.py(100):         cls._abc_cache = WeakSet()
 --- modulename: _weakrefset, funcname: __init__
_weakrefset.py(37):         self.data = set()
_weakrefset.py(38):         def _remove(item, selfref=ref(self)):
_weakrefset.py(45):         self._remove = _remove
_weakrefset.py(47):         self._pending_removals = []
_weakrefset.py(48):         self._iterating = set()
_weakrefset.py(49):         if data is not None:
abc.py(101):         cls._abc_negative_cache = WeakSet()
 --- modulename: _weakrefset, funcname: __init__
_weakrefset.py(37):         self.data = set()
_weakrefset.py(38):         def _remove(item, selfref=ref(self)):
_weakrefset.py(45):         self._remove = _remove
_weakrefset.py(47):         self._pending_removals = []
_weakrefset.py(48):         self._iterating = set()
_weakrefset.py(49):         if data is not None:
abc.py(102):         cls._abc_negative_cache_version = ABCMeta._abc_invalidation_counter
abc.py(103):         return cls
io.py(79): class TextIOBase(_io._TextIOBase, IOBase):
 --- modulename: io, funcname: TextIOBase
io.py(79): class TextIOBase(_io._TextIOBase, IOBase):
io.py(80):     __doc__ = _io._TextIOBase.__doc__
 --- modulename: abc, funcname: __new__
abc.py(87):         cls = super(ABCMeta, mcls).__new__(mcls, name, bases, namespace)
abc.py(89):         abstracts = set(name
abc.py(90):                      for name, value in namespace.items()
 --- modulename: abc, funcname: <genexpr>
abc.py(89):         abstracts = set(name
abc.py(90):                      for name, value in namespace.items()
abc.py(91):                      if getattr(value, "__isabstractmethod__", False))
abc.py(89):         abstracts = set(name
abc.py(90):                      for name, value in namespace.items()
abc.py(91):                      if getattr(value, "__isabstractmethod__", False))
abc.py(89):         abstracts = set(name
abc.py(92):         for base in bases:
abc.py(93):             for name in getattr(base, "__abstractmethods__", set()):
abc.py(92):         for base in bases:
abc.py(93):             for name in getattr(base, "__abstractmethods__", set()):
abc.py(92):         for base in bases:
abc.py(97):         cls.__abstractmethods__ = frozenset(abstracts)
abc.py(99):         cls._abc_registry = WeakSet()
 --- modulename: _weakrefset, funcname: __init__
_weakrefset.py(37):         self.data = set()
_weakrefset.py(38):         def _remove(item, selfref=ref(self)):
_weakrefset.py(45):         self._remove = _remove
_weakrefset.py(47):         self._pending_removals = []
_weakrefset.py(48):         self._iterating = set()
_weakrefset.py(49):         if data is not None:
abc.py(100):         cls._abc_cache = WeakSet()
 --- modulename: _weakrefset, funcname: __init__
_weakrefset.py(37):         self.data = set()
_weakrefset.py(38):         def _remove(item, selfref=ref(self)):
_weakrefset.py(45):         self._remove = _remove
_weakrefset.py(47):         self._pending_removals = []
_weakrefset.py(48):         self._iterating = set()
_weakrefset.py(49):         if data is not None:
abc.py(101):         cls._abc_negative_cache = WeakSet()
 --- modulename: _weakrefset, funcname: __init__
_weakrefset.py(37):         self.data = set()
_weakrefset.py(38):         def _remove(item, selfref=ref(self)):
_weakrefset.py(45):         self._remove = _remove
_weakrefset.py(47):         self._pending_removals = []
_weakrefset.py(48):         self._iterating = set()
_weakrefset.py(49):         if data is not None:
abc.py(102):         cls._abc_negative_cache_version = ABCMeta._abc_invalidation_counter
abc.py(103):         return cls
io.py(82): RawIOBase.register(FileIO)
 --- modulename: abc, funcname: register
abc.py(107):         if not isinstance(subclass, (type, types.ClassType)):
abc.py(109):         if issubclass(subclass, cls):
 --- modulename: abc, funcname: __subclasscheck__
abc.py(151):         if subclass in cls._abc_cache:
 --- modulename: _weakrefset, funcname: __contains__
_weakrefset.py(71):         try:
_weakrefset.py(72):             wr = ref(item)
_weakrefset.py(75):         return wr in self.data
abc.py(154):         if cls._abc_negative_cache_version < ABCMeta._abc_invalidation_counter:
abc.py(158):         elif subclass in cls._abc_negative_cache:
 --- modulename: _weakrefset, funcname: __contains__
_weakrefset.py(71):         try:
_weakrefset.py(72):             wr = ref(item)
_weakrefset.py(75):         return wr in self.data
abc.py(161):         ok = cls.__subclasshook__(subclass)
abc.py(162):         if ok is not NotImplemented:
abc.py(170):         if cls in getattr(subclass, '__mro__', ()):
abc.py(174):         for rcls in cls._abc_registry:
 --- modulename: _weakrefset, funcname: __iter__
_weakrefset.py(59):         with _IterationGuard(self):
 --- modulename: _weakrefset, funcname: __init__
_weakrefset.py(18):         self.weakcontainer = ref(weakcontainer)
 --- modulename: _weakrefset, funcname: __enter__
_weakrefset.py(21):         w = self.weakcontainer()
_weakrefset.py(22):         if w is not None:
_weakrefset.py(23):             w._iterating.add(self)
_weakrefset.py(24):         return self
_weakrefset.py(60):             for itemref in self.data:
 --- modulename: _weakrefset, funcname: __exit__
_weakrefset.py(27):         w = self.weakcontainer()
_weakrefset.py(28):         if w is not None:
_weakrefset.py(29):             s = w._iterating
_weakrefset.py(30):             s.remove(self)
_weakrefset.py(31):             if not s:
_weakrefset.py(32):                 w._commit_removals()
 --- modulename: _weakrefset, funcname: _commit_removals
_weakrefset.py(53):         l = self._pending_removals
_weakrefset.py(54):         discard = self.data.discard
_weakrefset.py(55):         while l:
abc.py(179):         for scls in cls.__subclasses__():
abc.py(184):         cls._abc_negative_cache.add(subclass)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(84):         if self._pending_removals:
_weakrefset.py(86):         self.data.add(ref(item, self._remove))
abc.py(185):         return False
abc.py(113):         if issubclass(cls, subclass):
abc.py(116):         cls._abc_registry.add(subclass)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(84):         if self._pending_removals:
_weakrefset.py(86):         self.data.add(ref(item, self._remove))
abc.py(117):         ABCMeta._abc_invalidation_counter += 1  # Invalidate negative cache
io.py(84): for klass in (BytesIO, BufferedReader, BufferedWriter, BufferedRandom,
io.py(85):               BufferedRWPair):
io.py(86):     BufferedIOBase.register(klass)
 --- modulename: abc, funcname: register
abc.py(107):         if not isinstance(subclass, (type, types.ClassType)):
abc.py(109):         if issubclass(subclass, cls):
 --- modulename: abc, funcname: __subclasscheck__
abc.py(151):         if subclass in cls._abc_cache:
 --- modulename: _weakrefset, funcname: __contains__
_weakrefset.py(71):         try:
_weakrefset.py(72):             wr = ref(item)
_weakrefset.py(75):         return wr in self.data
abc.py(154):         if cls._abc_negative_cache_version < ABCMeta._abc_invalidation_counter:
abc.py(156):             cls._abc_negative_cache = WeakSet()
 --- modulename: _weakrefset, funcname: __init__
_weakrefset.py(37):         self.data = set()
_weakrefset.py(38):         def _remove(item, selfref=ref(self)):
_weakrefset.py(45):         self._remove = _remove
_weakrefset.py(47):         self._pending_removals = []
_weakrefset.py(48):         self._iterating = set()
_weakrefset.py(49):         if data is not None:
abc.py(157):             cls._abc_negative_cache_version = ABCMeta._abc_invalidation_counter
abc.py(161):         ok = cls.__subclasshook__(subclass)
abc.py(162):         if ok is not NotImplemented:
abc.py(170):         if cls in getattr(subclass, '__mro__', ()):
abc.py(174):         for rcls in cls._abc_registry:
 --- modulename: _weakrefset, funcname: __iter__
_weakrefset.py(59):         with _IterationGuard(self):
 --- modulename: _weakrefset, funcname: __init__
_weakrefset.py(18):         self.weakcontainer = ref(weakcontainer)
 --- modulename: _weakrefset, funcname: __enter__
_weakrefset.py(21):         w = self.weakcontainer()
_weakrefset.py(22):         if w is not None:
_weakrefset.py(23):             w._iterating.add(self)
_weakrefset.py(24):         return self
_weakrefset.py(60):             for itemref in self.data:
 --- modulename: _weakrefset, funcname: __exit__
_weakrefset.py(27):         w = self.weakcontainer()
_weakrefset.py(28):         if w is not None:
_weakrefset.py(29):             s = w._iterating
_weakrefset.py(30):             s.remove(self)
_weakrefset.py(31):             if not s:
_weakrefset.py(32):                 w._commit_removals()
 --- modulename: _weakrefset, funcname: _commit_removals
_weakrefset.py(53):         l = self._pending_removals
_weakrefset.py(54):         discard = self.data.discard
_weakrefset.py(55):         while l:
abc.py(179):         for scls in cls.__subclasses__():
abc.py(184):         cls._abc_negative_cache.add(subclass)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(84):         if self._pending_removals:
_weakrefset.py(86):         self.data.add(ref(item, self._remove))
abc.py(185):         return False
abc.py(113):         if issubclass(cls, subclass):
abc.py(116):         cls._abc_registry.add(subclass)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(84):         if self._pending_removals:
_weakrefset.py(86):         self.data.add(ref(item, self._remove))
abc.py(117):         ABCMeta._abc_invalidation_counter += 1  # Invalidate negative cache
io.py(85):               BufferedRWPair):
io.py(86):     BufferedIOBase.register(klass)
 --- modulename: abc, funcname: register
abc.py(107):         if not isinstance(subclass, (type, types.ClassType)):
abc.py(109):         if issubclass(subclass, cls):
 --- modulename: abc, funcname: __subclasscheck__
abc.py(151):         if subclass in cls._abc_cache:
 --- modulename: _weakrefset, funcname: __contains__
_weakrefset.py(71):         try:
_weakrefset.py(72):             wr = ref(item)
_weakrefset.py(75):         return wr in self.data
abc.py(154):         if cls._abc_negative_cache_version < ABCMeta._abc_invalidation_counter:
abc.py(156):             cls._abc_negative_cache = WeakSet()
 --- modulename: _weakrefset, funcname: __init__
_weakrefset.py(37):         self.data = set()
_weakrefset.py(38):         def _remove(item, selfref=ref(self)):
_weakrefset.py(45):         self._remove = _remove
_weakrefset.py(47):         self._pending_removals = []
_weakrefset.py(48):         self._iterating = set()
_weakrefset.py(49):         if data is not None:
abc.py(157):             cls._abc_negative_cache_version = ABCMeta._abc_invalidation_counter
abc.py(161):         ok = cls.__subclasshook__(subclass)
abc.py(162):         if ok is not NotImplemented:
abc.py(170):         if cls in getattr(subclass, '__mro__', ()):
abc.py(174):         for rcls in cls._abc_registry:
 --- modulename: _weakrefset, funcname: __iter__
_weakrefset.py(59):         with _IterationGuard(self):
 --- modulename: _weakrefset, funcname: __init__
_weakrefset.py(18):         self.weakcontainer = ref(weakcontainer)
 --- modulename: _weakrefset, funcname: __enter__
_weakrefset.py(21):         w = self.weakcontainer()
_weakrefset.py(22):         if w is not None:
_weakrefset.py(23):             w._iterating.add(self)
_weakrefset.py(24):         return self
_weakrefset.py(60):             for itemref in self.data:
_weakrefset.py(61):                 item = itemref()
_weakrefset.py(62):                 if item is not None:
_weakrefset.py(65):                     yield item
abc.py(175):             if issubclass(subclass, rcls):
abc.py(174):         for rcls in cls._abc_registry:
 --- modulename: _weakrefset, funcname: __iter__
_weakrefset.py(60):             for itemref in self.data:
 --- modulename: _weakrefset, funcname: __exit__
_weakrefset.py(27):         w = self.weakcontainer()
_weakrefset.py(28):         if w is not None:
_weakrefset.py(29):             s = w._iterating
_weakrefset.py(30):             s.remove(self)
_weakrefset.py(31):             if not s:
_weakrefset.py(32):                 w._commit_removals()
 --- modulename: _weakrefset, funcname: _commit_removals
_weakrefset.py(53):         l = self._pending_removals
_weakrefset.py(54):         discard = self.data.discard
_weakrefset.py(55):         while l:
abc.py(179):         for scls in cls.__subclasses__():
abc.py(184):         cls._abc_negative_cache.add(subclass)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(84):         if self._pending_removals:
_weakrefset.py(86):         self.data.add(ref(item, self._remove))
abc.py(185):         return False
abc.py(113):         if issubclass(cls, subclass):
abc.py(116):         cls._abc_registry.add(subclass)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(84):         if self._pending_removals:
_weakrefset.py(86):         self.data.add(ref(item, self._remove))
abc.py(117):         ABCMeta._abc_invalidation_counter += 1  # Invalidate negative cache
io.py(85):               BufferedRWPair):
io.py(86):     BufferedIOBase.register(klass)
 --- modulename: abc, funcname: register
abc.py(107):         if not isinstance(subclass, (type, types.ClassType)):
abc.py(109):         if issubclass(subclass, cls):
 --- modulename: abc, funcname: __subclasscheck__
abc.py(151):         if subclass in cls._abc_cache:
 --- modulename: _weakrefset, funcname: __contains__
_weakrefset.py(71):         try:
_weakrefset.py(72):             wr = ref(item)
_weakrefset.py(75):         return wr in self.data
abc.py(154):         if cls._abc_negative_cache_version < ABCMeta._abc_invalidation_counter:
abc.py(156):             cls._abc_negative_cache = WeakSet()
 --- modulename: _weakrefset, funcname: __init__
_weakrefset.py(37):         self.data = set()
_weakrefset.py(38):         def _remove(item, selfref=ref(self)):
_weakrefset.py(45):         self._remove = _remove
_weakrefset.py(47):         self._pending_removals = []
_weakrefset.py(48):         self._iterating = set()
_weakrefset.py(49):         if data is not None:
abc.py(157):             cls._abc_negative_cache_version = ABCMeta._abc_invalidation_counter
abc.py(161):         ok = cls.__subclasshook__(subclass)
abc.py(162):         if ok is not NotImplemented:
abc.py(170):         if cls in getattr(subclass, '__mro__', ()):
abc.py(174):         for rcls in cls._abc_registry:
 --- modulename: _weakrefset, funcname: __iter__
_weakrefset.py(59):         with _IterationGuard(self):
 --- modulename: _weakrefset, funcname: __init__
_weakrefset.py(18):         self.weakcontainer = ref(weakcontainer)
 --- modulename: _weakrefset, funcname: __enter__
_weakrefset.py(21):         w = self.weakcontainer()
_weakrefset.py(22):         if w is not None:
_weakrefset.py(23):             w._iterating.add(self)
_weakrefset.py(24):         return self
_weakrefset.py(60):             for itemref in self.data:
_weakrefset.py(61):                 item = itemref()
_weakrefset.py(62):                 if item is not None:
_weakrefset.py(65):                     yield item
abc.py(175):             if issubclass(subclass, rcls):
abc.py(174):         for rcls in cls._abc_registry:
 --- modulename: _weakrefset, funcname: __iter__
_weakrefset.py(60):             for itemref in self.data:
_weakrefset.py(61):                 item = itemref()
_weakrefset.py(62):                 if item is not None:
_weakrefset.py(65):                     yield item
abc.py(175):             if issubclass(subclass, rcls):
abc.py(174):         for rcls in cls._abc_registry:
 --- modulename: _weakrefset, funcname: __iter__
_weakrefset.py(60):             for itemref in self.data:
 --- modulename: _weakrefset, funcname: __exit__
_weakrefset.py(27):         w = self.weakcontainer()
_weakrefset.py(28):         if w is not None:
_weakrefset.py(29):             s = w._iterating
_weakrefset.py(30):             s.remove(self)
_weakrefset.py(31):             if not s:
_weakrefset.py(32):                 w._commit_removals()
 --- modulename: _weakrefset, funcname: _commit_removals
_weakrefset.py(53):         l = self._pending_removals
_weakrefset.py(54):         discard = self.data.discard
_weakrefset.py(55):         while l:
abc.py(179):         for scls in cls.__subclasses__():
abc.py(184):         cls._abc_negative_cache.add(subclass)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(84):         if self._pending_removals:
_weakrefset.py(86):         self.data.add(ref(item, self._remove))
abc.py(185):         return False
abc.py(113):         if issubclass(cls, subclass):
abc.py(116):         cls._abc_registry.add(subclass)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(84):         if self._pending_removals:
_weakrefset.py(86):         self.data.add(ref(item, self._remove))
abc.py(117):         ABCMeta._abc_invalidation_counter += 1  # Invalidate negative cache
io.py(85):               BufferedRWPair):
io.py(86):     BufferedIOBase.register(klass)
 --- modulename: abc, funcname: register
abc.py(107):         if not isinstance(subclass, (type, types.ClassType)):
abc.py(109):         if issubclass(subclass, cls):
 --- modulename: abc, funcname: __subclasscheck__
abc.py(151):         if subclass in cls._abc_cache:
 --- modulename: _weakrefset, funcname: __contains__
_weakrefset.py(71):         try:
_weakrefset.py(72):             wr = ref(item)
_weakrefset.py(75):         return wr in self.data
abc.py(154):         if cls._abc_negative_cache_version < ABCMeta._abc_invalidation_counter:
abc.py(156):             cls._abc_negative_cache = WeakSet()
 --- modulename: _weakrefset, funcname: __init__
_weakrefset.py(37):         self.data = set()
_weakrefset.py(38):         def _remove(item, selfref=ref(self)):
_weakrefset.py(45):         self._remove = _remove
_weakrefset.py(47):         self._pending_removals = []
_weakrefset.py(48):         self._iterating = set()
_weakrefset.py(49):         if data is not None:
abc.py(157):             cls._abc_negative_cache_version = ABCMeta._abc_invalidation_counter
abc.py(161):         ok = cls.__subclasshook__(subclass)
abc.py(162):         if ok is not NotImplemented:
abc.py(170):         if cls in getattr(subclass, '__mro__', ()):
abc.py(174):         for rcls in cls._abc_registry:
 --- modulename: _weakrefset, funcname: __iter__
_weakrefset.py(59):         with _IterationGuard(self):
 --- modulename: _weakrefset, funcname: __init__
_weakrefset.py(18):         self.weakcontainer = ref(weakcontainer)
 --- modulename: _weakrefset, funcname: __enter__
_weakrefset.py(21):         w = self.weakcontainer()
_weakrefset.py(22):         if w is not None:
_weakrefset.py(23):             w._iterating.add(self)
_weakrefset.py(24):         return self
_weakrefset.py(60):             for itemref in self.data:
_weakrefset.py(61):                 item = itemref()
_weakrefset.py(62):                 if item is not None:
_weakrefset.py(65):                     yield item
abc.py(175):             if issubclass(subclass, rcls):
abc.py(174):         for rcls in cls._abc_registry:
 --- modulename: _weakrefset, funcname: __iter__
_weakrefset.py(60):             for itemref in self.data:
_weakrefset.py(61):                 item = itemref()
_weakrefset.py(62):                 if item is not None:
_weakrefset.py(65):                     yield item
abc.py(175):             if issubclass(subclass, rcls):
abc.py(174):         for rcls in cls._abc_registry:
 --- modulename: _weakrefset, funcname: __iter__
_weakrefset.py(60):             for itemref in self.data:
_weakrefset.py(61):                 item = itemref()
_weakrefset.py(62):                 if item is not None:
_weakrefset.py(65):                     yield item
abc.py(175):             if issubclass(subclass, rcls):
abc.py(174):         for rcls in cls._abc_registry:
 --- modulename: _weakrefset, funcname: __iter__
_weakrefset.py(60):             for itemref in self.data:
 --- modulename: _weakrefset, funcname: __exit__
_weakrefset.py(27):         w = self.weakcontainer()
_weakrefset.py(28):         if w is not None:
_weakrefset.py(29):             s = w._iterating
_weakrefset.py(30):             s.remove(self)
_weakrefset.py(31):             if not s:
_weakrefset.py(32):                 w._commit_removals()
 --- modulename: _weakrefset, funcname: _commit_removals
_weakrefset.py(53):         l = self._pending_removals
_weakrefset.py(54):         discard = self.data.discard
_weakrefset.py(55):         while l:
abc.py(179):         for scls in cls.__subclasses__():
abc.py(184):         cls._abc_negative_cache.add(subclass)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(84):         if self._pending_removals:
_weakrefset.py(86):         self.data.add(ref(item, self._remove))
abc.py(185):         return False
abc.py(113):         if issubclass(cls, subclass):
abc.py(116):         cls._abc_registry.add(subclass)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(84):         if self._pending_removals:
_weakrefset.py(86):         self.data.add(ref(item, self._remove))
abc.py(117):         ABCMeta._abc_invalidation_counter += 1  # Invalidate negative cache
io.py(85):               BufferedRWPair):
io.py(86):     BufferedIOBase.register(klass)
 --- modulename: abc, funcname: register
abc.py(107):         if not isinstance(subclass, (type, types.ClassType)):
abc.py(109):         if issubclass(subclass, cls):
 --- modulename: abc, funcname: __subclasscheck__
abc.py(151):         if subclass in cls._abc_cache:
 --- modulename: _weakrefset, funcname: __contains__
_weakrefset.py(71):         try:
_weakrefset.py(72):             wr = ref(item)
_weakrefset.py(75):         return wr in self.data
abc.py(154):         if cls._abc_negative_cache_version < ABCMeta._abc_invalidation_counter:
abc.py(156):             cls._abc_negative_cache = WeakSet()
 --- modulename: _weakrefset, funcname: __init__
_weakrefset.py(37):         self.data = set()
_weakrefset.py(38):         def _remove(item, selfref=ref(self)):
_weakrefset.py(45):         self._remove = _remove
_weakrefset.py(47):         self._pending_removals = []
_weakrefset.py(48):         self._iterating = set()
_weakrefset.py(49):         if data is not None:
abc.py(157):             cls._abc_negative_cache_version = ABCMeta._abc_invalidation_counter
abc.py(161):         ok = cls.__subclasshook__(subclass)
abc.py(162):         if ok is not NotImplemented:
abc.py(170):         if cls in getattr(subclass, '__mro__', ()):
abc.py(174):         for rcls in cls._abc_registry:
 --- modulename: _weakrefset, funcname: __iter__
_weakrefset.py(59):         with _IterationGuard(self):
 --- modulename: _weakrefset, funcname: __init__
_weakrefset.py(18):         self.weakcontainer = ref(weakcontainer)
 --- modulename: _weakrefset, funcname: __enter__
_weakrefset.py(21):         w = self.weakcontainer()
_weakrefset.py(22):         if w is not None:
_weakrefset.py(23):             w._iterating.add(self)
_weakrefset.py(24):         return self
_weakrefset.py(60):             for itemref in self.data:
_weakrefset.py(61):                 item = itemref()
_weakrefset.py(62):                 if item is not None:
_weakrefset.py(65):                     yield item
abc.py(175):             if issubclass(subclass, rcls):
abc.py(174):         for rcls in cls._abc_registry:
 --- modulename: _weakrefset, funcname: __iter__
_weakrefset.py(60):             for itemref in self.data:
_weakrefset.py(61):                 item = itemref()
_weakrefset.py(62):                 if item is not None:
_weakrefset.py(65):                     yield item
abc.py(175):             if issubclass(subclass, rcls):
abc.py(174):         for rcls in cls._abc_registry:
 --- modulename: _weakrefset, funcname: __iter__
_weakrefset.py(60):             for itemref in self.data:
_weakrefset.py(61):                 item = itemref()
_weakrefset.py(62):                 if item is not None:
_weakrefset.py(65):                     yield item
abc.py(175):             if issubclass(subclass, rcls):
abc.py(174):         for rcls in cls._abc_registry:
 --- modulename: _weakrefset, funcname: __iter__
_weakrefset.py(60):             for itemref in self.data:
_weakrefset.py(61):                 item = itemref()
_weakrefset.py(62):                 if item is not None:
_weakrefset.py(65):                     yield item
abc.py(175):             if issubclass(subclass, rcls):
abc.py(174):         for rcls in cls._abc_registry:
 --- modulename: _weakrefset, funcname: __iter__
_weakrefset.py(60):             for itemref in self.data:
 --- modulename: _weakrefset, funcname: __exit__
_weakrefset.py(27):         w = self.weakcontainer()
_weakrefset.py(28):         if w is not None:
_weakrefset.py(29):             s = w._iterating
_weakrefset.py(30):             s.remove(self)
_weakrefset.py(31):             if not s:
_weakrefset.py(32):                 w._commit_removals()
 --- modulename: _weakrefset, funcname: _commit_removals
_weakrefset.py(53):         l = self._pending_removals
_weakrefset.py(54):         discard = self.data.discard
_weakrefset.py(55):         while l:
abc.py(179):         for scls in cls.__subclasses__():
abc.py(184):         cls._abc_negative_cache.add(subclass)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(84):         if self._pending_removals:
_weakrefset.py(86):         self.data.add(ref(item, self._remove))
abc.py(185):         return False
abc.py(113):         if issubclass(cls, subclass):
abc.py(116):         cls._abc_registry.add(subclass)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(84):         if self._pending_removals:
_weakrefset.py(86):         self.data.add(ref(item, self._remove))
abc.py(117):         ABCMeta._abc_invalidation_counter += 1  # Invalidate negative cache
io.py(85):               BufferedRWPair):
io.py(88): for klass in (StringIO, TextIOWrapper):
io.py(89):     TextIOBase.register(klass)
 --- modulename: abc, funcname: register
abc.py(107):         if not isinstance(subclass, (type, types.ClassType)):
abc.py(109):         if issubclass(subclass, cls):
 --- modulename: abc, funcname: __subclasscheck__
abc.py(151):         if subclass in cls._abc_cache:
 --- modulename: _weakrefset, funcname: __contains__
_weakrefset.py(71):         try:
_weakrefset.py(72):             wr = ref(item)
_weakrefset.py(75):         return wr in self.data
abc.py(154):         if cls._abc_negative_cache_version < ABCMeta._abc_invalidation_counter:
abc.py(156):             cls._abc_negative_cache = WeakSet()
 --- modulename: _weakrefset, funcname: __init__
_weakrefset.py(37):         self.data = set()
_weakrefset.py(38):         def _remove(item, selfref=ref(self)):
_weakrefset.py(45):         self._remove = _remove
_weakrefset.py(47):         self._pending_removals = []
_weakrefset.py(48):         self._iterating = set()
_weakrefset.py(49):         if data is not None:
abc.py(157):             cls._abc_negative_cache_version = ABCMeta._abc_invalidation_counter
abc.py(161):         ok = cls.__subclasshook__(subclass)
abc.py(162):         if ok is not NotImplemented:
abc.py(170):         if cls in getattr(subclass, '__mro__', ()):
abc.py(174):         for rcls in cls._abc_registry:
 --- modulename: _weakrefset, funcname: __iter__
_weakrefset.py(59):         with _IterationGuard(self):
 --- modulename: _weakrefset, funcname: __init__
_weakrefset.py(18):         self.weakcontainer = ref(weakcontainer)
 --- modulename: _weakrefset, funcname: __enter__
_weakrefset.py(21):         w = self.weakcontainer()
_weakrefset.py(22):         if w is not None:
_weakrefset.py(23):             w._iterating.add(self)
_weakrefset.py(24):         return self
_weakrefset.py(60):             for itemref in self.data:
 --- modulename: _weakrefset, funcname: __exit__
_weakrefset.py(27):         w = self.weakcontainer()
_weakrefset.py(28):         if w is not None:
_weakrefset.py(29):             s = w._iterating
_weakrefset.py(30):             s.remove(self)
_weakrefset.py(31):             if not s:
_weakrefset.py(32):                 w._commit_removals()
 --- modulename: _weakrefset, funcname: _commit_removals
_weakrefset.py(53):         l = self._pending_removals
_weakrefset.py(54):         discard = self.data.discard
_weakrefset.py(55):         while l:
abc.py(179):         for scls in cls.__subclasses__():
abc.py(184):         cls._abc_negative_cache.add(subclass)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(84):         if self._pending_removals:
_weakrefset.py(86):         self.data.add(ref(item, self._remove))
abc.py(185):         return False
abc.py(113):         if issubclass(cls, subclass):
abc.py(116):         cls._abc_registry.add(subclass)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(84):         if self._pending_removals:
_weakrefset.py(86):         self.data.add(ref(item, self._remove))
abc.py(117):         ABCMeta._abc_invalidation_counter += 1  # Invalidate negative cache
io.py(88): for klass in (StringIO, TextIOWrapper):
io.py(89):     TextIOBase.register(klass)
 --- modulename: abc, funcname: register
abc.py(107):         if not isinstance(subclass, (type, types.ClassType)):
abc.py(109):         if issubclass(subclass, cls):
 --- modulename: abc, funcname: __subclasscheck__
abc.py(151):         if subclass in cls._abc_cache:
 --- modulename: _weakrefset, funcname: __contains__
_weakrefset.py(71):         try:
_weakrefset.py(72):             wr = ref(item)
_weakrefset.py(75):         return wr in self.data
abc.py(154):         if cls._abc_negative_cache_version < ABCMeta._abc_invalidation_counter:
abc.py(156):             cls._abc_negative_cache = WeakSet()
 --- modulename: _weakrefset, funcname: __init__
_weakrefset.py(37):         self.data = set()
_weakrefset.py(38):         def _remove(item, selfref=ref(self)):
_weakrefset.py(45):         self._remove = _remove
_weakrefset.py(47):         self._pending_removals = []
_weakrefset.py(48):         self._iterating = set()
_weakrefset.py(49):         if data is not None:
abc.py(157):             cls._abc_negative_cache_version = ABCMeta._abc_invalidation_counter
abc.py(161):         ok = cls.__subclasshook__(subclass)
abc.py(162):         if ok is not NotImplemented:
abc.py(170):         if cls in getattr(subclass, '__mro__', ()):
abc.py(174):         for rcls in cls._abc_registry:
 --- modulename: _weakrefset, funcname: __iter__
_weakrefset.py(59):         with _IterationGuard(self):
 --- modulename: _weakrefset, funcname: __init__
_weakrefset.py(18):         self.weakcontainer = ref(weakcontainer)
 --- modulename: _weakrefset, funcname: __enter__
_weakrefset.py(21):         w = self.weakcontainer()
_weakrefset.py(22):         if w is not None:
_weakrefset.py(23):             w._iterating.add(self)
_weakrefset.py(24):         return self
_weakrefset.py(60):             for itemref in self.data:
_weakrefset.py(61):                 item = itemref()
_weakrefset.py(62):                 if item is not None:
_weakrefset.py(65):                     yield item
abc.py(175):             if issubclass(subclass, rcls):
abc.py(174):         for rcls in cls._abc_registry:
 --- modulename: _weakrefset, funcname: __iter__
_weakrefset.py(60):             for itemref in self.data:
 --- modulename: _weakrefset, funcname: __exit__
_weakrefset.py(27):         w = self.weakcontainer()
_weakrefset.py(28):         if w is not None:
_weakrefset.py(29):             s = w._iterating
_weakrefset.py(30):             s.remove(self)
_weakrefset.py(31):             if not s:
_weakrefset.py(32):                 w._commit_removals()
 --- modulename: _weakrefset, funcname: _commit_removals
_weakrefset.py(53):         l = self._pending_removals
_weakrefset.py(54):         discard = self.data.discard
_weakrefset.py(55):         while l:
abc.py(179):         for scls in cls.__subclasses__():
abc.py(184):         cls._abc_negative_cache.add(subclass)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(84):         if self._pending_removals:
_weakrefset.py(86):         self.data.add(ref(item, self._remove))
abc.py(185):         return False
abc.py(113):         if issubclass(cls, subclass):
abc.py(116):         cls._abc_registry.add(subclass)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(84):         if self._pending_removals:
_weakrefset.py(86):         self.data.add(ref(item, self._remove))
abc.py(117):         ABCMeta._abc_invalidation_counter += 1  # Invalidate negative cache
io.py(88): for klass in (StringIO, TextIOWrapper):
io.py(90): del klass
tempfile.py(33): import os as _os
tempfile.py(34): import errno as _errno
tempfile.py(35): from random import Random as _Random
 --- modulename: random, funcname: <module>
random.py(40): """
random.py(42): from __future__ import division
random.py(43): from warnings import warn as _warn
random.py(44): from types import MethodType as _MethodType, BuiltinMethodType as _BuiltinMethodType
random.py(45): from math import log as _log, exp as _exp, pi as _pi, e as _e, ceil as _ceil
random.py(46): from math import sqrt as _sqrt, acos as _acos, cos as _cos, sin as _sin
random.py(47): from os import urandom as _urandom
random.py(48): from binascii import hexlify as _hexlify
random.py(49): import hashlib as _hashlib
 --- modulename: hashlib, funcname: <module>
hashlib.py(56): """
hashlib.py(60): __always_supported = ('md5', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512')
hashlib.py(62): algorithms_guaranteed = set(__always_supported)
hashlib.py(63): algorithms_available = set(__always_supported)
hashlib.py(65): algorithms = __always_supported
hashlib.py(67): __all__ = __always_supported + ('new', 'algorithms_guaranteed',
hashlib.py(69):                                 'pbkdf2_hmac')
hashlib.py(72): def __get_builtin_constructor(name):
hashlib.py(100): def __get_openssl_constructor(name):
hashlib.py(112): def __py_new(name, string=''):
hashlib.py(119): def __hash_new(name, string=''):
hashlib.py(133): try:
hashlib.py(134):     import _hashlib
hashlib.py(135):     new = __hash_new
hashlib.py(136):     __get_hash = __get_openssl_constructor
hashlib.py(137):     algorithms_available = algorithms_available.union(
hashlib.py(138):         _hashlib.openssl_md_meth_names)
hashlib.py(143): for __func_name in __always_supported:
hashlib.py(146):     try:
hashlib.py(147):         globals()[__func_name] = __get_hash(__func_name)
 --- modulename: hashlib, funcname: __get_openssl_constructor
hashlib.py(101):     try:
hashlib.py(102):         f = getattr(_hashlib, 'openssl_' + name)
hashlib.py(105):         f()
hashlib.py(107):         return f
hashlib.py(143): for __func_name in __always_supported:
hashlib.py(146):     try:
hashlib.py(147):         globals()[__func_name] = __get_hash(__func_name)
 --- modulename: hashlib, funcname: __get_openssl_constructor
hashlib.py(101):     try:
hashlib.py(102):         f = getattr(_hashlib, 'openssl_' + name)
hashlib.py(105):         f()
hashlib.py(107):         return f
hashlib.py(143): for __func_name in __always_supported:
hashlib.py(146):     try:
hashlib.py(147):         globals()[__func_name] = __get_hash(__func_name)
 --- modulename: hashlib, funcname: __get_openssl_constructor
hashlib.py(101):     try:
hashlib.py(102):         f = getattr(_hashlib, 'openssl_' + name)
hashlib.py(105):         f()
hashlib.py(107):         return f
hashlib.py(143): for __func_name in __always_supported:
hashlib.py(146):     try:
hashlib.py(147):         globals()[__func_name] = __get_hash(__func_name)
 --- modulename: hashlib, funcname: __get_openssl_constructor
hashlib.py(101):     try:
hashlib.py(102):         f = getattr(_hashlib, 'openssl_' + name)
hashlib.py(105):         f()
hashlib.py(107):         return f
hashlib.py(143): for __func_name in __always_supported:
hashlib.py(146):     try:
hashlib.py(147):         globals()[__func_name] = __get_hash(__func_name)
 --- modulename: hashlib, funcname: __get_openssl_constructor
hashlib.py(101):     try:
hashlib.py(102):         f = getattr(_hashlib, 'openssl_' + name)
hashlib.py(105):         f()
hashlib.py(107):         return f
hashlib.py(143): for __func_name in __always_supported:
hashlib.py(146):     try:
hashlib.py(147):         globals()[__func_name] = __get_hash(__func_name)
 --- modulename: hashlib, funcname: __get_openssl_constructor
hashlib.py(101):     try:
hashlib.py(102):         f = getattr(_hashlib, 'openssl_' + name)
hashlib.py(105):         f()
hashlib.py(107):         return f
hashlib.py(143): for __func_name in __always_supported:
hashlib.py(153): try:
hashlib.py(155):     from _hashlib import pbkdf2_hmac
hashlib.py(220): del __always_supported, __func_name, __get_hash
hashlib.py(221): del __py_new, __hash_new, __get_openssl_constructor
random.py(51): __all__ = ["Random","seed","random","uniform","randint","choice","sample",
random.py(52):            "randrange","shuffle","normalvariate","lognormvariate",
random.py(53):            "expovariate","vonmisesvariate","gammavariate","triangular",
random.py(54):            "gauss","betavariate","paretovariate","weibullvariate",
random.py(55):            "getstate","setstate","jumpahead", "WichmannHill", "getrandbits",
random.py(56):            "SystemRandom"]
random.py(58): NV_MAGICCONST = 4 * _exp(-0.5)/_sqrt(2.0)
random.py(59): TWOPI = 2.0*_pi
random.py(60): LOG4 = _log(4.0)
random.py(61): SG_MAGICCONST = 1.0 + _log(4.5)
random.py(62): BPF = 53        # Number of bits in a float
random.py(63): RECIP_BPF = 2**-BPF
random.py(70): import _random
random.py(72): class Random(_random.Random):
 --- modulename: random, funcname: Random
random.py(72): class Random(_random.Random):
random.py(87):     """
random.py(89):     VERSION = 3     # used by getstate/setstate
random.py(91):     def __init__(self, x=None):
random.py(100):     def seed(self, a=None):
random.py(121):     def getstate(self):
random.py(125):     def setstate(self, state):
random.py(147):     def jumpahead(self, n):
random.py(164):     def __getstate__(self): # for pickle
random.py(167):     def __setstate__(self, state):  # for pickle
random.py(170):     def __reduce__(self):
random.py(175):     def randrange(self, start, stop=None, step=1, _int=int, _maxwidth=1L<<BPF):
random.py(238):     def randint(self, a, b):
random.py(244):     def _randbelow(self, n, _log=_log, _int=int, _maxwidth=1L<<BPF,
random.py(245):                    _Method=_MethodType, _BuiltinMethod=_BuiltinMethodType):
random.py(273):     def choice(self, seq):
random.py(277):     def shuffle(self, x, random=None):
random.py(293):     def sample(self, population, k):
random.py(358):     def uniform(self, a, b):
random.py(364):     def triangular(self, low=0.0, high=1.0, mode=None):
random.py(386):     def normalvariate(self, mu, sigma):
random.py(411):     def lognormvariate(self, mu, sigma):
random.py(423):     def expovariate(self, lambd):
random.py(442):     def vonmisesvariate(self, mu, kappa):
random.py(490):     def gammavariate(self, alpha, beta):
random.py(562):     def gauss(self, mu, sigma):
random.py(615):     def betavariate(self, alpha, beta):
random.py(633):     def paretovariate(self, alpha):
random.py(642):     def weibullvariate(self, alpha, beta):
random.py(655): class WichmannHill(Random):
 --- modulename: random, funcname: WichmannHill
random.py(655): class WichmannHill(Random):
random.py(657):     VERSION = 1     # used by getstate/setstate
random.py(659):     def seed(self, a=None):
random.py(690):     def random(self):
random.py(721):     def getstate(self):
random.py(725):     def setstate(self, state):
random.py(735):     def jumpahead(self, n):
random.py(757):     def __whseed(self, x=0, y=0, z=0):
random.py(780):     def whseed(self, a=None):
random.py(805): class SystemRandom(Random):
 --- modulename: random, funcname: SystemRandom
random.py(805): class SystemRandom(Random):
random.py(811):     """
random.py(813):     def random(self):
random.py(817):     def getrandbits(self, k):
random.py(827):     def _stub(self, *args, **kwds):
random.py(830):     seed = jumpahead = _stub
random.py(832):     def _notimplemented(self, *args, **kwds):
random.py(835):     getstate = setstate = _notimplemented
random.py(839): def _test_generator(n, func, args):
random.py(861): def _test(N=2000):
random.py(885): _inst = Random()
 --- modulename: random, funcname: __init__
random.py(97):         self.seed(x)
 --- modulename: random, funcname: seed
random.py(109):         if a is None:
random.py(110):             try:
random.py(113):                 a = long(_hexlify(_urandom(2500)), 16)
random.py(118):         super(Random, self).seed(a)
random.py(119):         self.gauss_next = None
random.py(98):         self.gauss_next = None
random.py(886): seed = _inst.seed
random.py(887): random = _inst.random
random.py(888): uniform = _inst.uniform
random.py(889): triangular = _inst.triangular
random.py(890): randint = _inst.randint
random.py(891): choice = _inst.choice
random.py(892): randrange = _inst.randrange
random.py(893): sample = _inst.sample
random.py(894): shuffle = _inst.shuffle
random.py(895): normalvariate = _inst.normalvariate
random.py(896): lognormvariate = _inst.lognormvariate
random.py(897): expovariate = _inst.expovariate
random.py(898): vonmisesvariate = _inst.vonmisesvariate
random.py(899): gammavariate = _inst.gammavariate
random.py(900): gauss = _inst.gauss
random.py(901): betavariate = _inst.betavariate
random.py(902): paretovariate = _inst.paretovariate
random.py(903): weibullvariate = _inst.weibullvariate
random.py(904): getstate = _inst.getstate
random.py(905): setstate = _inst.setstate
random.py(906): jumpahead = _inst.jumpahead
random.py(907): getrandbits = _inst.getrandbits
random.py(909): if __name__ == '__main__':
tempfile.py(37): try:
tempfile.py(38):     from cStringIO import StringIO as _StringIO
tempfile.py(42): try:
tempfile.py(43):     import fcntl as _fcntl
tempfile.py(48):     def _set_cloexec(fd):
tempfile.py(59): try:
tempfile.py(60):     import thread as _thread
tempfile.py(63): _allocate_lock = _thread.allocate_lock
tempfile.py(65): _text_openflags = _os.O_RDWR | _os.O_CREAT | _os.O_EXCL
tempfile.py(66): if hasattr(_os, 'O_NOINHERIT'):
tempfile.py(68): if hasattr(_os, 'O_NOFOLLOW'):
tempfile.py(69):     _text_openflags |= _os.O_NOFOLLOW
tempfile.py(71): _bin_openflags = _text_openflags
tempfile.py(72): if hasattr(_os, 'O_BINARY'):
tempfile.py(75): if hasattr(_os, 'TMP_MAX'):
tempfile.py(76):     TMP_MAX = _os.TMP_MAX
tempfile.py(80): template = "tmp"
tempfile.py(84): _once_lock = _allocate_lock()
tempfile.py(86): if hasattr(_os, "lstat"):
tempfile.py(87):     _stat = _os.lstat
tempfile.py(100): def _exists(fn):
tempfile.py(108): class _RandomNameSequence:
 --- modulename: tempfile, funcname: _RandomNameSequence
tempfile.py(108): class _RandomNameSequence:
tempfile.py(114):     _RandomNameSequence is an iterator."""
tempfile.py(117):                   "ABCDEFGHIJKLMNOPQRSTUVWXYZ" +
tempfile.py(118):                   "0123456789_")
tempfile.py(120):     def __init__(self):
tempfile.py(124):     @property
tempfile.py(132):     def __iter__(self):
tempfile.py(135):     def next(self):
tempfile.py(148): def _candidate_tempdir_list():
tempfile.py(176): def _get_default_tempdir():
tempfile.py(219): _name_sequence = None
tempfile.py(221): def _get_candidate_names():
tempfile.py(235): def _mkstemp_inner(dir, pre, suf, flags):
tempfile.py(262): def gettempprefix():
tempfile.py(266): tempdir = None
tempfile.py(268): def gettempdir():
tempfile.py(280): def mkstemp(suffix="", prefix=template, dir=None, text=False):
tempfile.py(317): def mkdtemp(suffix="", prefix=template, dir=None):
tempfile.py(353): def mktemp(suffix="", prefix=template, dir=None):
tempfile.py(383): class _TemporaryFileWrapper:
 --- modulename: tempfile, funcname: _TemporaryFileWrapper
tempfile.py(383): class _TemporaryFileWrapper:
tempfile.py(389):     """
tempfile.py(391):     def __init__(self, file, name, delete=True):
tempfile.py(397):     def __getattr__(self, name):
tempfile.py(409):     def __enter__(self):
tempfile.py(416):     if _os.name != 'nt':
tempfile.py(422):         unlink = _os.unlink
tempfile.py(424):         def close(self):
tempfile.py(433):         def __del__(self):
tempfile.py(438):         def __exit__(self, exc, value, tb):
tempfile.py(447): def NamedTemporaryFile(mode='w+b', bufsize=-1, suffix="",
tempfile.py(448):                        prefix=template, dir=None, delete=True):
tempfile.py(483): if _os.name != 'posix' or _os.sys.platform == 'cygwin':
tempfile.py(489):     def TemporaryFile(mode='w+b', bufsize=-1, suffix="",
tempfile.py(490):                       prefix=template, dir=None):
tempfile.py(518): class SpooledTemporaryFile:
 --- modulename: tempfile, funcname: SpooledTemporaryFile
tempfile.py(518): class SpooledTemporaryFile:
tempfile.py(522):     """
tempfile.py(523):     _rolled = False
tempfile.py(525):     def __init__(self, max_size=0, mode='w+b', bufsize=-1,
tempfile.py(526):                  suffix="", prefix=template, dir=None):
tempfile.py(532):     def _check(self, file):
tempfile.py(538):     def rollover(self):
tempfile.py(555):     def __enter__(self):
tempfile.py(560):     def __exit__(self, exc, value, tb):
tempfile.py(564):     def __iter__(self):
tempfile.py(567):     def close(self):
tempfile.py(570):     @property
tempfile.py(574):     def fileno(self):
tempfile.py(578):     def flush(self):
tempfile.py(581):     def isatty(self):
tempfile.py(584):     @property
tempfile.py(591):     @property
tempfile.py(598):     def next(self):
tempfile.py(601):     def read(self, *args):
tempfile.py(604):     def readline(self, *args):
tempfile.py(607):     def readlines(self, *args):
tempfile.py(610):     def seek(self, *args):
tempfile.py(613):     @property
tempfile.py(617):     def tell(self):
tempfile.py(620):     def truncate(self):
tempfile.py(623):     def write(self, s):
tempfile.py(629):     def writelines(self, iterable):
tempfile.py(635):     def xreadlines(self, *args):
pipes.py(63): import string
pipes.py(65): __all__ = ["Template"]
pipes.py(69): FILEIN_FILEOUT = 'ff'                   # Must read & write real files
pipes.py(70): STDIN_FILEOUT  = '-f'                   # Must write a real file
pipes.py(71): FILEIN_STDOUT  = 'f-'                   # Must read a real file
pipes.py(72): STDIN_STDOUT   = '--'                   # Normal pipeline element
pipes.py(73): SOURCE         = '.-'                   # Must be first, writes stdout
pipes.py(74): SINK           = '-.'                   # Must be last, reads stdin
pipes.py(76): stepkinds = [FILEIN_FILEOUT, STDIN_FILEOUT, FILEIN_STDOUT, STDIN_STDOUT, \
pipes.py(77):              SOURCE, SINK]
pipes.py(80): class Template:
 --- modulename: pipes, funcname: Template
pipes.py(80): class Template:
pipes.py(81):     """Class representing a pipeline template."""
pipes.py(83):     def __init__(self):
pipes.py(88):     def __repr__(self):
pipes.py(92):     def reset(self):
pipes.py(96):     def clone(self):
pipes.py(104):     def debug(self, flag):
pipes.py(108):     def append(self, cmd, kind):
pipes.py(130):     def prepend(self, cmd, kind):
pipes.py(152):     def open(self, file, rw):
pipes.py(162):     def open_r(self, file):
pipes.py(173):     def open_w(self, file):
pipes.py(182):     def copy(self, infile, outfile):
pipes.py(185):     def makepipeline(self, infile, outfile):
pipes.py(193): def makepipeline(infile, steps, outfile):
pipes.py(265): _safechars = frozenset(string.ascii_letters + string.digits + '@%_-+=:,./')
pipes.py(267): def quote(file):
backward.py(62): try:
backward.py(63):     {}.iteritems
backward.py(69):     def iitems(d):
backward.py(74): try:
backward.py(75):     iter([]).next
backward.py(81):     def iternext(seq):
backward.py(87): if env.PY3:
backward.py(106):     def to_bytes(s):
backward.py(110):     def binary_bytes(byte_values):
backward.py(114):     def byte_to_int(byte_value):
backward.py(118):     def bytes_to_ints(bytes_value):
backward.py(124): try:
backward.py(126):     BUILTINS = sys.modules['__builtin__']
backward.py(133): try:
backward.py(134):     import importlib
 --- modulename: __init__, funcname: <module>
__init__.py(1): """Backport of importlib.import_module from 3.x."""
__init__.py(4): import sys
__init__.py(6): def _resolve_name(name, package, level):
__init__.py(20): def import_module(name, package=None):
backward.py(135):     import importlib.util
backward.py(137): except ImportError:
backward.py(138):     importlib = None
backward.py(141): try:
backward.py(142):     importlib_util_find_spec = importlib.util.find_spec
backward.py(143): except Exception:
backward.py(144):     import imp
backward.py(145):     importlib_util_find_spec = None
backward.py(148): try:
backward.py(149):     PYC_MAGIC_NUMBER = importlib.util.MAGIC_NUMBER
backward.py(150): except AttributeError:
backward.py(151):     PYC_MAGIC_NUMBER = imp.get_magic()
backward.py(154): def import_local_file(modname, modfile=None):
files.py(16): from coverage.misc import contract, CoverageException, join_regex, isolate_module
 --- modulename: misc, funcname: <module>
misc.py(4): """Miscellaneous stuff for coverage.py."""
misc.py(6): import errno
misc.py(7): import hashlib
misc.py(8): import inspect
misc.py(9): import locale
 --- modulename: locale, funcname: <module>
locale.py(12): """
locale.py(14): import sys
locale.py(15): import encodings
locale.py(16): import encodings.aliases
locale.py(17): import re
locale.py(18): import operator
locale.py(19): import functools
 --- modulename: functools, funcname: <module>
functools.py(2): """
functools.py(10): from _functools import partial, reduce
functools.py(15): WRAPPER_ASSIGNMENTS = ('__module__', '__name__', '__doc__')
functools.py(16): WRAPPER_UPDATES = ('__dict__',)
functools.py(19):                    assigned = WRAPPER_ASSIGNMENTS,
functools.py(20):                    updated = WRAPPER_UPDATES):
functools.py(40):           assigned = WRAPPER_ASSIGNMENTS,
functools.py(41):           updated = WRAPPER_UPDATES):
functools.py(53): def total_ordering(cls):
functools.py(80): def cmp_to_key(mycmp):
locale.py(21): try:
locale.py(22):     _unicode = unicode
locale.py(35): __all__ = ["getlocale", "getdefaultlocale", "getpreferredencoding", "Error",
locale.py(36):            "setlocale", "resetlocale", "localeconv", "strcoll", "strxfrm",
locale.py(37):            "str", "atof", "atoi", "format", "format_string", "currency",
locale.py(38):            "normalize", "LC_CTYPE", "LC_COLLATE", "LC_TIME", "LC_MONETARY",
locale.py(39):            "LC_NUMERIC", "LC_ALL", "CHAR_MAX"]
locale.py(41): try:
locale.py(43):     from _locale import *
locale.py(104): _localeconv = localeconv
locale.py(108): _override_localeconv = {}
locale.py(110): @functools.wraps(_localeconv)
 --- modulename: functools, funcname: wraps
functools.py(50):     return partial(update_wrapper, wrapped=wrapped,
functools.py(51):                    assigned=assigned, updated=updated)
 --- modulename: functools, funcname: update_wrapper
functools.py(32):     for attr in assigned:
functools.py(33):         setattr(wrapper, attr, getattr(wrapped, attr))
functools.py(32):     for attr in assigned:
functools.py(33):         setattr(wrapper, attr, getattr(wrapped, attr))
functools.py(32):     for attr in assigned:
functools.py(33):         setattr(wrapper, attr, getattr(wrapped, attr))
functools.py(32):     for attr in assigned:
functools.py(34):     for attr in updated:
functools.py(35):         getattr(wrapper, attr).update(getattr(wrapped, attr, {}))
functools.py(34):     for attr in updated:
functools.py(37):     return wrapper
locale.py(124): def _grouping_intervals(grouping):
locale.py(140): def _group(s, monetary=False):
locale.py(171): def _strip_padding(s, amount):
locale.py(182): _percent_re = re.compile(r'%(?:\((?P<key>.*?)\))?'
 --- modulename: re, funcname: compile
re.py(194):     return _compile(pattern, flags)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(240):         except KeyError:
re.py(241):             pass
re.py(242):     if isinstance(pattern, _pattern_type):
re.py(246):     if not sre_compile.isstring(pattern):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
re.py(248):     try:
re.py(249):         p = sre_compile.compile(pattern, flags)
 --- modulename: sre_compile, funcname: compile
sre_compile.py(570):     if isstring(p):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
sre_compile.py(571):         pattern = p
sre_compile.py(572):         p = sre_parse.parse(p, flags)
 --- modulename: sre_parse, funcname: parse
sre_parse.py(709):     source = Tokenizer(str)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(190):         self.string = string
sre_parse.py(191):         self.index = 0
sre_parse.py(192):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(711):     if pattern is None:
sre_parse.py(712):         pattern = Pattern()
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(68):         self.flags = 0
sre_parse.py(69):         self.open = []
sre_parse.py(70):         self.groups = 1
sre_parse.py(71):         self.groupdict = {}
sre_parse.py(72):         self.lookbehind = 0
sre_parse.py(713):     pattern.flags = flags
sre_parse.py(714):     pattern.str = str
sre_parse.py(716):     p = _parse_sub(source, pattern, 0)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(549):                 group = 0
sre_parse.py(551):                 if sourcematch("P"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(600):                 elif sourcematch(":"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(602):                     group = 2
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(670):                     group = None
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(273):     code = ESCAPES.get(escape)
sre_parse.py(274):     if code:
sre_parse.py(276):     try:
sre_parse.py(277):         c = escape[1:2]
sre_parse.py(278):         if c == "x":
sre_parse.py(285):         elif c == "0":
sre_parse.py(290):         elif c in DIGITS:
sre_parse.py(311):         if len(escape) == 2:
sre_parse.py(312):             return LITERAL, ord(escape[1])
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(549):                 group = 0
sre_parse.py(551):                 if sourcematch("P"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(553):                     if sourcematch("<"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(555):                         name = ""
sre_parse.py(556):                         while 1:
sre_parse.py(557):                             char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(558):                             if char is None:
sre_parse.py(560):                             if char == ">":
sre_parse.py(562):                             name = name + char
sre_parse.py(557):                             char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(558):                             if char is None:
sre_parse.py(560):                             if char == ">":
sre_parse.py(562):                             name = name + char
sre_parse.py(557):                             char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(558):                             if char is None:
sre_parse.py(560):                             if char == ">":
sre_parse.py(562):                             name = name + char
sre_parse.py(557):                             char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(558):                             if char is None:
sre_parse.py(560):                             if char == ">":
sre_parse.py(561):                                 break
sre_parse.py(563):                         group = 1
sre_parse.py(564):                         if not name:
sre_parse.py(566):                         if not isname(name):
 --- modulename: sre_parse, funcname: isname
sre_parse.py(229):     if not isident(name[0]):
 --- modulename: sre_parse, funcname: isident
sre_parse.py(222):     return "a" <= char <= "z" or "A" <= char <= "Z" or char == "_"
sre_parse.py(231):     for char in name[1:]:
sre_parse.py(232):         if not isident(char) and not isdigit(char):
 --- modulename: sre_parse, funcname: isident
sre_parse.py(222):     return "a" <= char <= "z" or "A" <= char <= "Z" or char == "_"
sre_parse.py(231):     for char in name[1:]:
sre_parse.py(232):         if not isident(char) and not isdigit(char):
 --- modulename: sre_parse, funcname: isident
sre_parse.py(222):     return "a" <= char <= "z" or "A" <= char <= "Z" or char == "_"
sre_parse.py(231):     for char in name[1:]:
sre_parse.py(234):     return True
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(78):             ogid = self.groupdict.get(name, None)
sre_parse.py(79):             if ogid is not None:
sre_parse.py(82):             self.groupdict[name] = gid
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(542):             subpatternappend((ANY, None))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(493):                 min, max = 0, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(537):                 subpattern[-1] = (MIN_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(273):     code = ESCAPES.get(escape)
sre_parse.py(274):     if code:
sre_parse.py(276):     try:
sre_parse.py(277):         c = escape[1:2]
sre_parse.py(278):         if c == "x":
sre_parse.py(285):         elif c == "0":
sre_parse.py(290):         elif c in DIGITS:
sre_parse.py(311):         if len(escape) == 2:
sre_parse.py(312):             return LITERAL, ord(escape[1])
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(491):                 min, max = 0, 1
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(549):                 group = 0
sre_parse.py(551):                 if sourcematch("P"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(553):                     if sourcematch("<"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(555):                         name = ""
sre_parse.py(556):                         while 1:
sre_parse.py(557):                             char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(558):                             if char is None:
sre_parse.py(560):                             if char == ">":
sre_parse.py(562):                             name = name + char
sre_parse.py(557):                             char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(558):                             if char is None:
sre_parse.py(560):                             if char == ">":
sre_parse.py(562):                             name = name + char
sre_parse.py(557):                             char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(558):                             if char is None:
sre_parse.py(560):                             if char == ">":
sre_parse.py(562):                             name = name + char
sre_parse.py(557):                             char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(558):                             if char is None:
sre_parse.py(560):                             if char == ">":
sre_parse.py(562):                             name = name + char
sre_parse.py(557):                             char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(558):                             if char is None:
sre_parse.py(560):                             if char == ">":
sre_parse.py(562):                             name = name + char
sre_parse.py(557):                             char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(558):                             if char is None:
sre_parse.py(560):                             if char == ">":
sre_parse.py(562):                             name = name + char
sre_parse.py(557):                             char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(558):                             if char is None:
sre_parse.py(560):                             if char == ">":
sre_parse.py(562):                             name = name + char
sre_parse.py(557):                             char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(558):                             if char is None:
sre_parse.py(560):                             if char == ">":
sre_parse.py(562):                             name = name + char
sre_parse.py(557):                             char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(558):                             if char is None:
sre_parse.py(560):                             if char == ">":
sre_parse.py(562):                             name = name + char
sre_parse.py(557):                             char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(558):                             if char is None:
sre_parse.py(560):                             if char == ">":
sre_parse.py(561):                                 break
sre_parse.py(563):                         group = 1
sre_parse.py(564):                         if not name:
sre_parse.py(566):                         if not isname(name):
 --- modulename: sre_parse, funcname: isname
sre_parse.py(229):     if not isident(name[0]):
 --- modulename: sre_parse, funcname: isident
sre_parse.py(222):     return "a" <= char <= "z" or "A" <= char <= "Z" or char == "_"
sre_parse.py(231):     for char in name[1:]:
sre_parse.py(232):         if not isident(char) and not isdigit(char):
 --- modulename: sre_parse, funcname: isident
sre_parse.py(222):     return "a" <= char <= "z" or "A" <= char <= "Z" or char == "_"
sre_parse.py(231):     for char in name[1:]:
sre_parse.py(232):         if not isident(char) and not isdigit(char):
 --- modulename: sre_parse, funcname: isident
sre_parse.py(222):     return "a" <= char <= "z" or "A" <= char <= "Z" or char == "_"
sre_parse.py(231):     for char in name[1:]:
sre_parse.py(232):         if not isident(char) and not isdigit(char):
 --- modulename: sre_parse, funcname: isident
sre_parse.py(222):     return "a" <= char <= "z" or "A" <= char <= "Z" or char == "_"
sre_parse.py(231):     for char in name[1:]:
sre_parse.py(232):         if not isident(char) and not isdigit(char):
 --- modulename: sre_parse, funcname: isident
sre_parse.py(222):     return "a" <= char <= "z" or "A" <= char <= "Z" or char == "_"
sre_parse.py(231):     for char in name[1:]:
sre_parse.py(232):         if not isident(char) and not isdigit(char):
 --- modulename: sre_parse, funcname: isident
sre_parse.py(222):     return "a" <= char <= "z" or "A" <= char <= "Z" or char == "_"
sre_parse.py(231):     for char in name[1:]:
sre_parse.py(232):         if not isident(char) and not isdigit(char):
 --- modulename: sre_parse, funcname: isident
sre_parse.py(222):     return "a" <= char <= "z" or "A" <= char <= "Z" or char == "_"
sre_parse.py(231):     for char in name[1:]:
sre_parse.py(232):         if not isident(char) and not isdigit(char):
 --- modulename: sre_parse, funcname: isident
sre_parse.py(222):     return "a" <= char <= "z" or "A" <= char <= "Z" or char == "_"
sre_parse.py(231):     for char in name[1:]:
sre_parse.py(232):         if not isident(char) and not isdigit(char):
 --- modulename: sre_parse, funcname: isident
sre_parse.py(222):     return "a" <= char <= "z" or "A" <= char <= "Z" or char == "_"
sre_parse.py(231):     for char in name[1:]:
sre_parse.py(234):     return True
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(78):             ogid = self.groupdict.get(name, None)
sre_parse.py(79):             if ogid is not None:
sre_parse.py(82):             self.groupdict[name] = gid
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(453):                     this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(454):                     if this == "]":
sre_parse.py(460):                     elif this:
sre_parse.py(461):                         if this[0] == "\\":
sre_parse.py(464):                             code2 = LITERAL, ord(this)
sre_parse.py(465):                         if code1[0] != LITERAL or code2[0] != LITERAL:
sre_parse.py(467):                         lo = code1[1]
sre_parse.py(468):                         hi = code2[1]
sre_parse.py(469):                         if hi < lo:
sre_parse.py(471):                         setappend((RANGE, (lo, hi)))
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(493):                 min, max = 0, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(537):                 subpattern[-1] = (MIN_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(415):             break # end of pattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(328):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(718):     tail = source.get()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(719):     if tail == ")":
sre_parse.py(721):     elif tail:
sre_parse.py(724):     if flags & SRE_FLAG_DEBUG:
sre_parse.py(727):     if not (flags & SRE_FLAG_VERBOSE) and p.pattern.flags & SRE_FLAG_VERBOSE:
sre_parse.py(732):     return p
sre_compile.py(576):     code = _code(p, flags)
 --- modulename: sre_compile, funcname: _code
sre_compile.py(554):     flags = p.pattern.flags | flags
sre_compile.py(555):     code = []
sre_compile.py(558):     _compile_info(code, p, flags)
 --- modulename: sre_compile, funcname: _compile_info
sre_compile.py(437):     lo, hi = pattern.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_compile.py(438):     if lo == 0:
sre_compile.py(441):     prefix = []
sre_compile.py(442):     prefixappend = prefix.append
sre_compile.py(443):     prefix_skip = 0
sre_compile.py(444):     charset = [] # not used
sre_compile.py(445):     charsetappend = charset.append
sre_compile.py(446):     if not (flags & SRE_FLAG_IGNORECASE):
sre_compile.py(448):         for op, av in pattern.data:
sre_compile.py(449):             if op is LITERAL:
sre_compile.py(450):                 if len(prefix) == prefix_skip:
sre_compile.py(451):                     prefix_skip = prefix_skip + 1
sre_compile.py(452):                 prefixappend(av)
sre_compile.py(448):         for op, av in pattern.data:
sre_compile.py(449):             if op is LITERAL:
sre_compile.py(453):             elif op is SUBPATTERN and len(av[1]) == 1:
sre_compile.py(460):                 break
sre_compile.py(462):         if not prefix and pattern.data:
sre_compile.py(501):     emit = code.append
sre_compile.py(502):     emit(OPCODES[INFO])
sre_compile.py(503):     skip = len(code); emit(0)
sre_compile.py(505):     mask = 0
sre_compile.py(506):     if prefix:
sre_compile.py(507):         mask = SRE_INFO_PREFIX
sre_compile.py(508):         if len(prefix) == prefix_skip == len(pattern.data):
sre_compile.py(512):     emit(mask)
sre_compile.py(514):     if lo < MAXCODE:
sre_compile.py(515):         emit(lo)
sre_compile.py(519):     if hi < MAXCODE:
sre_compile.py(522):         emit(0)
sre_compile.py(524):     if prefix:
sre_compile.py(525):         emit(len(prefix)) # length
sre_compile.py(526):         emit(prefix_skip) # skip
sre_compile.py(527):         code.extend(prefix)
sre_compile.py(529):         table = [-1] + ([0]*len(prefix))
sre_compile.py(530):         for i in xrange(len(prefix)):
sre_compile.py(531):             table[i+1] = table[i]+1
sre_compile.py(532):             while table[i+1] > 0 and prefix[i] != prefix[table[i+1]-1]:
sre_compile.py(530):         for i in xrange(len(prefix)):
sre_compile.py(534):         code.extend(table[1:]) # don't store first entry
sre_compile.py(537):     code[skip] = len(code) - skip
sre_compile.py(561):     _compile(code, p.data, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
sre_compile.py(136):                 emit(OPCODES[REPEAT])
sre_compile.py(137):                 skip = _len(code); emit(0)
sre_compile.py(138):                 emit(av[0])
sre_compile.py(139):                 emit(av[1])
sre_compile.py(140):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(128):                     emit(OPCODES[MIN_REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(110):             if flags & SRE_FLAG_DOTALL:
sre_compile.py(113):                 emit(OPCODES[ANY])
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(141):                 code[skip] = _len(code) - skip
sre_compile.py(142):                 if op is MAX_REPEAT:
sre_compile.py(143):                     emit(OPCODES[MAX_UNTIL])
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(128):                     emit(OPCODES[MIN_REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(274):                     r = range(av[0], av[1]+1)
sre_compile.py(275):                     if fixup:
sre_compile.py(277):                     if fixup and fixes:
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(320):             runs = None
sre_compile.py(321):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(342):     if len(charmap) == 256:
sre_compile.py(343):         data = _mk_bitmap(charmap)
 --- modulename: sre_compile, funcname: _mk_bitmap
sre_compile.py(412):     s = bytes(bits).translate(_BITS_TRANS)[::-1]
sre_compile.py(413):     return [_int(s[i - _CODEBITS: i], 2)
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(344):         out.append((CHARSET, data))
sre_compile.py(345):         out += tail
sre_compile.py(346):         return out
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(242):             code.extend(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(320):             runs = None
sre_compile.py(321):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(342):     if len(charmap) == 256:
sre_compile.py(343):         data = _mk_bitmap(charmap)
 --- modulename: sre_compile, funcname: _mk_bitmap
sre_compile.py(412):     s = bytes(bits).translate(_BITS_TRANS)[::-1]
sre_compile.py(413):     return [_int(s[i - _CODEBITS: i], 2)
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(344):         out.append((CHARSET, data))
sre_compile.py(345):         out += tail
sre_compile.py(346):         return out
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(242):             code.extend(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(563):     code.append(OPCODES[SUCCESS])
sre_compile.py(565):     return code
sre_compile.py(581):     if p.pattern.groups > 100:
sre_compile.py(587):     groupindex = p.pattern.groupdict
sre_compile.py(588):     indexgroup = [None] * p.pattern.groups
sre_compile.py(589):     for k, i in groupindex.items():
sre_compile.py(590):         indexgroup[i] = k
sre_compile.py(589):     for k, i in groupindex.items():
sre_compile.py(590):         indexgroup[i] = k
sre_compile.py(589):     for k, i in groupindex.items():
sre_compile.py(592):     return _sre.compile(
sre_compile.py(593):         pattern, flags | p.pattern.flags, code,
sre_compile.py(594):         p.pattern.groups-1,
sre_compile.py(595):         groupindex, indexgroup
re.py(252):     if not bypass_cache:
re.py(253):         if len(_cache) >= _MAXCACHE:
re.py(255):         if p.flags & LOCALE:
re.py(260):             loc = None
re.py(261):         _cache[cachekey] = p, loc
re.py(262):     return p
locale.py(185): def format(percent, value, grouping=False, monetary=False, *additional):
locale.py(198): def _format(percent, value, grouping=False, monetary=False, *additional):
locale.py(222): def format_string(f, val, grouping=False):
locale.py(256): def currency(val, symbol=True, grouping=False, international=False):
locale.py(301): def str(val):
locale.py(305): def atof(string, func=float):
locale.py(318): def atoi(str):
locale.py(322): def _test():
locale.py(338): _setlocale = setlocale
locale.py(342): _ascii_lower_map = ''.join(
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(344):     for x in range(256)
 --- modulename: locale, funcname: <genexpr>
locale.py(343):     chr(x + 32 if x >= ord('A') and x <= ord('Z') else x)
locale.py(347): def _replace_encoding(code, encoding):
locale.py(363): def normalize(localename):
locale.py(447): def _parse_localename(localename):
locale.py(477): def _build_localename(localetuple):
locale.py(493): def getdefaultlocale(envvars=('LC_ALL', 'LC_CTYPE', 'LANG', 'LANGUAGE')):
locale.py(546): def getlocale(category=LC_CTYPE):
locale.py(564): def setlocale(category, locale=None):
locale.py(581): def resetlocale(category=LC_ALL):
locale.py(591): if sys.platform.startswith("win"):
locale.py(599):     try:
locale.py(600):         CODESET
locale.py(608):         def getpreferredencoding(do_setlocale = True):
locale.py(639): locale_encoding_alias = {
locale.py(642):     '437':                          'C',
locale.py(643):     'c':                            'C',
locale.py(644):     'en':                           'ISO8859-1',
locale.py(645):     'jis':                          'JIS7',
locale.py(646):     'jis7':                         'JIS7',
locale.py(647):     'ajec':                         'eucJP',
locale.py(650):     'ascii':                        'ISO8859-1',
locale.py(651):     'latin_1':                      'ISO8859-1',
locale.py(652):     'iso8859_1':                    'ISO8859-1',
locale.py(653):     'iso8859_10':                   'ISO8859-10',
locale.py(654):     'iso8859_11':                   'ISO8859-11',
locale.py(655):     'iso8859_13':                   'ISO8859-13',
locale.py(656):     'iso8859_14':                   'ISO8859-14',
locale.py(657):     'iso8859_15':                   'ISO8859-15',
locale.py(658):     'iso8859_16':                   'ISO8859-16',
locale.py(659):     'iso8859_2':                    'ISO8859-2',
locale.py(660):     'iso8859_3':                    'ISO8859-3',
locale.py(661):     'iso8859_4':                    'ISO8859-4',
locale.py(662):     'iso8859_5':                    'ISO8859-5',
locale.py(663):     'iso8859_6':                    'ISO8859-6',
locale.py(664):     'iso8859_7':                    'ISO8859-7',
locale.py(665):     'iso8859_8':                    'ISO8859-8',
locale.py(666):     'iso8859_9':                    'ISO8859-9',
locale.py(667):     'iso2022_jp':                   'JIS7',
locale.py(668):     'shift_jis':                    'SJIS',
locale.py(669):     'tactis':                       'TACTIS',
locale.py(670):     'euc_jp':                       'eucJP',
locale.py(671):     'euc_kr':                       'eucKR',
locale.py(672):     'utf_8':                        'UTF-8',
locale.py(673):     'koi8_r':                       'KOI8-R',
locale.py(674):     'koi8_u':                       'KOI8-U',
locale.py(791): locale_alias = {
locale.py(792):     'a3':                                   'az_AZ.KOI8-C',
locale.py(793):     'a3_az':                                'az_AZ.KOI8-C',
locale.py(794):     'a3_az.koi8c':                          'az_AZ.KOI8-C',
locale.py(795):     'a3_az.koic':                           'az_AZ.KOI8-C',
locale.py(796):     'aa_dj':                                'aa_DJ.ISO8859-1',
locale.py(797):     'aa_er':                                'aa_ER.UTF-8',
locale.py(798):     'aa_et':                                'aa_ET.UTF-8',
locale.py(799):     'af':                                   'af_ZA.ISO8859-1',
locale.py(800):     'af_za':                                'af_ZA.ISO8859-1',
locale.py(801):     'af_za.iso88591':                       'af_ZA.ISO8859-1',
locale.py(802):     'am':                                   'am_ET.UTF-8',
locale.py(803):     'am_et':                                'am_ET.UTF-8',
locale.py(804):     'american':                             'en_US.ISO8859-1',
locale.py(805):     'american.iso88591':                    'en_US.ISO8859-1',
locale.py(806):     'an_es':                                'an_ES.ISO8859-15',
locale.py(807):     'ar':                                   'ar_AA.ISO8859-6',
locale.py(808):     'ar_aa':                                'ar_AA.ISO8859-6',
locale.py(809):     'ar_aa.iso88596':                       'ar_AA.ISO8859-6',
locale.py(810):     'ar_ae':                                'ar_AE.ISO8859-6',
locale.py(811):     'ar_ae.iso88596':                       'ar_AE.ISO8859-6',
locale.py(812):     'ar_bh':                                'ar_BH.ISO8859-6',
locale.py(813):     'ar_bh.iso88596':                       'ar_BH.ISO8859-6',
locale.py(814):     'ar_dz':                                'ar_DZ.ISO8859-6',
locale.py(815):     'ar_dz.iso88596':                       'ar_DZ.ISO8859-6',
locale.py(816):     'ar_eg':                                'ar_EG.ISO8859-6',
locale.py(817):     'ar_eg.iso88596':                       'ar_EG.ISO8859-6',
locale.py(818):     'ar_in':                                'ar_IN.UTF-8',
locale.py(819):     'ar_iq':                                'ar_IQ.ISO8859-6',
locale.py(820):     'ar_iq.iso88596':                       'ar_IQ.ISO8859-6',
locale.py(821):     'ar_jo':                                'ar_JO.ISO8859-6',
locale.py(822):     'ar_jo.iso88596':                       'ar_JO.ISO8859-6',
locale.py(823):     'ar_kw':                                'ar_KW.ISO8859-6',
locale.py(824):     'ar_kw.iso88596':                       'ar_KW.ISO8859-6',
locale.py(825):     'ar_lb':                                'ar_LB.ISO8859-6',
locale.py(826):     'ar_lb.iso88596':                       'ar_LB.ISO8859-6',
locale.py(827):     'ar_ly':                                'ar_LY.ISO8859-6',
locale.py(828):     'ar_ly.iso88596':                       'ar_LY.ISO8859-6',
locale.py(829):     'ar_ma':                                'ar_MA.ISO8859-6',
locale.py(830):     'ar_ma.iso88596':                       'ar_MA.ISO8859-6',
locale.py(831):     'ar_om':                                'ar_OM.ISO8859-6',
locale.py(832):     'ar_om.iso88596':                       'ar_OM.ISO8859-6',
locale.py(833):     'ar_qa':                                'ar_QA.ISO8859-6',
locale.py(834):     'ar_qa.iso88596':                       'ar_QA.ISO8859-6',
locale.py(835):     'ar_sa':                                'ar_SA.ISO8859-6',
locale.py(836):     'ar_sa.iso88596':                       'ar_SA.ISO8859-6',
locale.py(837):     'ar_sd':                                'ar_SD.ISO8859-6',
locale.py(838):     'ar_sd.iso88596':                       'ar_SD.ISO8859-6',
locale.py(839):     'ar_sy':                                'ar_SY.ISO8859-6',
locale.py(840):     'ar_sy.iso88596':                       'ar_SY.ISO8859-6',
locale.py(841):     'ar_tn':                                'ar_TN.ISO8859-6',
locale.py(842):     'ar_tn.iso88596':                       'ar_TN.ISO8859-6',
locale.py(843):     'ar_ye':                                'ar_YE.ISO8859-6',
locale.py(844):     'ar_ye.iso88596':                       'ar_YE.ISO8859-6',
locale.py(845):     'arabic':                               'ar_AA.ISO8859-6',
locale.py(846):     'arabic.iso88596':                      'ar_AA.ISO8859-6',
locale.py(847):     'as':                                   'as_IN.UTF-8',
locale.py(848):     'as_in':                                'as_IN.UTF-8',
locale.py(849):     'ast_es':                               'ast_ES.ISO8859-15',
locale.py(850):     'ayc_pe':                               'ayc_PE.UTF-8',
locale.py(851):     'az':                                   'az_AZ.ISO8859-9E',
locale.py(852):     'az_az':                                'az_AZ.ISO8859-9E',
locale.py(853):     'az_az.iso88599e':                      'az_AZ.ISO8859-9E',
locale.py(854):     'be':                                   'be_BY.CP1251',
locale.py(855):     'be@latin':                             'be_BY.UTF-8@latin',
locale.py(856):     'be_bg.utf8':                           'bg_BG.UTF-8',
locale.py(857):     'be_by':                                'be_BY.CP1251',
locale.py(858):     'be_by.cp1251':                         'be_BY.CP1251',
locale.py(859):     'be_by.microsoftcp1251':                'be_BY.CP1251',
locale.py(860):     'be_by.utf8@latin':                     'be_BY.UTF-8@latin',
locale.py(861):     'be_by@latin':                          'be_BY.UTF-8@latin',
locale.py(862):     'bem_zm':                               'bem_ZM.UTF-8',
locale.py(863):     'ber_dz':                               'ber_DZ.UTF-8',
locale.py(864):     'ber_ma':                               'ber_MA.UTF-8',
locale.py(865):     'bg':                                   'bg_BG.CP1251',
locale.py(866):     'bg_bg':                                'bg_BG.CP1251',
locale.py(867):     'bg_bg.cp1251':                         'bg_BG.CP1251',
locale.py(868):     'bg_bg.iso88595':                       'bg_BG.ISO8859-5',
locale.py(869):     'bg_bg.koi8r':                          'bg_BG.KOI8-R',
locale.py(870):     'bg_bg.microsoftcp1251':                'bg_BG.CP1251',
locale.py(871):     'bho_in':                               'bho_IN.UTF-8',
locale.py(872):     'bn_bd':                                'bn_BD.UTF-8',
locale.py(873):     'bn_in':                                'bn_IN.UTF-8',
locale.py(874):     'bo_cn':                                'bo_CN.UTF-8',
locale.py(875):     'bo_in':                                'bo_IN.UTF-8',
locale.py(876):     'bokmal':                               'nb_NO.ISO8859-1',
locale.py(877):     'bokm\xe5l':                            'nb_NO.ISO8859-1',
locale.py(878):     'br':                                   'br_FR.ISO8859-1',
locale.py(879):     'br_fr':                                'br_FR.ISO8859-1',
locale.py(880):     'br_fr.iso88591':                       'br_FR.ISO8859-1',
locale.py(881):     'br_fr.iso885914':                      'br_FR.ISO8859-14',
locale.py(882):     'br_fr.iso885915':                      'br_FR.ISO8859-15',
locale.py(883):     'br_fr.iso885915@euro':                 'br_FR.ISO8859-15',
locale.py(884):     'br_fr.utf8@euro':                      'br_FR.UTF-8',
locale.py(885):     'br_fr@euro':                           'br_FR.ISO8859-15',
locale.py(886):     'brx_in':                               'brx_IN.UTF-8',
locale.py(887):     'bs':                                   'bs_BA.ISO8859-2',
locale.py(888):     'bs_ba':                                'bs_BA.ISO8859-2',
locale.py(889):     'bs_ba.iso88592':                       'bs_BA.ISO8859-2',
locale.py(890):     'bulgarian':                            'bg_BG.CP1251',
locale.py(891):     'byn_er':                               'byn_ER.UTF-8',
locale.py(892):     'c':                                    'C',
locale.py(893):     'c-french':                             'fr_CA.ISO8859-1',
locale.py(894):     'c-french.iso88591':                    'fr_CA.ISO8859-1',
locale.py(895):     'c.ascii':                              'C',
locale.py(896):     'c.en':                                 'C',
locale.py(897):     'c.iso88591':                           'en_US.ISO8859-1',
locale.py(898):     'c.utf8':                               'en_US.UTF-8',
locale.py(899):     'c_c':                                  'C',
locale.py(900):     'c_c.c':                                'C',
locale.py(901):     'ca':                                   'ca_ES.ISO8859-1',
locale.py(902):     'ca_ad':                                'ca_AD.ISO8859-1',
locale.py(903):     'ca_ad.iso88591':                       'ca_AD.ISO8859-1',
locale.py(904):     'ca_ad.iso885915':                      'ca_AD.ISO8859-15',
locale.py(905):     'ca_ad.iso885915@euro':                 'ca_AD.ISO8859-15',
locale.py(906):     'ca_ad.utf8@euro':                      'ca_AD.UTF-8',
locale.py(907):     'ca_ad@euro':                           'ca_AD.ISO8859-15',
locale.py(908):     'ca_es':                                'ca_ES.ISO8859-1',
locale.py(909):     'ca_es.iso88591':                       'ca_ES.ISO8859-1',
locale.py(910):     'ca_es.iso885915':                      'ca_ES.ISO8859-15',
locale.py(911):     'ca_es.iso885915@euro':                 'ca_ES.ISO8859-15',
locale.py(912):     'ca_es.utf8@euro':                      'ca_ES.UTF-8',
locale.py(913):     'ca_es@valencia':                       'ca_ES.ISO8859-15@valencia',
locale.py(914):     'ca_es@euro':                           'ca_ES.ISO8859-15',
locale.py(915):     'ca_fr':                                'ca_FR.ISO8859-1',
locale.py(916):     'ca_fr.iso88591':                       'ca_FR.ISO8859-1',
locale.py(917):     'ca_fr.iso885915':                      'ca_FR.ISO8859-15',
locale.py(918):     'ca_fr.iso885915@euro':                 'ca_FR.ISO8859-15',
locale.py(919):     'ca_fr.utf8@euro':                      'ca_FR.UTF-8',
locale.py(920):     'ca_fr@euro':                           'ca_FR.ISO8859-15',
locale.py(921):     'ca_it':                                'ca_IT.ISO8859-1',
locale.py(922):     'ca_it.iso88591':                       'ca_IT.ISO8859-1',
locale.py(923):     'ca_it.iso885915':                      'ca_IT.ISO8859-15',
locale.py(924):     'ca_it.iso885915@euro':                 'ca_IT.ISO8859-15',
locale.py(925):     'ca_it.utf8@euro':                      'ca_IT.UTF-8',
locale.py(926):     'ca_it@euro':                           'ca_IT.ISO8859-15',
locale.py(927):     'catalan':                              'ca_ES.ISO8859-1',
locale.py(928):     'cextend':                              'en_US.ISO8859-1',
locale.py(929):     'cextend.en':                           'en_US.ISO8859-1',
locale.py(930):     'chinese-s':                            'zh_CN.eucCN',
locale.py(931):     'chinese-t':                            'zh_TW.eucTW',
locale.py(932):     'crh_ua':                               'crh_UA.UTF-8',
locale.py(933):     'croatian':                             'hr_HR.ISO8859-2',
locale.py(934):     'cs':                                   'cs_CZ.ISO8859-2',
locale.py(935):     'cs_cs':                                'cs_CZ.ISO8859-2',
locale.py(936):     'cs_cs.iso88592':                       'cs_CZ.ISO8859-2',
locale.py(937):     'cs_cz':                                'cs_CZ.ISO8859-2',
locale.py(938):     'cs_cz.iso88592':                       'cs_CZ.ISO8859-2',
locale.py(939):     'csb_pl':                               'csb_PL.UTF-8',
locale.py(940):     'cv_ru':                                'cv_RU.UTF-8',
locale.py(941):     'cy':                                   'cy_GB.ISO8859-1',
locale.py(942):     'cy_gb':                                'cy_GB.ISO8859-1',
locale.py(943):     'cy_gb.iso88591':                       'cy_GB.ISO8859-1',
locale.py(944):     'cy_gb.iso885914':                      'cy_GB.ISO8859-14',
locale.py(945):     'cy_gb.iso885915':                      'cy_GB.ISO8859-15',
locale.py(946):     'cy_gb@euro':                           'cy_GB.ISO8859-15',
locale.py(947):     'cz':                                   'cs_CZ.ISO8859-2',
locale.py(948):     'cz_cz':                                'cs_CZ.ISO8859-2',
locale.py(949):     'czech':                                'cs_CZ.ISO8859-2',
locale.py(950):     'da':                                   'da_DK.ISO8859-1',
locale.py(951):     'da.iso885915':                         'da_DK.ISO8859-15',
locale.py(952):     'da_dk':                                'da_DK.ISO8859-1',
locale.py(953):     'da_dk.88591':                          'da_DK.ISO8859-1',
locale.py(954):     'da_dk.885915':                         'da_DK.ISO8859-15',
locale.py(955):     'da_dk.iso88591':                       'da_DK.ISO8859-1',
locale.py(956):     'da_dk.iso885915':                      'da_DK.ISO8859-15',
locale.py(957):     'da_dk@euro':                           'da_DK.ISO8859-15',
locale.py(958):     'danish':                               'da_DK.ISO8859-1',
locale.py(959):     'danish.iso88591':                      'da_DK.ISO8859-1',
locale.py(960):     'dansk':                                'da_DK.ISO8859-1',
locale.py(961):     'de':                                   'de_DE.ISO8859-1',
locale.py(962):     'de.iso885915':                         'de_DE.ISO8859-15',
locale.py(963):     'de_at':                                'de_AT.ISO8859-1',
locale.py(964):     'de_at.iso88591':                       'de_AT.ISO8859-1',
locale.py(965):     'de_at.iso885915':                      'de_AT.ISO8859-15',
locale.py(966):     'de_at.iso885915@euro':                 'de_AT.ISO8859-15',
locale.py(967):     'de_at.utf8@euro':                      'de_AT.UTF-8',
locale.py(968):     'de_at@euro':                           'de_AT.ISO8859-15',
locale.py(969):     'de_be':                                'de_BE.ISO8859-1',
locale.py(970):     'de_be.iso88591':                       'de_BE.ISO8859-1',
locale.py(971):     'de_be.iso885915':                      'de_BE.ISO8859-15',
locale.py(972):     'de_be.iso885915@euro':                 'de_BE.ISO8859-15',
locale.py(973):     'de_be.utf8@euro':                      'de_BE.UTF-8',
locale.py(974):     'de_be@euro':                           'de_BE.ISO8859-15',
locale.py(975):     'de_ch':                                'de_CH.ISO8859-1',
locale.py(976):     'de_ch.iso88591':                       'de_CH.ISO8859-1',
locale.py(977):     'de_ch.iso885915':                      'de_CH.ISO8859-15',
locale.py(978):     'de_ch@euro':                           'de_CH.ISO8859-15',
locale.py(979):     'de_de':                                'de_DE.ISO8859-1',
locale.py(980):     'de_de.88591':                          'de_DE.ISO8859-1',
locale.py(981):     'de_de.885915':                         'de_DE.ISO8859-15',
locale.py(982):     'de_de.885915@euro':                    'de_DE.ISO8859-15',
locale.py(983):     'de_de.iso88591':                       'de_DE.ISO8859-1',
locale.py(984):     'de_de.iso885915':                      'de_DE.ISO8859-15',
locale.py(985):     'de_de.iso885915@euro':                 'de_DE.ISO8859-15',
locale.py(986):     'de_de.utf8@euro':                      'de_DE.UTF-8',
locale.py(987):     'de_de@euro':                           'de_DE.ISO8859-15',
locale.py(988):     'de_li.utf8':                           'de_LI.UTF-8',
locale.py(989):     'de_lu':                                'de_LU.ISO8859-1',
locale.py(990):     'de_lu.iso88591':                       'de_LU.ISO8859-1',
locale.py(991):     'de_lu.iso885915':                      'de_LU.ISO8859-15',
locale.py(992):     'de_lu.iso885915@euro':                 'de_LU.ISO8859-15',
locale.py(993):     'de_lu.utf8@euro':                      'de_LU.UTF-8',
locale.py(994):     'de_lu@euro':                           'de_LU.ISO8859-15',
locale.py(995):     'deutsch':                              'de_DE.ISO8859-1',
locale.py(996):     'doi_in':                               'doi_IN.UTF-8',
locale.py(997):     'dutch':                                'nl_NL.ISO8859-1',
locale.py(998):     'dutch.iso88591':                       'nl_BE.ISO8859-1',
locale.py(999):     'dv_mv':                                'dv_MV.UTF-8',
locale.py(1000):     'dz_bt':                                'dz_BT.UTF-8',
locale.py(1001):     'ee':                                   'ee_EE.ISO8859-4',
locale.py(1002):     'ee_ee':                                'ee_EE.ISO8859-4',
locale.py(1003):     'ee_ee.iso88594':                       'ee_EE.ISO8859-4',
locale.py(1004):     'eesti':                                'et_EE.ISO8859-1',
locale.py(1005):     'el':                                   'el_GR.ISO8859-7',
locale.py(1006):     'el_cy':                                'el_CY.ISO8859-7',
locale.py(1007):     'el_gr':                                'el_GR.ISO8859-7',
locale.py(1008):     'el_gr.iso88597':                       'el_GR.ISO8859-7',
locale.py(1009):     'el_gr@euro':                           'el_GR.ISO8859-15',
locale.py(1010):     'en':                                   'en_US.ISO8859-1',
locale.py(1011):     'en.iso88591':                          'en_US.ISO8859-1',
locale.py(1012):     'en_ag':                                'en_AG.UTF-8',
locale.py(1013):     'en_au':                                'en_AU.ISO8859-1',
locale.py(1014):     'en_au.iso88591':                       'en_AU.ISO8859-1',
locale.py(1015):     'en_be':                                'en_BE.ISO8859-1',
locale.py(1016):     'en_be@euro':                           'en_BE.ISO8859-15',
locale.py(1017):     'en_bw':                                'en_BW.ISO8859-1',
locale.py(1018):     'en_bw.iso88591':                       'en_BW.ISO8859-1',
locale.py(1019):     'en_ca':                                'en_CA.ISO8859-1',
locale.py(1020):     'en_ca.iso88591':                       'en_CA.ISO8859-1',
locale.py(1021):     'en_dk':                                'en_DK.ISO8859-1',
locale.py(1022):     'en_dl.utf8':                           'en_DL.UTF-8',
locale.py(1023):     'en_gb':                                'en_GB.ISO8859-1',
locale.py(1024):     'en_gb.88591':                          'en_GB.ISO8859-1',
locale.py(1025):     'en_gb.iso88591':                       'en_GB.ISO8859-1',
locale.py(1026):     'en_gb.iso885915':                      'en_GB.ISO8859-15',
locale.py(1027):     'en_gb@euro':                           'en_GB.ISO8859-15',
locale.py(1028):     'en_hk':                                'en_HK.ISO8859-1',
locale.py(1029):     'en_hk.iso88591':                       'en_HK.ISO8859-1',
locale.py(1030):     'en_ie':                                'en_IE.ISO8859-1',
locale.py(1031):     'en_ie.iso88591':                       'en_IE.ISO8859-1',
locale.py(1032):     'en_ie.iso885915':                      'en_IE.ISO8859-15',
locale.py(1033):     'en_ie.iso885915@euro':                 'en_IE.ISO8859-15',
locale.py(1034):     'en_ie.utf8@euro':                      'en_IE.UTF-8',
locale.py(1035):     'en_ie@euro':                           'en_IE.ISO8859-15',
locale.py(1036):     'en_in':                                'en_IN.ISO8859-1',
locale.py(1037):     'en_ng':                                'en_NG.UTF-8',
locale.py(1038):     'en_nz':                                'en_NZ.ISO8859-1',
locale.py(1039):     'en_nz.iso88591':                       'en_NZ.ISO8859-1',
locale.py(1040):     'en_ph':                                'en_PH.ISO8859-1',
locale.py(1041):     'en_ph.iso88591':                       'en_PH.ISO8859-1',
locale.py(1042):     'en_sg':                                'en_SG.ISO8859-1',
locale.py(1043):     'en_sg.iso88591':                       'en_SG.ISO8859-1',
locale.py(1044):     'en_uk':                                'en_GB.ISO8859-1',
locale.py(1045):     'en_us':                                'en_US.ISO8859-1',
locale.py(1046):     'en_us.88591':                          'en_US.ISO8859-1',
locale.py(1047):     'en_us.885915':                         'en_US.ISO8859-15',
locale.py(1048):     'en_us.iso88591':                       'en_US.ISO8859-1',
locale.py(1049):     'en_us.iso885915':                      'en_US.ISO8859-15',
locale.py(1050):     'en_us.iso885915@euro':                 'en_US.ISO8859-15',
locale.py(1051):     'en_us@euro':                           'en_US.ISO8859-15',
locale.py(1052):     'en_us@euro@euro':                      'en_US.ISO8859-15',
locale.py(1053):     'en_za':                                'en_ZA.ISO8859-1',
locale.py(1054):     'en_za.88591':                          'en_ZA.ISO8859-1',
locale.py(1055):     'en_za.iso88591':                       'en_ZA.ISO8859-1',
locale.py(1056):     'en_za.iso885915':                      'en_ZA.ISO8859-15',
locale.py(1057):     'en_za@euro':                           'en_ZA.ISO8859-15',
locale.py(1058):     'en_zm':                                'en_ZM.UTF-8',
locale.py(1059):     'en_zw':                                'en_ZW.ISO8859-1',
locale.py(1060):     'en_zw.iso88591':                       'en_ZW.ISO8859-1',
locale.py(1061):     'en_zw.utf8':                           'en_ZS.UTF-8',
locale.py(1062):     'eng_gb':                               'en_GB.ISO8859-1',
locale.py(1063):     'eng_gb.8859':                          'en_GB.ISO8859-1',
locale.py(1064):     'english':                              'en_EN.ISO8859-1',
locale.py(1065):     'english.iso88591':                     'en_EN.ISO8859-1',
locale.py(1066):     'english_uk':                           'en_GB.ISO8859-1',
locale.py(1067):     'english_uk.8859':                      'en_GB.ISO8859-1',
locale.py(1068):     'english_united-states':                'en_US.ISO8859-1',
locale.py(1069):     'english_united-states.437':            'C',
locale.py(1070):     'english_us':                           'en_US.ISO8859-1',
locale.py(1071):     'english_us.8859':                      'en_US.ISO8859-1',
locale.py(1072):     'english_us.ascii':                     'en_US.ISO8859-1',
locale.py(1073):     'eo':                                   'eo_XX.ISO8859-3',
locale.py(1074):     'eo.utf8':                              'eo.UTF-8',
locale.py(1075):     'eo_eo':                                'eo_EO.ISO8859-3',
locale.py(1076):     'eo_eo.iso88593':                       'eo_EO.ISO8859-3',
locale.py(1077):     'eo_us.utf8':                           'eo_US.UTF-8',
locale.py(1078):     'eo_xx':                                'eo_XX.ISO8859-3',
locale.py(1079):     'eo_xx.iso88593':                       'eo_XX.ISO8859-3',
locale.py(1080):     'es':                                   'es_ES.ISO8859-1',
locale.py(1081):     'es_ar':                                'es_AR.ISO8859-1',
locale.py(1082):     'es_ar.iso88591':                       'es_AR.ISO8859-1',
locale.py(1083):     'es_bo':                                'es_BO.ISO8859-1',
locale.py(1084):     'es_bo.iso88591':                       'es_BO.ISO8859-1',
locale.py(1085):     'es_cl':                                'es_CL.ISO8859-1',
locale.py(1086):     'es_cl.iso88591':                       'es_CL.ISO8859-1',
locale.py(1087):     'es_co':                                'es_CO.ISO8859-1',
locale.py(1088):     'es_co.iso88591':                       'es_CO.ISO8859-1',
locale.py(1089):     'es_cr':                                'es_CR.ISO8859-1',
locale.py(1090):     'es_cr.iso88591':                       'es_CR.ISO8859-1',
locale.py(1091):     'es_cu':                                'es_CU.UTF-8',
locale.py(1092):     'es_do':                                'es_DO.ISO8859-1',
locale.py(1093):     'es_do.iso88591':                       'es_DO.ISO8859-1',
locale.py(1094):     'es_ec':                                'es_EC.ISO8859-1',
locale.py(1095):     'es_ec.iso88591':                       'es_EC.ISO8859-1',
locale.py(1096):     'es_es':                                'es_ES.ISO8859-1',
locale.py(1097):     'es_es.88591':                          'es_ES.ISO8859-1',
locale.py(1098):     'es_es.iso88591':                       'es_ES.ISO8859-1',
locale.py(1099):     'es_es.iso885915':                      'es_ES.ISO8859-15',
locale.py(1100):     'es_es.iso885915@euro':                 'es_ES.ISO8859-15',
locale.py(1101):     'es_es.utf8@euro':                      'es_ES.UTF-8',
locale.py(1102):     'es_es@euro':                           'es_ES.ISO8859-15',
locale.py(1103):     'es_gt':                                'es_GT.ISO8859-1',
locale.py(1104):     'es_gt.iso88591':                       'es_GT.ISO8859-1',
locale.py(1105):     'es_hn':                                'es_HN.ISO8859-1',
locale.py(1106):     'es_hn.iso88591':                       'es_HN.ISO8859-1',
locale.py(1107):     'es_mx':                                'es_MX.ISO8859-1',
locale.py(1108):     'es_mx.iso88591':                       'es_MX.ISO8859-1',
locale.py(1109):     'es_ni':                                'es_NI.ISO8859-1',
locale.py(1110):     'es_ni.iso88591':                       'es_NI.ISO8859-1',
locale.py(1111):     'es_pa':                                'es_PA.ISO8859-1',
locale.py(1112):     'es_pa.iso88591':                       'es_PA.ISO8859-1',
locale.py(1113):     'es_pa.iso885915':                      'es_PA.ISO8859-15',
locale.py(1114):     'es_pa@euro':                           'es_PA.ISO8859-15',
locale.py(1115):     'es_pe':                                'es_PE.ISO8859-1',
locale.py(1116):     'es_pe.iso88591':                       'es_PE.ISO8859-1',
locale.py(1117):     'es_pe.iso885915':                      'es_PE.ISO8859-15',
locale.py(1118):     'es_pe@euro':                           'es_PE.ISO8859-15',
locale.py(1119):     'es_pr':                                'es_PR.ISO8859-1',
locale.py(1120):     'es_pr.iso88591':                       'es_PR.ISO8859-1',
locale.py(1121):     'es_py':                                'es_PY.ISO8859-1',
locale.py(1122):     'es_py.iso88591':                       'es_PY.ISO8859-1',
locale.py(1123):     'es_py.iso885915':                      'es_PY.ISO8859-15',
locale.py(1124):     'es_py@euro':                           'es_PY.ISO8859-15',
locale.py(1125):     'es_sv':                                'es_SV.ISO8859-1',
locale.py(1126):     'es_sv.iso88591':                       'es_SV.ISO8859-1',
locale.py(1127):     'es_sv.iso885915':                      'es_SV.ISO8859-15',
locale.py(1128):     'es_sv@euro':                           'es_SV.ISO8859-15',
locale.py(1129):     'es_us':                                'es_US.ISO8859-1',
locale.py(1130):     'es_us.iso88591':                       'es_US.ISO8859-1',
locale.py(1131):     'es_uy':                                'es_UY.ISO8859-1',
locale.py(1132):     'es_uy.iso88591':                       'es_UY.ISO8859-1',
locale.py(1133):     'es_uy.iso885915':                      'es_UY.ISO8859-15',
locale.py(1134):     'es_uy@euro':                           'es_UY.ISO8859-15',
locale.py(1135):     'es_ve':                                'es_VE.ISO8859-1',
locale.py(1136):     'es_ve.iso88591':                       'es_VE.ISO8859-1',
locale.py(1137):     'es_ve.iso885915':                      'es_VE.ISO8859-15',
locale.py(1138):     'es_ve@euro':                           'es_VE.ISO8859-15',
locale.py(1139):     'estonian':                             'et_EE.ISO8859-1',
locale.py(1140):     'et':                                   'et_EE.ISO8859-15',
locale.py(1141):     'et_ee':                                'et_EE.ISO8859-15',
locale.py(1142):     'et_ee.iso88591':                       'et_EE.ISO8859-1',
locale.py(1143):     'et_ee.iso885913':                      'et_EE.ISO8859-13',
locale.py(1144):     'et_ee.iso885915':                      'et_EE.ISO8859-15',
locale.py(1145):     'et_ee.iso88594':                       'et_EE.ISO8859-4',
locale.py(1146):     'et_ee@euro':                           'et_EE.ISO8859-15',
locale.py(1147):     'eu':                                   'eu_ES.ISO8859-1',
locale.py(1148):     'eu_es':                                'eu_ES.ISO8859-1',
locale.py(1149):     'eu_es.iso88591':                       'eu_ES.ISO8859-1',
locale.py(1150):     'eu_es.iso885915':                      'eu_ES.ISO8859-15',
locale.py(1151):     'eu_es.iso885915@euro':                 'eu_ES.ISO8859-15',
locale.py(1152):     'eu_es.utf8@euro':                      'eu_ES.UTF-8',
locale.py(1153):     'eu_es@euro':                           'eu_ES.ISO8859-15',
locale.py(1154):     'eu_fr':                                'eu_FR.ISO8859-1',
locale.py(1155):     'fa':                                   'fa_IR.UTF-8',
locale.py(1156):     'fa_ir':                                'fa_IR.UTF-8',
locale.py(1157):     'fa_ir.isiri3342':                      'fa_IR.ISIRI-3342',
locale.py(1158):     'ff_sn':                                'ff_SN.UTF-8',
locale.py(1159):     'fi':                                   'fi_FI.ISO8859-15',
locale.py(1160):     'fi.iso885915':                         'fi_FI.ISO8859-15',
locale.py(1161):     'fi_fi':                                'fi_FI.ISO8859-15',
locale.py(1162):     'fi_fi.88591':                          'fi_FI.ISO8859-1',
locale.py(1163):     'fi_fi.iso88591':                       'fi_FI.ISO8859-1',
locale.py(1164):     'fi_fi.iso885915':                      'fi_FI.ISO8859-15',
locale.py(1165):     'fi_fi.iso885915@euro':                 'fi_FI.ISO8859-15',
locale.py(1166):     'fi_fi.utf8@euro':                      'fi_FI.UTF-8',
locale.py(1167):     'fi_fi@euro':                           'fi_FI.ISO8859-15',
locale.py(1168):     'fil_ph':                               'fil_PH.UTF-8',
locale.py(1169):     'finnish':                              'fi_FI.ISO8859-1',
locale.py(1170):     'finnish.iso88591':                     'fi_FI.ISO8859-1',
locale.py(1171):     'fo':                                   'fo_FO.ISO8859-1',
locale.py(1172):     'fo_fo':                                'fo_FO.ISO8859-1',
locale.py(1173):     'fo_fo.iso88591':                       'fo_FO.ISO8859-1',
locale.py(1174):     'fo_fo.iso885915':                      'fo_FO.ISO8859-15',
locale.py(1175):     'fo_fo@euro':                           'fo_FO.ISO8859-15',
locale.py(1176):     'fr':                                   'fr_FR.ISO8859-1',
locale.py(1177):     'fr.iso885915':                         'fr_FR.ISO8859-15',
locale.py(1178):     'fr_be':                                'fr_BE.ISO8859-1',
locale.py(1179):     'fr_be.88591':                          'fr_BE.ISO8859-1',
locale.py(1180):     'fr_be.iso88591':                       'fr_BE.ISO8859-1',
locale.py(1181):     'fr_be.iso885915':                      'fr_BE.ISO8859-15',
locale.py(1182):     'fr_be.iso885915@euro':                 'fr_BE.ISO8859-15',
locale.py(1183):     'fr_be.utf8@euro':                      'fr_BE.UTF-8',
locale.py(1184):     'fr_be@euro':                           'fr_BE.ISO8859-15',
locale.py(1185):     'fr_ca':                                'fr_CA.ISO8859-1',
locale.py(1186):     'fr_ca.88591':                          'fr_CA.ISO8859-1',
locale.py(1187):     'fr_ca.iso88591':                       'fr_CA.ISO8859-1',
locale.py(1188):     'fr_ca.iso885915':                      'fr_CA.ISO8859-15',
locale.py(1189):     'fr_ca@euro':                           'fr_CA.ISO8859-15',
locale.py(1190):     'fr_ch':                                'fr_CH.ISO8859-1',
locale.py(1191):     'fr_ch.88591':                          'fr_CH.ISO8859-1',
locale.py(1192):     'fr_ch.iso88591':                       'fr_CH.ISO8859-1',
locale.py(1193):     'fr_ch.iso885915':                      'fr_CH.ISO8859-15',
locale.py(1194):     'fr_ch@euro':                           'fr_CH.ISO8859-15',
locale.py(1195):     'fr_fr':                                'fr_FR.ISO8859-1',
locale.py(1196):     'fr_fr.88591':                          'fr_FR.ISO8859-1',
locale.py(1197):     'fr_fr.iso88591':                       'fr_FR.ISO8859-1',
locale.py(1198):     'fr_fr.iso885915':                      'fr_FR.ISO8859-15',
locale.py(1199):     'fr_fr.iso885915@euro':                 'fr_FR.ISO8859-15',
locale.py(1200):     'fr_fr.utf8@euro':                      'fr_FR.UTF-8',
locale.py(1201):     'fr_fr@euro':                           'fr_FR.ISO8859-15',
locale.py(1202):     'fr_lu':                                'fr_LU.ISO8859-1',
locale.py(1203):     'fr_lu.88591':                          'fr_LU.ISO8859-1',
locale.py(1204):     'fr_lu.iso88591':                       'fr_LU.ISO8859-1',
locale.py(1205):     'fr_lu.iso885915':                      'fr_LU.ISO8859-15',
locale.py(1206):     'fr_lu.iso885915@euro':                 'fr_LU.ISO8859-15',
locale.py(1207):     'fr_lu.utf8@euro':                      'fr_LU.UTF-8',
locale.py(1208):     'fr_lu@euro':                           'fr_LU.ISO8859-15',
locale.py(1209):     'fran\xe7ais':                          'fr_FR.ISO8859-1',
locale.py(1210):     'fre_fr':                               'fr_FR.ISO8859-1',
locale.py(1211):     'fre_fr.8859':                          'fr_FR.ISO8859-1',
locale.py(1212):     'french':                               'fr_FR.ISO8859-1',
locale.py(1213):     'french.iso88591':                      'fr_CH.ISO8859-1',
locale.py(1214):     'french_france':                        'fr_FR.ISO8859-1',
locale.py(1215):     'french_france.8859':                   'fr_FR.ISO8859-1',
locale.py(1216):     'fur_it':                               'fur_IT.UTF-8',
locale.py(1217):     'fy_de':                                'fy_DE.UTF-8',
locale.py(1218):     'fy_nl':                                'fy_NL.UTF-8',
locale.py(1219):     'ga':                                   'ga_IE.ISO8859-1',
locale.py(1220):     'ga_ie':                                'ga_IE.ISO8859-1',
locale.py(1221):     'ga_ie.iso88591':                       'ga_IE.ISO8859-1',
locale.py(1222):     'ga_ie.iso885914':                      'ga_IE.ISO8859-14',
locale.py(1223):     'ga_ie.iso885915':                      'ga_IE.ISO8859-15',
locale.py(1224):     'ga_ie.iso885915@euro':                 'ga_IE.ISO8859-15',
locale.py(1225):     'ga_ie.utf8@euro':                      'ga_IE.UTF-8',
locale.py(1226):     'ga_ie@euro':                           'ga_IE.ISO8859-15',
locale.py(1227):     'galego':                               'gl_ES.ISO8859-1',
locale.py(1228):     'galician':                             'gl_ES.ISO8859-1',
locale.py(1229):     'gd':                                   'gd_GB.ISO8859-1',
locale.py(1230):     'gd_gb':                                'gd_GB.ISO8859-1',
locale.py(1231):     'gd_gb.iso88591':                       'gd_GB.ISO8859-1',
locale.py(1232):     'gd_gb.iso885914':                      'gd_GB.ISO8859-14',
locale.py(1233):     'gd_gb.iso885915':                      'gd_GB.ISO8859-15',
locale.py(1234):     'gd_gb@euro':                           'gd_GB.ISO8859-15',
locale.py(1235):     'ger_de':                               'de_DE.ISO8859-1',
locale.py(1236):     'ger_de.8859':                          'de_DE.ISO8859-1',
locale.py(1237):     'german':                               'de_DE.ISO8859-1',
locale.py(1238):     'german.iso88591':                      'de_CH.ISO8859-1',
locale.py(1239):     'german_germany':                       'de_DE.ISO8859-1',
locale.py(1240):     'german_germany.8859':                  'de_DE.ISO8859-1',
locale.py(1241):     'gez_er':                               'gez_ER.UTF-8',
locale.py(1242):     'gez_et':                               'gez_ET.UTF-8',
locale.py(1243):     'gl':                                   'gl_ES.ISO8859-1',
locale.py(1244):     'gl_es':                                'gl_ES.ISO8859-1',
locale.py(1245):     'gl_es.iso88591':                       'gl_ES.ISO8859-1',
locale.py(1246):     'gl_es.iso885915':                      'gl_ES.ISO8859-15',
locale.py(1247):     'gl_es.iso885915@euro':                 'gl_ES.ISO8859-15',
locale.py(1248):     'gl_es.utf8@euro':                      'gl_ES.UTF-8',
locale.py(1249):     'gl_es@euro':                           'gl_ES.ISO8859-15',
locale.py(1250):     'greek':                                'el_GR.ISO8859-7',
locale.py(1251):     'greek.iso88597':                       'el_GR.ISO8859-7',
locale.py(1252):     'gu_in':                                'gu_IN.UTF-8',
locale.py(1253):     'gv':                                   'gv_GB.ISO8859-1',
locale.py(1254):     'gv_gb':                                'gv_GB.ISO8859-1',
locale.py(1255):     'gv_gb.iso88591':                       'gv_GB.ISO8859-1',
locale.py(1256):     'gv_gb.iso885914':                      'gv_GB.ISO8859-14',
locale.py(1257):     'gv_gb.iso885915':                      'gv_GB.ISO8859-15',
locale.py(1258):     'gv_gb@euro':                           'gv_GB.ISO8859-15',
locale.py(1259):     'ha_ng':                                'ha_NG.UTF-8',
locale.py(1260):     'he':                                   'he_IL.ISO8859-8',
locale.py(1261):     'he_il':                                'he_IL.ISO8859-8',
locale.py(1262):     'he_il.cp1255':                         'he_IL.CP1255',
locale.py(1263):     'he_il.iso88598':                       'he_IL.ISO8859-8',
locale.py(1264):     'he_il.microsoftcp1255':                'he_IL.CP1255',
locale.py(1265):     'hebrew':                               'he_IL.ISO8859-8',
locale.py(1266):     'hebrew.iso88598':                      'he_IL.ISO8859-8',
locale.py(1267):     'hi':                                   'hi_IN.ISCII-DEV',
locale.py(1268):     'hi_in':                                'hi_IN.ISCII-DEV',
locale.py(1269):     'hi_in.isciidev':                       'hi_IN.ISCII-DEV',
locale.py(1270):     'hne':                                  'hne_IN.UTF-8',
locale.py(1271):     'hne_in':                               'hne_IN.UTF-8',
locale.py(1272):     'hr':                                   'hr_HR.ISO8859-2',
locale.py(1273):     'hr_hr':                                'hr_HR.ISO8859-2',
locale.py(1274):     'hr_hr.iso88592':                       'hr_HR.ISO8859-2',
locale.py(1275):     'hrvatski':                             'hr_HR.ISO8859-2',
locale.py(1276):     'hsb_de':                               'hsb_DE.ISO8859-2',
locale.py(1277):     'ht_ht':                                'ht_HT.UTF-8',
locale.py(1278):     'hu':                                   'hu_HU.ISO8859-2',
locale.py(1279):     'hu_hu':                                'hu_HU.ISO8859-2',
locale.py(1280):     'hu_hu.iso88592':                       'hu_HU.ISO8859-2',
locale.py(1281):     'hungarian':                            'hu_HU.ISO8859-2',
locale.py(1282):     'hy_am':                                'hy_AM.UTF-8',
locale.py(1283):     'hy_am.armscii8':                       'hy_AM.ARMSCII_8',
locale.py(1284):     'ia':                                   'ia.UTF-8',
locale.py(1285):     'ia_fr':                                'ia_FR.UTF-8',
locale.py(1286):     'icelandic':                            'is_IS.ISO8859-1',
locale.py(1287):     'icelandic.iso88591':                   'is_IS.ISO8859-1',
locale.py(1288):     'id':                                   'id_ID.ISO8859-1',
locale.py(1289):     'id_id':                                'id_ID.ISO8859-1',
locale.py(1290):     'ig_ng':                                'ig_NG.UTF-8',
locale.py(1291):     'ik_ca':                                'ik_CA.UTF-8',
locale.py(1292):     'in':                                   'id_ID.ISO8859-1',
locale.py(1293):     'in_id':                                'id_ID.ISO8859-1',
locale.py(1294):     'is':                                   'is_IS.ISO8859-1',
locale.py(1295):     'is_is':                                'is_IS.ISO8859-1',
locale.py(1296):     'is_is.iso88591':                       'is_IS.ISO8859-1',
locale.py(1297):     'is_is.iso885915':                      'is_IS.ISO8859-15',
locale.py(1298):     'is_is@euro':                           'is_IS.ISO8859-15',
locale.py(1299):     'iso-8859-1':                           'en_US.ISO8859-1',
locale.py(1300):     'iso-8859-15':                          'en_US.ISO8859-15',
locale.py(1301):     'iso8859-1':                            'en_US.ISO8859-1',
locale.py(1302):     'iso8859-15':                           'en_US.ISO8859-15',
locale.py(1303):     'iso_8859_1':                           'en_US.ISO8859-1',
locale.py(1304):     'iso_8859_15':                          'en_US.ISO8859-15',
locale.py(1305):     'it':                                   'it_IT.ISO8859-1',
locale.py(1306):     'it.iso885915':                         'it_IT.ISO8859-15',
locale.py(1307):     'it_ch':                                'it_CH.ISO8859-1',
locale.py(1308):     'it_ch.iso88591':                       'it_CH.ISO8859-1',
locale.py(1309):     'it_ch.iso885915':                      'it_CH.ISO8859-15',
locale.py(1310):     'it_ch@euro':                           'it_CH.ISO8859-15',
locale.py(1311):     'it_it':                                'it_IT.ISO8859-1',
locale.py(1312):     'it_it.88591':                          'it_IT.ISO8859-1',
locale.py(1313):     'it_it.iso88591':                       'it_IT.ISO8859-1',
locale.py(1314):     'it_it.iso885915':                      'it_IT.ISO8859-15',
locale.py(1315):     'it_it.iso885915@euro':                 'it_IT.ISO8859-15',
locale.py(1316):     'it_it.utf8@euro':                      'it_IT.UTF-8',
locale.py(1317):     'it_it@euro':                           'it_IT.ISO8859-15',
locale.py(1318):     'italian':                              'it_IT.ISO8859-1',
locale.py(1319):     'italian.iso88591':                     'it_IT.ISO8859-1',
locale.py(1320):     'iu':                                   'iu_CA.NUNACOM-8',
locale.py(1321):     'iu_ca':                                'iu_CA.NUNACOM-8',
locale.py(1322):     'iu_ca.nunacom8':                       'iu_CA.NUNACOM-8',
locale.py(1323):     'iw':                                   'he_IL.ISO8859-8',
locale.py(1324):     'iw_il':                                'he_IL.ISO8859-8',
locale.py(1325):     'iw_il.iso88598':                       'he_IL.ISO8859-8',
locale.py(1326):     'iw_il.utf8':                           'iw_IL.UTF-8',
locale.py(1327):     'ja':                                   'ja_JP.eucJP',
locale.py(1328):     'ja.jis':                               'ja_JP.JIS7',
locale.py(1329):     'ja.sjis':                              'ja_JP.SJIS',
locale.py(1330):     'ja_jp':                                'ja_JP.eucJP',
locale.py(1331):     'ja_jp.ajec':                           'ja_JP.eucJP',
locale.py(1332):     'ja_jp.euc':                            'ja_JP.eucJP',
locale.py(1333):     'ja_jp.eucjp':                          'ja_JP.eucJP',
locale.py(1334):     'ja_jp.iso-2022-jp':                    'ja_JP.JIS7',
locale.py(1335):     'ja_jp.iso2022jp':                      'ja_JP.JIS7',
locale.py(1336):     'ja_jp.jis':                            'ja_JP.JIS7',
locale.py(1337):     'ja_jp.jis7':                           'ja_JP.JIS7',
locale.py(1338):     'ja_jp.mscode':                         'ja_JP.SJIS',
locale.py(1339):     'ja_jp.pck':                            'ja_JP.SJIS',
locale.py(1340):     'ja_jp.sjis':                           'ja_JP.SJIS',
locale.py(1341):     'ja_jp.ujis':                           'ja_JP.eucJP',
locale.py(1342):     'japan':                                'ja_JP.eucJP',
locale.py(1343):     'japanese':                             'ja_JP.eucJP',
locale.py(1344):     'japanese-euc':                         'ja_JP.eucJP',
locale.py(1345):     'japanese.euc':                         'ja_JP.eucJP',
locale.py(1346):     'japanese.sjis':                        'ja_JP.SJIS',
locale.py(1347):     'jp_jp':                                'ja_JP.eucJP',
locale.py(1348):     'ka':                                   'ka_GE.GEORGIAN-ACADEMY',
locale.py(1349):     'ka_ge':                                'ka_GE.GEORGIAN-ACADEMY',
locale.py(1350):     'ka_ge.georgianacademy':                'ka_GE.GEORGIAN-ACADEMY',
locale.py(1351):     'ka_ge.georgianps':                     'ka_GE.GEORGIAN-PS',
locale.py(1352):     'ka_ge.georgianrs':                     'ka_GE.GEORGIAN-ACADEMY',
locale.py(1353):     'kk_kz':                                'kk_KZ.RK1048',
locale.py(1354):     'kl':                                   'kl_GL.ISO8859-1',
locale.py(1355):     'kl_gl':                                'kl_GL.ISO8859-1',
locale.py(1356):     'kl_gl.iso88591':                       'kl_GL.ISO8859-1',
locale.py(1357):     'kl_gl.iso885915':                      'kl_GL.ISO8859-15',
locale.py(1358):     'kl_gl@euro':                           'kl_GL.ISO8859-15',
locale.py(1359):     'km_kh':                                'km_KH.UTF-8',
locale.py(1360):     'kn':                                   'kn_IN.UTF-8',
locale.py(1361):     'kn_in':                                'kn_IN.UTF-8',
locale.py(1362):     'ko':                                   'ko_KR.eucKR',
locale.py(1363):     'ko_kr':                                'ko_KR.eucKR',
locale.py(1364):     'ko_kr.euc':                            'ko_KR.eucKR',
locale.py(1365):     'ko_kr.euckr':                          'ko_KR.eucKR',
locale.py(1366):     'kok_in':                               'kok_IN.UTF-8',
locale.py(1367):     'korean':                               'ko_KR.eucKR',
locale.py(1368):     'korean.euc':                           'ko_KR.eucKR',
locale.py(1369):     'ks':                                   'ks_IN.UTF-8',
locale.py(1370):     'ks_in':                                'ks_IN.UTF-8',
locale.py(1371):     'ks_in@devanagari':                     'ks_IN.UTF-8@devanagari',
locale.py(1372):     'ks_in@devanagari.utf8':                'ks_IN.UTF-8@devanagari',
locale.py(1373):     'ku_tr':                                'ku_TR.ISO8859-9',
locale.py(1374):     'kw':                                   'kw_GB.ISO8859-1',
locale.py(1375):     'kw_gb':                                'kw_GB.ISO8859-1',
locale.py(1376):     'kw_gb.iso88591':                       'kw_GB.ISO8859-1',
locale.py(1377):     'kw_gb.iso885914':                      'kw_GB.ISO8859-14',
locale.py(1378):     'kw_gb.iso885915':                      'kw_GB.ISO8859-15',
locale.py(1379):     'kw_gb@euro':                           'kw_GB.ISO8859-15',
locale.py(1380):     'ky':                                   'ky_KG.UTF-8',
locale.py(1381):     'ky_kg':                                'ky_KG.UTF-8',
locale.py(1382):     'lb_lu':                                'lb_LU.UTF-8',
locale.py(1383):     'lg_ug':                                'lg_UG.ISO8859-10',
locale.py(1384):     'li_be':                                'li_BE.UTF-8',
locale.py(1385):     'li_nl':                                'li_NL.UTF-8',
locale.py(1386):     'lij_it':                               'lij_IT.UTF-8',
locale.py(1387):     'lithuanian':                           'lt_LT.ISO8859-13',
locale.py(1388):     'lo':                                   'lo_LA.MULELAO-1',
locale.py(1389):     'lo_la':                                'lo_LA.MULELAO-1',
locale.py(1390):     'lo_la.cp1133':                         'lo_LA.IBM-CP1133',
locale.py(1391):     'lo_la.ibmcp1133':                      'lo_LA.IBM-CP1133',
locale.py(1392):     'lo_la.mulelao1':                       'lo_LA.MULELAO-1',
locale.py(1393):     'lt':                                   'lt_LT.ISO8859-13',
locale.py(1394):     'lt_lt':                                'lt_LT.ISO8859-13',
locale.py(1395):     'lt_lt.iso885913':                      'lt_LT.ISO8859-13',
locale.py(1396):     'lt_lt.iso88594':                       'lt_LT.ISO8859-4',
locale.py(1397):     'lv':                                   'lv_LV.ISO8859-13',
locale.py(1398):     'lv_lv':                                'lv_LV.ISO8859-13',
locale.py(1399):     'lv_lv.iso885913':                      'lv_LV.ISO8859-13',
locale.py(1400):     'lv_lv.iso88594':                       'lv_LV.ISO8859-4',
locale.py(1401):     'mag_in':                               'mag_IN.UTF-8',
locale.py(1402):     'mai':                                  'mai_IN.UTF-8',
locale.py(1403):     'mai_in':                               'mai_IN.UTF-8',
locale.py(1404):     'mg_mg':                                'mg_MG.ISO8859-15',
locale.py(1405):     'mhr_ru':                               'mhr_RU.UTF-8',
locale.py(1406):     'mi':                                   'mi_NZ.ISO8859-1',
locale.py(1407):     'mi_nz':                                'mi_NZ.ISO8859-1',
locale.py(1408):     'mi_nz.iso88591':                       'mi_NZ.ISO8859-1',
locale.py(1409):     'mk':                                   'mk_MK.ISO8859-5',
locale.py(1410):     'mk_mk':                                'mk_MK.ISO8859-5',
locale.py(1411):     'mk_mk.cp1251':                         'mk_MK.CP1251',
locale.py(1412):     'mk_mk.iso88595':                       'mk_MK.ISO8859-5',
locale.py(1413):     'mk_mk.microsoftcp1251':                'mk_MK.CP1251',
locale.py(1414):     'ml':                                   'ml_IN.UTF-8',
locale.py(1415):     'ml_in':                                'ml_IN.UTF-8',
locale.py(1416):     'mn_mn':                                'mn_MN.UTF-8',
locale.py(1417):     'mni_in':                               'mni_IN.UTF-8',
locale.py(1418):     'mr':                                   'mr_IN.UTF-8',
locale.py(1419):     'mr_in':                                'mr_IN.UTF-8',
locale.py(1420):     'ms':                                   'ms_MY.ISO8859-1',
locale.py(1421):     'ms_my':                                'ms_MY.ISO8859-1',
locale.py(1422):     'ms_my.iso88591':                       'ms_MY.ISO8859-1',
locale.py(1423):     'mt':                                   'mt_MT.ISO8859-3',
locale.py(1424):     'mt_mt':                                'mt_MT.ISO8859-3',
locale.py(1425):     'mt_mt.iso88593':                       'mt_MT.ISO8859-3',
locale.py(1426):     'my_mm':                                'my_MM.UTF-8',
locale.py(1427):     'nan_tw@latin':                         'nan_TW.UTF-8@latin',
locale.py(1428):     'nb':                                   'nb_NO.ISO8859-1',
locale.py(1429):     'nb_no':                                'nb_NO.ISO8859-1',
locale.py(1430):     'nb_no.88591':                          'nb_NO.ISO8859-1',
locale.py(1431):     'nb_no.iso88591':                       'nb_NO.ISO8859-1',
locale.py(1432):     'nb_no.iso885915':                      'nb_NO.ISO8859-15',
locale.py(1433):     'nb_no@euro':                           'nb_NO.ISO8859-15',
locale.py(1434):     'nds_de':                               'nds_DE.UTF-8',
locale.py(1435):     'nds_nl':                               'nds_NL.UTF-8',
locale.py(1436):     'ne_np':                                'ne_NP.UTF-8',
locale.py(1437):     'nhn_mx':                               'nhn_MX.UTF-8',
locale.py(1438):     'niu_nu':                               'niu_NU.UTF-8',
locale.py(1439):     'niu_nz':                               'niu_NZ.UTF-8',
locale.py(1440):     'nl':                                   'nl_NL.ISO8859-1',
locale.py(1441):     'nl.iso885915':                         'nl_NL.ISO8859-15',
locale.py(1442):     'nl_aw':                                'nl_AW.UTF-8',
locale.py(1443):     'nl_be':                                'nl_BE.ISO8859-1',
locale.py(1444):     'nl_be.88591':                          'nl_BE.ISO8859-1',
locale.py(1445):     'nl_be.iso88591':                       'nl_BE.ISO8859-1',
locale.py(1446):     'nl_be.iso885915':                      'nl_BE.ISO8859-15',
locale.py(1447):     'nl_be.iso885915@euro':                 'nl_BE.ISO8859-15',
locale.py(1448):     'nl_be.utf8@euro':                      'nl_BE.UTF-8',
locale.py(1449):     'nl_be@euro':                           'nl_BE.ISO8859-15',
locale.py(1450):     'nl_nl':                                'nl_NL.ISO8859-1',
locale.py(1451):     'nl_nl.88591':                          'nl_NL.ISO8859-1',
locale.py(1452):     'nl_nl.iso88591':                       'nl_NL.ISO8859-1',
locale.py(1453):     'nl_nl.iso885915':                      'nl_NL.ISO8859-15',
locale.py(1454):     'nl_nl.iso885915@euro':                 'nl_NL.ISO8859-15',
locale.py(1455):     'nl_nl.utf8@euro':                      'nl_NL.UTF-8',
locale.py(1456):     'nl_nl@euro':                           'nl_NL.ISO8859-15',
locale.py(1457):     'nn':                                   'nn_NO.ISO8859-1',
locale.py(1458):     'nn_no':                                'nn_NO.ISO8859-1',
locale.py(1459):     'nn_no.88591':                          'nn_NO.ISO8859-1',
locale.py(1460):     'nn_no.iso88591':                       'nn_NO.ISO8859-1',
locale.py(1461):     'nn_no.iso885915':                      'nn_NO.ISO8859-15',
locale.py(1462):     'nn_no@euro':                           'nn_NO.ISO8859-15',
locale.py(1463):     'no':                                   'no_NO.ISO8859-1',
locale.py(1464):     'no@nynorsk':                           'ny_NO.ISO8859-1',
locale.py(1465):     'no_no':                                'no_NO.ISO8859-1',
locale.py(1466):     'no_no.88591':                          'no_NO.ISO8859-1',
locale.py(1467):     'no_no.iso88591':                       'no_NO.ISO8859-1',
locale.py(1468):     'no_no.iso885915':                      'no_NO.ISO8859-15',
locale.py(1469):     'no_no.iso88591@bokmal':                'no_NO.ISO8859-1',
locale.py(1470):     'no_no.iso88591@nynorsk':               'no_NO.ISO8859-1',
locale.py(1471):     'no_no@euro':                           'no_NO.ISO8859-15',
locale.py(1472):     'norwegian':                            'no_NO.ISO8859-1',
locale.py(1473):     'norwegian.iso88591':                   'no_NO.ISO8859-1',
locale.py(1474):     'nr':                                   'nr_ZA.ISO8859-1',
locale.py(1475):     'nr_za':                                'nr_ZA.ISO8859-1',
locale.py(1476):     'nr_za.iso88591':                       'nr_ZA.ISO8859-1',
locale.py(1477):     'nso':                                  'nso_ZA.ISO8859-15',
locale.py(1478):     'nso_za':                               'nso_ZA.ISO8859-15',
locale.py(1479):     'nso_za.iso885915':                     'nso_ZA.ISO8859-15',
locale.py(1480):     'ny':                                   'ny_NO.ISO8859-1',
locale.py(1481):     'ny_no':                                'ny_NO.ISO8859-1',
locale.py(1482):     'ny_no.88591':                          'ny_NO.ISO8859-1',
locale.py(1483):     'ny_no.iso88591':                       'ny_NO.ISO8859-1',
locale.py(1484):     'ny_no.iso885915':                      'ny_NO.ISO8859-15',
locale.py(1485):     'ny_no@euro':                           'ny_NO.ISO8859-15',
locale.py(1486):     'nynorsk':                              'nn_NO.ISO8859-1',
locale.py(1487):     'oc':                                   'oc_FR.ISO8859-1',
locale.py(1488):     'oc_fr':                                'oc_FR.ISO8859-1',
locale.py(1489):     'oc_fr.iso88591':                       'oc_FR.ISO8859-1',
locale.py(1490):     'oc_fr.iso885915':                      'oc_FR.ISO8859-15',
locale.py(1491):     'oc_fr@euro':                           'oc_FR.ISO8859-15',
locale.py(1492):     'om_et':                                'om_ET.UTF-8',
locale.py(1493):     'om_ke':                                'om_KE.ISO8859-1',
locale.py(1494):     'or':                                   'or_IN.UTF-8',
locale.py(1495):     'or_in':                                'or_IN.UTF-8',
locale.py(1496):     'os_ru':                                'os_RU.UTF-8',
locale.py(1497):     'pa':                                   'pa_IN.UTF-8',
locale.py(1498):     'pa_in':                                'pa_IN.UTF-8',
locale.py(1499):     'pa_pk':                                'pa_PK.UTF-8',
locale.py(1500):     'pap_an':                               'pap_AN.UTF-8',
locale.py(1501):     'pd':                                   'pd_US.ISO8859-1',
locale.py(1502):     'pd_de':                                'pd_DE.ISO8859-1',
locale.py(1503):     'pd_de.iso88591':                       'pd_DE.ISO8859-1',
locale.py(1504):     'pd_de.iso885915':                      'pd_DE.ISO8859-15',
locale.py(1505):     'pd_de@euro':                           'pd_DE.ISO8859-15',
locale.py(1506):     'pd_us':                                'pd_US.ISO8859-1',
locale.py(1507):     'pd_us.iso88591':                       'pd_US.ISO8859-1',
locale.py(1508):     'pd_us.iso885915':                      'pd_US.ISO8859-15',
locale.py(1509):     'pd_us@euro':                           'pd_US.ISO8859-15',
locale.py(1510):     'ph':                                   'ph_PH.ISO8859-1',
locale.py(1511):     'ph_ph':                                'ph_PH.ISO8859-1',
locale.py(1512):     'ph_ph.iso88591':                       'ph_PH.ISO8859-1',
locale.py(1513):     'pl':                                   'pl_PL.ISO8859-2',
locale.py(1514):     'pl_pl':                                'pl_PL.ISO8859-2',
locale.py(1515):     'pl_pl.iso88592':                       'pl_PL.ISO8859-2',
locale.py(1516):     'polish':                               'pl_PL.ISO8859-2',
locale.py(1517):     'portuguese':                           'pt_PT.ISO8859-1',
locale.py(1518):     'portuguese.iso88591':                  'pt_PT.ISO8859-1',
locale.py(1519):     'portuguese_brazil':                    'pt_BR.ISO8859-1',
locale.py(1520):     'portuguese_brazil.8859':               'pt_BR.ISO8859-1',
locale.py(1521):     'posix':                                'C',
locale.py(1522):     'posix-utf2':                           'C',
locale.py(1523):     'pp':                                   'pp_AN.ISO8859-1',
locale.py(1524):     'pp_an':                                'pp_AN.ISO8859-1',
locale.py(1525):     'pp_an.iso88591':                       'pp_AN.ISO8859-1',
locale.py(1526):     'ps_af':                                'ps_AF.UTF-8',
locale.py(1527):     'pt':                                   'pt_PT.ISO8859-1',
locale.py(1528):     'pt.iso885915':                         'pt_PT.ISO8859-15',
locale.py(1529):     'pt_br':                                'pt_BR.ISO8859-1',
locale.py(1530):     'pt_br.88591':                          'pt_BR.ISO8859-1',
locale.py(1531):     'pt_br.iso88591':                       'pt_BR.ISO8859-1',
locale.py(1532):     'pt_br.iso885915':                      'pt_BR.ISO8859-15',
locale.py(1533):     'pt_br@euro':                           'pt_BR.ISO8859-15',
locale.py(1534):     'pt_pt':                                'pt_PT.ISO8859-1',
locale.py(1535):     'pt_pt.88591':                          'pt_PT.ISO8859-1',
locale.py(1536):     'pt_pt.iso88591':                       'pt_PT.ISO8859-1',
locale.py(1537):     'pt_pt.iso885915':                      'pt_PT.ISO8859-15',
locale.py(1538):     'pt_pt.iso885915@euro':                 'pt_PT.ISO8859-15',
locale.py(1539):     'pt_pt.utf8@euro':                      'pt_PT.UTF-8',
locale.py(1540):     'pt_pt@euro':                           'pt_PT.ISO8859-15',
locale.py(1541):     'ro':                                   'ro_RO.ISO8859-2',
locale.py(1542):     'ro_ro':                                'ro_RO.ISO8859-2',
locale.py(1543):     'ro_ro.iso88592':                       'ro_RO.ISO8859-2',
locale.py(1544):     'romanian':                             'ro_RO.ISO8859-2',
locale.py(1545):     'ru':                                   'ru_RU.UTF-8',
locale.py(1546):     'ru.koi8r':                             'ru_RU.KOI8-R',
locale.py(1547):     'ru_ru':                                'ru_RU.UTF-8',
locale.py(1548):     'ru_ru.cp1251':                         'ru_RU.CP1251',
locale.py(1549):     'ru_ru.iso88595':                       'ru_RU.ISO8859-5',
locale.py(1550):     'ru_ru.koi8r':                          'ru_RU.KOI8-R',
locale.py(1551):     'ru_ru.microsoftcp1251':                'ru_RU.CP1251',
locale.py(1552):     'ru_ua':                                'ru_UA.KOI8-U',
locale.py(1553):     'ru_ua.cp1251':                         'ru_UA.CP1251',
locale.py(1554):     'ru_ua.koi8u':                          'ru_UA.KOI8-U',
locale.py(1555):     'ru_ua.microsoftcp1251':                'ru_UA.CP1251',
locale.py(1556):     'rumanian':                             'ro_RO.ISO8859-2',
locale.py(1557):     'russian':                              'ru_RU.ISO8859-5',
locale.py(1558):     'rw':                                   'rw_RW.ISO8859-1',
locale.py(1559):     'rw_rw':                                'rw_RW.ISO8859-1',
locale.py(1560):     'rw_rw.iso88591':                       'rw_RW.ISO8859-1',
locale.py(1561):     'sa_in':                                'sa_IN.UTF-8',
locale.py(1562):     'sat_in':                               'sat_IN.UTF-8',
locale.py(1563):     'sc_it':                                'sc_IT.UTF-8',
locale.py(1564):     'sd':                                   'sd_IN.UTF-8',
locale.py(1565):     'sd@devanagari':                        'sd_IN.UTF-8@devanagari',
locale.py(1566):     'sd_in':                                'sd_IN.UTF-8',
locale.py(1567):     'sd_in@devanagari':                     'sd_IN.UTF-8@devanagari',
locale.py(1568):     'sd_in@devanagari.utf8':                'sd_IN.UTF-8@devanagari',
locale.py(1569):     'sd_pk':                                'sd_PK.UTF-8',
locale.py(1570):     'se_no':                                'se_NO.UTF-8',
locale.py(1571):     'serbocroatian':                        'sr_RS.UTF-8@latin',
locale.py(1572):     'sh':                                   'sr_RS.UTF-8@latin',
locale.py(1573):     'sh_ba.iso88592@bosnia':                'sr_CS.ISO8859-2',
locale.py(1574):     'sh_hr':                                'sh_HR.ISO8859-2',
locale.py(1575):     'sh_hr.iso88592':                       'hr_HR.ISO8859-2',
locale.py(1576):     'sh_sp':                                'sr_CS.ISO8859-2',
locale.py(1577):     'sh_yu':                                'sr_RS.UTF-8@latin',
locale.py(1578):     'shs_ca':                               'shs_CA.UTF-8',
locale.py(1579):     'si':                                   'si_LK.UTF-8',
locale.py(1580):     'si_lk':                                'si_LK.UTF-8',
locale.py(1581):     'sid_et':                               'sid_ET.UTF-8',
locale.py(1582):     'sinhala':                              'si_LK.UTF-8',
locale.py(1583):     'sk':                                   'sk_SK.ISO8859-2',
locale.py(1584):     'sk_sk':                                'sk_SK.ISO8859-2',
locale.py(1585):     'sk_sk.iso88592':                       'sk_SK.ISO8859-2',
locale.py(1586):     'sl':                                   'sl_SI.ISO8859-2',
locale.py(1587):     'sl_cs':                                'sl_CS.ISO8859-2',
locale.py(1588):     'sl_si':                                'sl_SI.ISO8859-2',
locale.py(1589):     'sl_si.iso88592':                       'sl_SI.ISO8859-2',
locale.py(1590):     'slovak':                               'sk_SK.ISO8859-2',
locale.py(1591):     'slovene':                              'sl_SI.ISO8859-2',
locale.py(1592):     'slovenian':                            'sl_SI.ISO8859-2',
locale.py(1593):     'so_dj':                                'so_DJ.ISO8859-1',
locale.py(1594):     'so_et':                                'so_ET.UTF-8',
locale.py(1595):     'so_ke':                                'so_KE.ISO8859-1',
locale.py(1596):     'so_so':                                'so_SO.ISO8859-1',
locale.py(1597):     'sp':                                   'sr_CS.ISO8859-5',
locale.py(1598):     'sp_yu':                                'sr_CS.ISO8859-5',
locale.py(1599):     'spanish':                              'es_ES.ISO8859-1',
locale.py(1600):     'spanish.iso88591':                     'es_ES.ISO8859-1',
locale.py(1601):     'spanish_spain':                        'es_ES.ISO8859-1',
locale.py(1602):     'spanish_spain.8859':                   'es_ES.ISO8859-1',
locale.py(1603):     'sq':                                   'sq_AL.ISO8859-2',
locale.py(1604):     'sq_al':                                'sq_AL.ISO8859-2',
locale.py(1605):     'sq_al.iso88592':                       'sq_AL.ISO8859-2',
locale.py(1606):     'sq_mk':                                'sq_MK.UTF-8',
locale.py(1607):     'sr':                                   'sr_RS.UTF-8',
locale.py(1608):     'sr@cyrillic':                          'sr_RS.UTF-8',
locale.py(1609):     'sr@latin':                             'sr_RS.UTF-8@latin',
locale.py(1610):     'sr@latn':                              'sr_CS.UTF-8@latin',
locale.py(1611):     'sr_cs':                                'sr_CS.UTF-8',
locale.py(1612):     'sr_cs.iso88592':                       'sr_CS.ISO8859-2',
locale.py(1613):     'sr_cs.iso88592@latn':                  'sr_CS.ISO8859-2',
locale.py(1614):     'sr_cs.iso88595':                       'sr_CS.ISO8859-5',
locale.py(1615):     'sr_cs.utf8@latn':                      'sr_CS.UTF-8@latin',
locale.py(1616):     'sr_cs@latn':                           'sr_CS.UTF-8@latin',
locale.py(1617):     'sr_me':                                'sr_ME.UTF-8',
locale.py(1618):     'sr_rs':                                'sr_RS.UTF-8',
locale.py(1619):     'sr_rs@latin':                          'sr_RS.UTF-8@latin',
locale.py(1620):     'sr_rs@latn':                           'sr_RS.UTF-8@latin',
locale.py(1621):     'sr_sp':                                'sr_CS.ISO8859-2',
locale.py(1622):     'sr_yu':                                'sr_RS.UTF-8@latin',
locale.py(1623):     'sr_yu.cp1251@cyrillic':                'sr_CS.CP1251',
locale.py(1624):     'sr_yu.iso88592':                       'sr_CS.ISO8859-2',
locale.py(1625):     'sr_yu.iso88595':                       'sr_CS.ISO8859-5',
locale.py(1626):     'sr_yu.iso88595@cyrillic':              'sr_CS.ISO8859-5',
locale.py(1627):     'sr_yu.microsoftcp1251@cyrillic':       'sr_CS.CP1251',
locale.py(1628):     'sr_yu.utf8':                           'sr_RS.UTF-8',
locale.py(1629):     'sr_yu.utf8@cyrillic':                  'sr_RS.UTF-8',
locale.py(1630):     'sr_yu@cyrillic':                       'sr_RS.UTF-8',
locale.py(1631):     'ss':                                   'ss_ZA.ISO8859-1',
locale.py(1632):     'ss_za':                                'ss_ZA.ISO8859-1',
locale.py(1633):     'ss_za.iso88591':                       'ss_ZA.ISO8859-1',
locale.py(1634):     'st':                                   'st_ZA.ISO8859-1',
locale.py(1635):     'st_za':                                'st_ZA.ISO8859-1',
locale.py(1636):     'st_za.iso88591':                       'st_ZA.ISO8859-1',
locale.py(1637):     'sv':                                   'sv_SE.ISO8859-1',
locale.py(1638):     'sv.iso885915':                         'sv_SE.ISO8859-15',
locale.py(1639):     'sv_fi':                                'sv_FI.ISO8859-1',
locale.py(1640):     'sv_fi.iso88591':                       'sv_FI.ISO8859-1',
locale.py(1641):     'sv_fi.iso885915':                      'sv_FI.ISO8859-15',
locale.py(1642):     'sv_fi.iso885915@euro':                 'sv_FI.ISO8859-15',
locale.py(1643):     'sv_fi.utf8@euro':                      'sv_FI.UTF-8',
locale.py(1644):     'sv_fi@euro':                           'sv_FI.ISO8859-15',
locale.py(1645):     'sv_se':                                'sv_SE.ISO8859-1',
locale.py(1646):     'sv_se.88591':                          'sv_SE.ISO8859-1',
locale.py(1647):     'sv_se.iso88591':                       'sv_SE.ISO8859-1',
locale.py(1648):     'sv_se.iso885915':                      'sv_SE.ISO8859-15',
locale.py(1649):     'sv_se@euro':                           'sv_SE.ISO8859-15',
locale.py(1650):     'sw_ke':                                'sw_KE.UTF-8',
locale.py(1651):     'sw_tz':                                'sw_TZ.UTF-8',
locale.py(1652):     'swedish':                              'sv_SE.ISO8859-1',
locale.py(1653):     'swedish.iso88591':                     'sv_SE.ISO8859-1',
locale.py(1654):     'szl_pl':                               'szl_PL.UTF-8',
locale.py(1655):     'ta':                                   'ta_IN.TSCII-0',
locale.py(1656):     'ta_in':                                'ta_IN.TSCII-0',
locale.py(1657):     'ta_in.tscii':                          'ta_IN.TSCII-0',
locale.py(1658):     'ta_in.tscii0':                         'ta_IN.TSCII-0',
locale.py(1659):     'ta_lk':                                'ta_LK.UTF-8',
locale.py(1660):     'te':                                   'te_IN.UTF-8',
locale.py(1661):     'te_in':                                'te_IN.UTF-8',
locale.py(1662):     'tg':                                   'tg_TJ.KOI8-C',
locale.py(1663):     'tg_tj':                                'tg_TJ.KOI8-C',
locale.py(1664):     'tg_tj.koi8c':                          'tg_TJ.KOI8-C',
locale.py(1665):     'th':                                   'th_TH.ISO8859-11',
locale.py(1666):     'th_th':                                'th_TH.ISO8859-11',
locale.py(1667):     'th_th.iso885911':                      'th_TH.ISO8859-11',
locale.py(1668):     'th_th.tactis':                         'th_TH.TIS620',
locale.py(1669):     'th_th.tis620':                         'th_TH.TIS620',
locale.py(1670):     'thai':                                 'th_TH.ISO8859-11',
locale.py(1671):     'ti_er':                                'ti_ER.UTF-8',
locale.py(1672):     'ti_et':                                'ti_ET.UTF-8',
locale.py(1673):     'tig_er':                               'tig_ER.UTF-8',
locale.py(1674):     'tk_tm':                                'tk_TM.UTF-8',
locale.py(1675):     'tl':                                   'tl_PH.ISO8859-1',
locale.py(1676):     'tl_ph':                                'tl_PH.ISO8859-1',
locale.py(1677):     'tl_ph.iso88591':                       'tl_PH.ISO8859-1',
locale.py(1678):     'tn':                                   'tn_ZA.ISO8859-15',
locale.py(1679):     'tn_za':                                'tn_ZA.ISO8859-15',
locale.py(1680):     'tn_za.iso885915':                      'tn_ZA.ISO8859-15',
locale.py(1681):     'tr':                                   'tr_TR.ISO8859-9',
locale.py(1682):     'tr_cy':                                'tr_CY.ISO8859-9',
locale.py(1683):     'tr_tr':                                'tr_TR.ISO8859-9',
locale.py(1684):     'tr_tr.iso88599':                       'tr_TR.ISO8859-9',
locale.py(1685):     'ts':                                   'ts_ZA.ISO8859-1',
locale.py(1686):     'ts_za':                                'ts_ZA.ISO8859-1',
locale.py(1687):     'ts_za.iso88591':                       'ts_ZA.ISO8859-1',
locale.py(1688):     'tt':                                   'tt_RU.TATAR-CYR',
locale.py(1689):     'tt_ru':                                'tt_RU.TATAR-CYR',
locale.py(1690):     'tt_ru.koi8c':                          'tt_RU.KOI8-C',
locale.py(1691):     'tt_ru.tatarcyr':                       'tt_RU.TATAR-CYR',
locale.py(1692):     'tt_ru@iqtelif':                        'tt_RU.UTF-8@iqtelif',
locale.py(1693):     'turkish':                              'tr_TR.ISO8859-9',
locale.py(1694):     'turkish.iso88599':                     'tr_TR.ISO8859-9',
locale.py(1695):     'ug_cn':                                'ug_CN.UTF-8',
locale.py(1696):     'uk':                                   'uk_UA.KOI8-U',
locale.py(1697):     'uk_ua':                                'uk_UA.KOI8-U',
locale.py(1698):     'uk_ua.cp1251':                         'uk_UA.CP1251',
locale.py(1699):     'uk_ua.iso88595':                       'uk_UA.ISO8859-5',
locale.py(1700):     'uk_ua.koi8u':                          'uk_UA.KOI8-U',
locale.py(1701):     'uk_ua.microsoftcp1251':                'uk_UA.CP1251',
locale.py(1702):     'univ':                                 'en_US.UTF-8',
locale.py(1703):     'universal':                            'en_US.UTF-8',
locale.py(1704):     'universal.utf8@ucs4':                  'en_US.UTF-8',
locale.py(1705):     'unm_us':                               'unm_US.UTF-8',
locale.py(1706):     'ur':                                   'ur_PK.CP1256',
locale.py(1707):     'ur_in':                                'ur_IN.UTF-8',
locale.py(1708):     'ur_pk':                                'ur_PK.CP1256',
locale.py(1709):     'ur_pk.cp1256':                         'ur_PK.CP1256',
locale.py(1710):     'ur_pk.microsoftcp1256':                'ur_PK.CP1256',
locale.py(1711):     'uz':                                   'uz_UZ.UTF-8',
locale.py(1712):     'uz_uz':                                'uz_UZ.UTF-8',
locale.py(1713):     'uz_uz.iso88591':                       'uz_UZ.ISO8859-1',
locale.py(1714):     'uz_uz.utf8@cyrillic':                  'uz_UZ.UTF-8',
locale.py(1715):     'uz_uz@cyrillic':                       'uz_UZ.UTF-8',
locale.py(1716):     've':                                   've_ZA.UTF-8',
locale.py(1717):     've_za':                                've_ZA.UTF-8',
locale.py(1718):     'vi':                                   'vi_VN.TCVN',
locale.py(1719):     'vi_vn':                                'vi_VN.TCVN',
locale.py(1720):     'vi_vn.tcvn':                           'vi_VN.TCVN',
locale.py(1721):     'vi_vn.tcvn5712':                       'vi_VN.TCVN',
locale.py(1722):     'vi_vn.viscii':                         'vi_VN.VISCII',
locale.py(1723):     'vi_vn.viscii111':                      'vi_VN.VISCII',
locale.py(1724):     'wa':                                   'wa_BE.ISO8859-1',
locale.py(1725):     'wa_be':                                'wa_BE.ISO8859-1',
locale.py(1726):     'wa_be.iso88591':                       'wa_BE.ISO8859-1',
locale.py(1727):     'wa_be.iso885915':                      'wa_BE.ISO8859-15',
locale.py(1728):     'wa_be.iso885915@euro':                 'wa_BE.ISO8859-15',
locale.py(1729):     'wa_be@euro':                           'wa_BE.ISO8859-15',
locale.py(1730):     'wae_ch':                               'wae_CH.UTF-8',
locale.py(1731):     'wal_et':                               'wal_ET.UTF-8',
locale.py(1732):     'wo_sn':                                'wo_SN.UTF-8',
locale.py(1733):     'xh':                                   'xh_ZA.ISO8859-1',
locale.py(1734):     'xh_za':                                'xh_ZA.ISO8859-1',
locale.py(1735):     'xh_za.iso88591':                       'xh_ZA.ISO8859-1',
locale.py(1736):     'yi':                                   'yi_US.CP1255',
locale.py(1737):     'yi_us':                                'yi_US.CP1255',
locale.py(1738):     'yi_us.cp1255':                         'yi_US.CP1255',
locale.py(1739):     'yi_us.microsoftcp1255':                'yi_US.CP1255',
locale.py(1740):     'yo_ng':                                'yo_NG.UTF-8',
locale.py(1741):     'yue_hk':                               'yue_HK.UTF-8',
locale.py(1742):     'zh':                                   'zh_CN.eucCN',
locale.py(1743):     'zh_cn':                                'zh_CN.gb2312',
locale.py(1744):     'zh_cn.big5':                           'zh_TW.big5',
locale.py(1745):     'zh_cn.euc':                            'zh_CN.eucCN',
locale.py(1746):     'zh_cn.gb18030':                        'zh_CN.gb18030',
locale.py(1747):     'zh_cn.gb2312':                         'zh_CN.gb2312',
locale.py(1748):     'zh_cn.gbk':                            'zh_CN.gbk',
locale.py(1749):     'zh_hk':                                'zh_HK.big5hkscs',
locale.py(1750):     'zh_hk.big5':                           'zh_HK.big5',
locale.py(1751):     'zh_hk.big5hk':                         'zh_HK.big5hkscs',
locale.py(1752):     'zh_hk.big5hkscs':                      'zh_HK.big5hkscs',
locale.py(1753):     'zh_sg':                                'zh_SG.GB2312',
locale.py(1754):     'zh_sg.gbk':                            'zh_SG.GBK',
locale.py(1755):     'zh_tw':                                'zh_TW.big5',
locale.py(1756):     'zh_tw.big5':                           'zh_TW.big5',
locale.py(1757):     'zh_tw.euc':                            'zh_TW.eucTW',
locale.py(1758):     'zh_tw.euctw':                          'zh_TW.eucTW',
locale.py(1759):     'zu':                                   'zu_ZA.ISO8859-1',
locale.py(1760):     'zu_za':                                'zu_ZA.ISO8859-1',
locale.py(1761):     'zu_za.iso88591':                       'zu_ZA.ISO8859-1',
locale.py(1777): windows_locale = {
locale.py(1778):     0x0436: "af_ZA", # Afrikaans
locale.py(1779):     0x041c: "sq_AL", # Albanian
locale.py(1780):     0x0484: "gsw_FR",# Alsatian - France
locale.py(1781):     0x045e: "am_ET", # Amharic - Ethiopia
locale.py(1782):     0x0401: "ar_SA", # Arabic - Saudi Arabia
locale.py(1783):     0x0801: "ar_IQ", # Arabic - Iraq
locale.py(1784):     0x0c01: "ar_EG", # Arabic - Egypt
locale.py(1785):     0x1001: "ar_LY", # Arabic - Libya
locale.py(1786):     0x1401: "ar_DZ", # Arabic - Algeria
locale.py(1787):     0x1801: "ar_MA", # Arabic - Morocco
locale.py(1788):     0x1c01: "ar_TN", # Arabic - Tunisia
locale.py(1789):     0x2001: "ar_OM", # Arabic - Oman
locale.py(1790):     0x2401: "ar_YE", # Arabic - Yemen
locale.py(1791):     0x2801: "ar_SY", # Arabic - Syria
locale.py(1792):     0x2c01: "ar_JO", # Arabic - Jordan
locale.py(1793):     0x3001: "ar_LB", # Arabic - Lebanon
locale.py(1794):     0x3401: "ar_KW", # Arabic - Kuwait
locale.py(1795):     0x3801: "ar_AE", # Arabic - United Arab Emirates
locale.py(1796):     0x3c01: "ar_BH", # Arabic - Bahrain
locale.py(1797):     0x4001: "ar_QA", # Arabic - Qatar
locale.py(1798):     0x042b: "hy_AM", # Armenian
locale.py(1799):     0x044d: "as_IN", # Assamese - India
locale.py(1800):     0x042c: "az_AZ", # Azeri - Latin
locale.py(1801):     0x082c: "az_AZ", # Azeri - Cyrillic
locale.py(1802):     0x046d: "ba_RU", # Bashkir
locale.py(1803):     0x042d: "eu_ES", # Basque - Russia
locale.py(1804):     0x0423: "be_BY", # Belarusian
locale.py(1805):     0x0445: "bn_IN", # Begali
locale.py(1806):     0x201a: "bs_BA", # Bosnian - Cyrillic
locale.py(1807):     0x141a: "bs_BA", # Bosnian - Latin
locale.py(1808):     0x047e: "br_FR", # Breton - France
locale.py(1809):     0x0402: "bg_BG", # Bulgarian
locale.py(1811):     0x0403: "ca_ES", # Catalan
locale.py(1812):     0x0004: "zh_CHS",# Chinese - Simplified
locale.py(1813):     0x0404: "zh_TW", # Chinese - Taiwan
locale.py(1814):     0x0804: "zh_CN", # Chinese - PRC
locale.py(1815):     0x0c04: "zh_HK", # Chinese - Hong Kong S.A.R.
locale.py(1816):     0x1004: "zh_SG", # Chinese - Singapore
locale.py(1817):     0x1404: "zh_MO", # Chinese - Macao S.A.R.
locale.py(1818):     0x7c04: "zh_CHT",# Chinese - Traditional
locale.py(1819):     0x0483: "co_FR", # Corsican - France
locale.py(1820):     0x041a: "hr_HR", # Croatian
locale.py(1821):     0x101a: "hr_BA", # Croatian - Bosnia
locale.py(1822):     0x0405: "cs_CZ", # Czech
locale.py(1823):     0x0406: "da_DK", # Danish
locale.py(1824):     0x048c: "gbz_AF",# Dari - Afghanistan
locale.py(1825):     0x0465: "div_MV",# Divehi - Maldives
locale.py(1826):     0x0413: "nl_NL", # Dutch - The Netherlands
locale.py(1827):     0x0813: "nl_BE", # Dutch - Belgium
locale.py(1828):     0x0409: "en_US", # English - United States
locale.py(1829):     0x0809: "en_GB", # English - United Kingdom
locale.py(1830):     0x0c09: "en_AU", # English - Australia
locale.py(1831):     0x1009: "en_CA", # English - Canada
locale.py(1832):     0x1409: "en_NZ", # English - New Zealand
locale.py(1833):     0x1809: "en_IE", # English - Ireland
locale.py(1834):     0x1c09: "en_ZA", # English - South Africa
locale.py(1835):     0x2009: "en_JA", # English - Jamaica
locale.py(1836):     0x2409: "en_CB", # English - Carribbean
locale.py(1837):     0x2809: "en_BZ", # English - Belize
locale.py(1838):     0x2c09: "en_TT", # English - Trinidad
locale.py(1839):     0x3009: "en_ZW", # English - Zimbabwe
locale.py(1840):     0x3409: "en_PH", # English - Philippines
locale.py(1841):     0x4009: "en_IN", # English - India
locale.py(1842):     0x4409: "en_MY", # English - Malaysia
locale.py(1843):     0x4809: "en_IN", # English - Singapore
locale.py(1844):     0x0425: "et_EE", # Estonian
locale.py(1845):     0x0438: "fo_FO", # Faroese
locale.py(1846):     0x0464: "fil_PH",# Filipino
locale.py(1847):     0x040b: "fi_FI", # Finnish
locale.py(1848):     0x040c: "fr_FR", # French - France
locale.py(1849):     0x080c: "fr_BE", # French - Belgium
locale.py(1850):     0x0c0c: "fr_CA", # French - Canada
locale.py(1851):     0x100c: "fr_CH", # French - Switzerland
locale.py(1852):     0x140c: "fr_LU", # French - Luxembourg
locale.py(1853):     0x180c: "fr_MC", # French - Monaco
locale.py(1854):     0x0462: "fy_NL", # Frisian - Netherlands
locale.py(1855):     0x0456: "gl_ES", # Galician
locale.py(1856):     0x0437: "ka_GE", # Georgian
locale.py(1857):     0x0407: "de_DE", # German - Germany
locale.py(1858):     0x0807: "de_CH", # German - Switzerland
locale.py(1859):     0x0c07: "de_AT", # German - Austria
locale.py(1860):     0x1007: "de_LU", # German - Luxembourg
locale.py(1861):     0x1407: "de_LI", # German - Liechtenstein
locale.py(1862):     0x0408: "el_GR", # Greek
locale.py(1863):     0x046f: "kl_GL", # Greenlandic - Greenland
locale.py(1864):     0x0447: "gu_IN", # Gujarati
locale.py(1865):     0x0468: "ha_NG", # Hausa - Latin
locale.py(1866):     0x040d: "he_IL", # Hebrew
locale.py(1867):     0x0439: "hi_IN", # Hindi
locale.py(1868):     0x040e: "hu_HU", # Hungarian
locale.py(1869):     0x040f: "is_IS", # Icelandic
locale.py(1870):     0x0421: "id_ID", # Indonesian
locale.py(1871):     0x045d: "iu_CA", # Inuktitut - Syllabics
locale.py(1872):     0x085d: "iu_CA", # Inuktitut - Latin
locale.py(1873):     0x083c: "ga_IE", # Irish - Ireland
locale.py(1874):     0x0410: "it_IT", # Italian - Italy
locale.py(1875):     0x0810: "it_CH", # Italian - Switzerland
locale.py(1876):     0x0411: "ja_JP", # Japanese
locale.py(1877):     0x044b: "kn_IN", # Kannada - India
locale.py(1878):     0x043f: "kk_KZ", # Kazakh
locale.py(1879):     0x0453: "kh_KH", # Khmer - Cambodia
locale.py(1880):     0x0486: "qut_GT",# K'iche - Guatemala
locale.py(1881):     0x0487: "rw_RW", # Kinyarwanda - Rwanda
locale.py(1882):     0x0457: "kok_IN",# Konkani
locale.py(1883):     0x0412: "ko_KR", # Korean
locale.py(1884):     0x0440: "ky_KG", # Kyrgyz
locale.py(1885):     0x0454: "lo_LA", # Lao - Lao PDR
locale.py(1886):     0x0426: "lv_LV", # Latvian
locale.py(1887):     0x0427: "lt_LT", # Lithuanian
locale.py(1888):     0x082e: "dsb_DE",# Lower Sorbian - Germany
locale.py(1889):     0x046e: "lb_LU", # Luxembourgish
locale.py(1890):     0x042f: "mk_MK", # FYROM Macedonian
locale.py(1891):     0x043e: "ms_MY", # Malay - Malaysia
locale.py(1892):     0x083e: "ms_BN", # Malay - Brunei Darussalam
locale.py(1893):     0x044c: "ml_IN", # Malayalam - India
locale.py(1894):     0x043a: "mt_MT", # Maltese
locale.py(1895):     0x0481: "mi_NZ", # Maori
locale.py(1896):     0x047a: "arn_CL",# Mapudungun
locale.py(1897):     0x044e: "mr_IN", # Marathi
locale.py(1898):     0x047c: "moh_CA",# Mohawk - Canada
locale.py(1899):     0x0450: "mn_MN", # Mongolian - Cyrillic
locale.py(1900):     0x0850: "mn_CN", # Mongolian - PRC
locale.py(1901):     0x0461: "ne_NP", # Nepali
locale.py(1902):     0x0414: "nb_NO", # Norwegian - Bokmal
locale.py(1903):     0x0814: "nn_NO", # Norwegian - Nynorsk
locale.py(1904):     0x0482: "oc_FR", # Occitan - France
locale.py(1905):     0x0448: "or_IN", # Oriya - India
locale.py(1906):     0x0463: "ps_AF", # Pashto - Afghanistan
locale.py(1907):     0x0429: "fa_IR", # Persian
locale.py(1908):     0x0415: "pl_PL", # Polish
locale.py(1909):     0x0416: "pt_BR", # Portuguese - Brazil
locale.py(1910):     0x0816: "pt_PT", # Portuguese - Portugal
locale.py(1911):     0x0446: "pa_IN", # Punjabi
locale.py(1912):     0x046b: "quz_BO",# Quechua (Bolivia)
locale.py(1913):     0x086b: "quz_EC",# Quechua (Ecuador)
locale.py(1914):     0x0c6b: "quz_PE",# Quechua (Peru)
locale.py(1915):     0x0418: "ro_RO", # Romanian - Romania
locale.py(1916):     0x0417: "rm_CH", # Romansh
locale.py(1917):     0x0419: "ru_RU", # Russian
locale.py(1918):     0x243b: "smn_FI",# Sami Finland
locale.py(1919):     0x103b: "smj_NO",# Sami Norway
locale.py(1920):     0x143b: "smj_SE",# Sami Sweden
locale.py(1921):     0x043b: "se_NO", # Sami Northern Norway
locale.py(1922):     0x083b: "se_SE", # Sami Northern Sweden
locale.py(1923):     0x0c3b: "se_FI", # Sami Northern Finland
locale.py(1924):     0x203b: "sms_FI",# Sami Skolt
locale.py(1925):     0x183b: "sma_NO",# Sami Southern Norway
locale.py(1926):     0x1c3b: "sma_SE",# Sami Southern Sweden
locale.py(1927):     0x044f: "sa_IN", # Sanskrit
locale.py(1928):     0x0c1a: "sr_SP", # Serbian - Cyrillic
locale.py(1929):     0x1c1a: "sr_BA", # Serbian - Bosnia Cyrillic
locale.py(1930):     0x081a: "sr_SP", # Serbian - Latin
locale.py(1931):     0x181a: "sr_BA", # Serbian - Bosnia Latin
locale.py(1932):     0x045b: "si_LK", # Sinhala - Sri Lanka
locale.py(1933):     0x046c: "ns_ZA", # Northern Sotho
locale.py(1934):     0x0432: "tn_ZA", # Setswana - Southern Africa
locale.py(1935):     0x041b: "sk_SK", # Slovak
locale.py(1936):     0x0424: "sl_SI", # Slovenian
locale.py(1937):     0x040a: "es_ES", # Spanish - Spain
locale.py(1938):     0x080a: "es_MX", # Spanish - Mexico
locale.py(1939):     0x0c0a: "es_ES", # Spanish - Spain (Modern)
locale.py(1940):     0x100a: "es_GT", # Spanish - Guatemala
locale.py(1941):     0x140a: "es_CR", # Spanish - Costa Rica
locale.py(1942):     0x180a: "es_PA", # Spanish - Panama
locale.py(1943):     0x1c0a: "es_DO", # Spanish - Dominican Republic
locale.py(1944):     0x200a: "es_VE", # Spanish - Venezuela
locale.py(1945):     0x240a: "es_CO", # Spanish - Colombia
locale.py(1946):     0x280a: "es_PE", # Spanish - Peru
locale.py(1947):     0x2c0a: "es_AR", # Spanish - Argentina
locale.py(1948):     0x300a: "es_EC", # Spanish - Ecuador
locale.py(1949):     0x340a: "es_CL", # Spanish - Chile
locale.py(1950):     0x380a: "es_UR", # Spanish - Uruguay
locale.py(1951):     0x3c0a: "es_PY", # Spanish - Paraguay
locale.py(1952):     0x400a: "es_BO", # Spanish - Bolivia
locale.py(1953):     0x440a: "es_SV", # Spanish - El Salvador
locale.py(1954):     0x480a: "es_HN", # Spanish - Honduras
locale.py(1955):     0x4c0a: "es_NI", # Spanish - Nicaragua
locale.py(1956):     0x500a: "es_PR", # Spanish - Puerto Rico
locale.py(1957):     0x540a: "es_US", # Spanish - United States
locale.py(1959):     0x0441: "sw_KE", # Swahili
locale.py(1960):     0x041d: "sv_SE", # Swedish - Sweden
locale.py(1961):     0x081d: "sv_FI", # Swedish - Finland
locale.py(1962):     0x045a: "syr_SY",# Syriac
locale.py(1963):     0x0428: "tg_TJ", # Tajik - Cyrillic
locale.py(1964):     0x085f: "tmz_DZ",# Tamazight - Latin
locale.py(1965):     0x0449: "ta_IN", # Tamil
locale.py(1966):     0x0444: "tt_RU", # Tatar
locale.py(1967):     0x044a: "te_IN", # Telugu
locale.py(1968):     0x041e: "th_TH", # Thai
locale.py(1969):     0x0851: "bo_BT", # Tibetan - Bhutan
locale.py(1970):     0x0451: "bo_CN", # Tibetan - PRC
locale.py(1971):     0x041f: "tr_TR", # Turkish
locale.py(1972):     0x0442: "tk_TM", # Turkmen - Cyrillic
locale.py(1973):     0x0480: "ug_CN", # Uighur - Arabic
locale.py(1974):     0x0422: "uk_UA", # Ukrainian
locale.py(1975):     0x042e: "wen_DE",# Upper Sorbian - Germany
locale.py(1976):     0x0420: "ur_PK", # Urdu
locale.py(1977):     0x0820: "ur_IN", # Urdu - India
locale.py(1978):     0x0443: "uz_UZ", # Uzbek - Latin
locale.py(1979):     0x0843: "uz_UZ", # Uzbek - Cyrillic
locale.py(1980):     0x042a: "vi_VN", # Vietnamese
locale.py(1981):     0x0452: "cy_GB", # Welsh
locale.py(1982):     0x0488: "wo_SN", # Wolof - Senegal
locale.py(1983):     0x0434: "xh_ZA", # Xhosa - South Africa
locale.py(1984):     0x0485: "sah_RU",# Yakut - Cyrillic
locale.py(1985):     0x0478: "ii_CN", # Yi - PRC
locale.py(1986):     0x046a: "yo_NG", # Yoruba - Nigeria
locale.py(1987):     0x0435: "zu_ZA", # Zulu
locale.py(1990): def _print_locale():
locale.py(2048): try:
locale.py(2049):     LC_MESSAGES
locale.py(2053):     __all__.append("LC_MESSAGES")
locale.py(2055): if __name__=='__main__':
misc.py(10): import os
misc.py(11): import sys
misc.py(12): import types
misc.py(14): from coverage import env
misc.py(15): from coverage.backward import string_class, to_bytes, unicode_class
misc.py(17): ISOLATED_MODULES = {}
misc.py(20): def isolate_module(mod):
misc.py(38): os = isolate_module(os)
 --- modulename: misc, funcname: isolate_module
misc.py(28):     if mod not in ISOLATED_MODULES:
misc.py(29):         new_mod = types.ModuleType(mod.__name__)
misc.py(30):         ISOLATED_MODULES[mod] = new_mod
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(34):                 value = isolate_module(value)
 --- modulename: misc, funcname: isolate_module
misc.py(28):     if mod not in ISOLATED_MODULES:
misc.py(29):         new_mod = types.ModuleType(mod.__name__)
misc.py(30):         ISOLATED_MODULES[mod] = new_mod
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(34):                 value = isolate_module(value)
 --- modulename: misc, funcname: isolate_module
misc.py(28):     if mod not in ISOLATED_MODULES:
misc.py(29):         new_mod = types.ModuleType(mod.__name__)
misc.py(30):         ISOLATED_MODULES[mod] = new_mod
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(34):                 value = isolate_module(value)
 --- modulename: misc, funcname: isolate_module
misc.py(28):     if mod not in ISOLATED_MODULES:
misc.py(29):         new_mod = types.ModuleType(mod.__name__)
misc.py(30):         ISOLATED_MODULES[mod] = new_mod
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(36):     return ISOLATED_MODULES[mod]
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(36):     return ISOLATED_MODULES[mod]
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(36):     return ISOLATED_MODULES[mod]
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(34):                 value = isolate_module(value)
 --- modulename: misc, funcname: isolate_module
misc.py(28):     if mod not in ISOLATED_MODULES:
misc.py(29):         new_mod = types.ModuleType(mod.__name__)
misc.py(30):         ISOLATED_MODULES[mod] = new_mod
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(36):     return ISOLATED_MODULES[mod]
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(34):                 value = isolate_module(value)
 --- modulename: misc, funcname: isolate_module
misc.py(28):     if mod not in ISOLATED_MODULES:
misc.py(29):         new_mod = types.ModuleType(mod.__name__)
misc.py(30):         ISOLATED_MODULES[mod] = new_mod
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(36):     return ISOLATED_MODULES[mod]
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(34):                 value = isolate_module(value)
 --- modulename: misc, funcname: isolate_module
misc.py(28):     if mod not in ISOLATED_MODULES:
misc.py(29):         new_mod = types.ModuleType(mod.__name__)
misc.py(30):         ISOLATED_MODULES[mod] = new_mod
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(34):                 value = isolate_module(value)
 --- modulename: misc, funcname: isolate_module
misc.py(28):     if mod not in ISOLATED_MODULES:
misc.py(29):         new_mod = types.ModuleType(mod.__name__)
misc.py(30):         ISOLATED_MODULES[mod] = new_mod
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(34):                 value = isolate_module(value)
 --- modulename: misc, funcname: isolate_module
misc.py(28):     if mod not in ISOLATED_MODULES:
misc.py(36):     return ISOLATED_MODULES[mod]
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(34):                 value = isolate_module(value)
 --- modulename: misc, funcname: isolate_module
misc.py(28):     if mod not in ISOLATED_MODULES:
misc.py(29):         new_mod = types.ModuleType(mod.__name__)
misc.py(30):         ISOLATED_MODULES[mod] = new_mod
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(36):     return ISOLATED_MODULES[mod]
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(36):     return ISOLATED_MODULES[mod]
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(34):                 value = isolate_module(value)
 --- modulename: misc, funcname: isolate_module
misc.py(28):     if mod not in ISOLATED_MODULES:
misc.py(36):     return ISOLATED_MODULES[mod]
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(34):                 value = isolate_module(value)
 --- modulename: misc, funcname: isolate_module
misc.py(28):     if mod not in ISOLATED_MODULES:
misc.py(36):     return ISOLATED_MODULES[mod]
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(34):                 value = isolate_module(value)
 --- modulename: misc, funcname: isolate_module
misc.py(28):     if mod not in ISOLATED_MODULES:
misc.py(36):     return ISOLATED_MODULES[mod]
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(34):                 value = isolate_module(value)
 --- modulename: misc, funcname: isolate_module
misc.py(28):     if mod not in ISOLATED_MODULES:
misc.py(29):         new_mod = types.ModuleType(mod.__name__)
misc.py(30):         ISOLATED_MODULES[mod] = new_mod
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(34):                 value = isolate_module(value)
 --- modulename: misc, funcname: isolate_module
misc.py(28):     if mod not in ISOLATED_MODULES:
misc.py(29):         new_mod = types.ModuleType(mod.__name__)
misc.py(30):         ISOLATED_MODULES[mod] = new_mod
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(34):                 value = isolate_module(value)
 --- modulename: misc, funcname: isolate_module
misc.py(28):     if mod not in ISOLATED_MODULES:
misc.py(36):     return ISOLATED_MODULES[mod]
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(34):                 value = isolate_module(value)
 --- modulename: misc, funcname: isolate_module
misc.py(28):     if mod not in ISOLATED_MODULES:
misc.py(36):     return ISOLATED_MODULES[mod]
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(36):     return ISOLATED_MODULES[mod]
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(34):                 value = isolate_module(value)
 --- modulename: misc, funcname: isolate_module
misc.py(28):     if mod not in ISOLATED_MODULES:
misc.py(36):     return ISOLATED_MODULES[mod]
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(34):                 value = isolate_module(value)
 --- modulename: misc, funcname: isolate_module
misc.py(28):     if mod not in ISOLATED_MODULES:
misc.py(29):         new_mod = types.ModuleType(mod.__name__)
misc.py(30):         ISOLATED_MODULES[mod] = new_mod
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(36):     return ISOLATED_MODULES[mod]
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(36):     return ISOLATED_MODULES[mod]
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(36):     return ISOLATED_MODULES[mod]
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(34):                 value = isolate_module(value)
 --- modulename: misc, funcname: isolate_module
misc.py(28):     if mod not in ISOLATED_MODULES:
misc.py(36):     return ISOLATED_MODULES[mod]
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(32):             value = getattr(mod, name)
misc.py(33):             if isinstance(value, types.ModuleType):
misc.py(35):             setattr(new_mod, name, value)
misc.py(31):         for name in dir(mod):
misc.py(36):     return ISOLATED_MODULES[mod]
misc.py(43): if env.TESTING:
misc.py(59):     def contract(**unused):
misc.py(64): def nice_pair(pair):
misc.py(78): def format_lines(statements, lines):
misc.py(111): def expensive(fn):
misc.py(132): def bool_or_none(b):
misc.py(140): def join_regex(regexes):
misc.py(145): def file_be_gone(path):
misc.py(154): def output_encoding(outfile=None):
misc.py(166): class Hasher(object):
 --- modulename: misc, funcname: Hasher
misc.py(166): class Hasher(object):
misc.py(167):     """Hashes Python data into md5."""
misc.py(168):     def __init__(self):
misc.py(171):     def update(self, v):
misc.py(200):     def hexdigest(self):
misc.py(205): def _needs_to_implement(that, func_name):
misc.py(222): class CoverageException(Exception):
 --- modulename: misc, funcname: CoverageException
misc.py(222): class CoverageException(Exception):
misc.py(223):     """An exception specific to coverage.py."""
misc.py(224):     pass
misc.py(227): class NoSource(CoverageException):
 --- modulename: misc, funcname: NoSource
misc.py(227): class NoSource(CoverageException):
misc.py(228):     """We couldn't find the source for a module."""
misc.py(229):     pass
misc.py(232): class NoCode(NoSource):
 --- modulename: misc, funcname: NoCode
misc.py(232): class NoCode(NoSource):
misc.py(233):     """We couldn't find any code at all."""
misc.py(234):     pass
misc.py(237): class NotPython(CoverageException):
 --- modulename: misc, funcname: NotPython
misc.py(237): class NotPython(CoverageException):
misc.py(238):     """A source file turned out not to be parsable Python."""
misc.py(239):     pass
misc.py(242): class ExceptionDuringRun(CoverageException):
 --- modulename: misc, funcname: ExceptionDuringRun
misc.py(242): class ExceptionDuringRun(CoverageException):
misc.py(247):     """
misc.py(248):     pass
files.py(19): os = isolate_module(os)
 --- modulename: misc, funcname: isolate_module
misc.py(28):     if mod not in ISOLATED_MODULES:
misc.py(36):     return ISOLATED_MODULES[mod]
files.py(22): def set_relative_directory():
files.py(34): def relative_directory():
files.py(39): @contract(returns='unicode')
 --- modulename: misc, funcname: contract
misc.py(61):         return lambda func: func
 --- modulename: misc, funcname: <lambda>
misc.py(61):         return lambda func: func
files.py(53): @contract(returns='unicode')
 --- modulename: misc, funcname: contract
misc.py(61):         return lambda func: func
 --- modulename: misc, funcname: <lambda>
misc.py(61):         return lambda func: func
files.py(74): def flat_rootname(filename):
files.py(88): if env.WINDOWS:
files.py(126):     def actual_path(filename):
files.py(131): if env.PY2:
files.py(132):     @contract(returns='unicode')
 --- modulename: misc, funcname: contract
misc.py(61):         return lambda func: func
 --- modulename: misc, funcname: <lambda>
misc.py(61):         return lambda func: func
files.py(146): @contract(returns='unicode')
 --- modulename: misc, funcname: contract
misc.py(61):         return lambda func: func
 --- modulename: misc, funcname: <lambda>
misc.py(61):         return lambda func: func
files.py(156): RELATIVE_DIR = None
files.py(157): CANONICAL_FILENAME_CACHE = None
files.py(158): set_relative_directory()
 --- modulename: files, funcname: set_relative_directory
files.py(27):     RELATIVE_DIR = os.path.normcase(abs_file(os.curdir) + os.sep)
 --- modulename: files, funcname: abs_file
files.py(149):     path = os.path.expandvars(os.path.expanduser(filename))
 --- modulename: posixpath, funcname: expanduser
posixpath.py(254):     if not path.startswith('~'):
posixpath.py(255):         return path
 --- modulename: posixpath, funcname: expandvars
posixpath.py(287):     if '$' not in path:
posixpath.py(288):         return path
files.py(150):     path = os.path.abspath(os.path.realpath(path))
 --- modulename: posixpath, funcname: realpath
posixpath.py(375):     path, ok = _joinrealpath('', filename, {})
 --- modulename: posixpath, funcname: _joinrealpath
posixpath.py(381):     if isabs(rest):
 --- modulename: posixpath, funcname: isabs
posixpath.py(54):     return s.startswith('/')
posixpath.py(385):     while rest:
posixpath.py(386):         name, _, rest = rest.partition(sep)
posixpath.py(387):         if not name or name == curdir:
posixpath.py(389):             continue
posixpath.py(385):     while rest:
posixpath.py(419):     return path, True
posixpath.py(376):     return abspath(path)
 --- modulename: posixpath, funcname: abspath
posixpath.py(360):     if not isabs(path):
 --- modulename: posixpath, funcname: isabs
posixpath.py(54):     return s.startswith('/')
posixpath.py(361):         if isinstance(path, _unicode):
posixpath.py(364):             cwd = os.getcwd()
posixpath.py(365):         path = join(cwd, path)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
posixpath.py(366):     return normpath(path)
 --- modulename: posixpath, funcname: normpath
posixpath.py(332):     slash, dot = (u'/', u'.') if isinstance(path, _unicode) else ('/', '.')
posixpath.py(333):     if path == '':
posixpath.py(335):     initial_slashes = path.startswith('/')
posixpath.py(338):     if (initial_slashes and
posixpath.py(339):         path.startswith('//') and not path.startswith('///')):
posixpath.py(341):     comps = path.split('/')
posixpath.py(342):     new_comps = []
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(345):             continue
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(345):             continue
posixpath.py(343):     for comp in comps:
posixpath.py(351):     comps = new_comps
posixpath.py(352):     path = slash.join(comps)
posixpath.py(353):     if initial_slashes:
posixpath.py(354):         path = slash*initial_slashes + path
posixpath.py(355):     return path or dot
 --- modulename: posixpath, funcname: abspath
posixpath.py(360):     if not isabs(path):
 --- modulename: posixpath, funcname: isabs
posixpath.py(54):     return s.startswith('/')
posixpath.py(366):     return normpath(path)
 --- modulename: posixpath, funcname: normpath
posixpath.py(332):     slash, dot = (u'/', u'.') if isinstance(path, _unicode) else ('/', '.')
posixpath.py(333):     if path == '':
posixpath.py(335):     initial_slashes = path.startswith('/')
posixpath.py(338):     if (initial_slashes and
posixpath.py(339):         path.startswith('//') and not path.startswith('///')):
posixpath.py(341):     comps = path.split('/')
posixpath.py(342):     new_comps = []
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(345):             continue
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(351):     comps = new_comps
posixpath.py(352):     path = slash.join(comps)
posixpath.py(353):     if initial_slashes:
posixpath.py(354):         path = slash*initial_slashes + path
posixpath.py(355):     return path or dot
files.py(151):     path = actual_path(path)
 --- modulename: files, funcname: actual_path
files.py(128):         return filename
files.py(152):     path = unicode_filename(path)
 --- modulename: files, funcname: unicode_filename
files.py(135):         if isinstance(filename, str):
files.py(136):             encoding = sys.getfilesystemencoding() or sys.getdefaultencoding()
files.py(137):             filename = filename.decode(encoding, "replace")
 --- modulename: utf_8, funcname: decode
utf_8.py(16):     return codecs.utf_8_decode(input, errors, True)
files.py(138):         return filename
files.py(153):     return path
 --- modulename: posixpath, funcname: normcase
posixpath.py(46):     return s
files.py(31):     CANONICAL_FILENAME_CACHE = {}
files.py(161): def isabs_anywhere(filename):
files.py(166): def prep_patterns(patterns):
files.py(185): class TreeMatcher(object):
 --- modulename: files, funcname: TreeMatcher
files.py(185): class TreeMatcher(object):
files.py(186):     """A matcher for files in a tree."""
files.py(187):     def __init__(self, directories):
files.py(190):     def __repr__(self):
files.py(193):     def info(self):
files.py(197):     def match(self, fpath):
files.py(210): class ModuleMatcher(object):
 --- modulename: files, funcname: ModuleMatcher
files.py(210): class ModuleMatcher(object):
files.py(211):     """A matcher for modules in a tree."""
files.py(212):     def __init__(self, module_names):
files.py(215):     def __repr__(self):
files.py(218):     def info(self):
files.py(222):     def match(self, module_name):
files.py(238): class FnmatchMatcher(object):
 --- modulename: files, funcname: FnmatchMatcher
files.py(238): class FnmatchMatcher(object):
files.py(239):     """A matcher for files by file name pattern."""
files.py(240):     def __init__(self, pats):
files.py(254):     def __repr__(self):
files.py(257):     def info(self):
files.py(261):     def match(self, fpath):
files.py(266): def sep(s):
files.py(276): class PathAliases(object):
 --- modulename: files, funcname: PathAliases
files.py(276): class PathAliases(object):
files.py(286):     """
files.py(287):     def __init__(self):
files.py(290):     def add(self, pattern, result):
files.py(330):     def map(self, path):
files.py(357): def find_python_files(dirname):
control.py(15): from coverage.annotate import AnnotateReporter
 --- modulename: annotate, funcname: <module>
annotate.py(4): """Source file annotation for coverage.py."""
annotate.py(6): import io
annotate.py(7): import os
annotate.py(8): import re
annotate.py(10): from coverage.files import flat_rootname
annotate.py(11): from coverage.misc import isolate_module
annotate.py(12): from coverage.report import Reporter
 --- modulename: report, funcname: <module>
report.py(4): """Reporter foundation for coverage.py."""
report.py(6): import os
report.py(8): from coverage.files import prep_patterns, FnmatchMatcher
report.py(9): from coverage.misc import CoverageException, NoSource, NotPython, isolate_module
report.py(11): os = isolate_module(os)
 --- modulename: misc, funcname: isolate_module
misc.py(28):     if mod not in ISOLATED_MODULES:
misc.py(36):     return ISOLATED_MODULES[mod]
report.py(14): class Reporter(object):
 --- modulename: report, funcname: Reporter
report.py(14): class Reporter(object):
report.py(15):     """A base class for all reporters."""
report.py(17):     def __init__(self, coverage, config):
report.py(34):     def find_file_reporters(self, morfs):
report.py(52):     def report_files(self, report_fn, morfs, directory=None):
annotate.py(14): os = isolate_module(os)
 --- modulename: misc, funcname: isolate_module
misc.py(28):     if mod not in ISOLATED_MODULES:
misc.py(36):     return ISOLATED_MODULES[mod]
annotate.py(17): class AnnotateReporter(Reporter):
 --- modulename: annotate, funcname: AnnotateReporter
annotate.py(17): class AnnotateReporter(Reporter):
annotate.py(37):     """
annotate.py(39):     def __init__(self, coverage, config):
annotate.py(43):     blank_re = re.compile(r"\s*(#|$)")
 --- modulename: re, funcname: compile
re.py(194):     return _compile(pattern, flags)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(240):         except KeyError:
re.py(241):             pass
re.py(242):     if isinstance(pattern, _pattern_type):
re.py(246):     if not sre_compile.isstring(pattern):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
re.py(248):     try:
re.py(249):         p = sre_compile.compile(pattern, flags)
 --- modulename: sre_compile, funcname: compile
sre_compile.py(570):     if isstring(p):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
sre_compile.py(571):         pattern = p
sre_compile.py(572):         p = sre_parse.parse(p, flags)
 --- modulename: sre_parse, funcname: parse
sre_parse.py(709):     source = Tokenizer(str)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(190):         self.string = string
sre_parse.py(191):         self.index = 0
sre_parse.py(192):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(711):     if pattern is None:
sre_parse.py(712):         pattern = Pattern()
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(68):         self.flags = 0
sre_parse.py(69):         self.open = []
sre_parse.py(70):         self.groups = 1
sre_parse.py(71):         self.groupdict = {}
sre_parse.py(72):         self.lookbehind = 0
sre_parse.py(713):     pattern.flags = flags
sre_parse.py(714):     pattern.str = str
sre_parse.py(716):     p = _parse_sub(source, pattern, 0)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(272):         return code
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(493):                 min, max = 0, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(326):             continue
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(695):             subpattern.append((AT, AT_END))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(337):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(338):     subpatternappend = subpattern.append
sre_parse.py(341):     while 1:
sre_parse.py(342):         prefix = None
sre_parse.py(343):         for item in items:
sre_parse.py(344):             if not item:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(346):             if prefix is None:
sre_parse.py(347):                 prefix = item[0]
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(343):         for item in items:
sre_parse.py(344):             if not item:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(346):             if prefix is None:
sre_parse.py(348):             elif item[0] != prefix:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(349):                 break
sre_parse.py(357):         break
sre_parse.py(360):     for item in items:
sre_parse.py(361):         if len(item) != 1 or item[0][0] != LITERAL:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(360):     for item in items:
sre_parse.py(361):         if len(item) != 1 or item[0][0] != LITERAL:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(362):             break
sre_parse.py(373):     subpattern.append((BRANCH, (None, items)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(374):     return subpattern
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(415):             break # end of pattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(328):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(718):     tail = source.get()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(719):     if tail == ")":
sre_parse.py(721):     elif tail:
sre_parse.py(724):     if flags & SRE_FLAG_DEBUG:
sre_parse.py(727):     if not (flags & SRE_FLAG_VERBOSE) and p.pattern.flags & SRE_FLAG_VERBOSE:
sre_parse.py(732):     return p
sre_compile.py(576):     code = _code(p, flags)
 --- modulename: sre_compile, funcname: _code
sre_compile.py(554):     flags = p.pattern.flags | flags
sre_compile.py(555):     code = []
sre_compile.py(558):     _compile_info(code, p, flags)
 --- modulename: sre_compile, funcname: _compile_info
sre_compile.py(437):     lo, hi = pattern.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(160):                 i = MAXREPEAT - 1
sre_parse.py(161):                 j = 0
sre_parse.py(162):                 for av in av[1]:
sre_parse.py(163):                     l, h = av.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(164):                     i = min(i, l)
sre_parse.py(165):                     j = max(j, h)
sre_parse.py(162):                 for av in av[1]:
sre_parse.py(163):                     l, h = av.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(183):             elif op == SUCCESS:
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(164):                     i = min(i, l)
sre_parse.py(165):                     j = max(j, h)
sre_parse.py(162):                 for av in av[1]:
sre_parse.py(166):                 lo = lo + i
sre_parse.py(167):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_compile.py(438):     if lo == 0:
sre_compile.py(439):         return # not worth it
sre_compile.py(561):     _compile(code, p.data, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(155):         elif op in SUCCESS_CODES:
sre_compile.py(157):         elif op in ASSERT_CODES:
sre_compile.py(170):         elif op is CALL:
sre_compile.py(176):         elif op is AT:
sre_compile.py(185):         elif op is BRANCH:
sre_compile.py(186):             emit(OPCODES[op])
sre_compile.py(187):             tail = []
sre_compile.py(188):             tailappend = tail.append
sre_compile.py(189):             for av in av[1]:
sre_compile.py(190):                 skip = _len(code); emit(0)
sre_compile.py(192):                 _compile(code, av, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(193):                 emit(OPCODES[JUMP])
sre_compile.py(194):                 tailappend(_len(code)); emit(0)
sre_compile.py(195):                 code[skip] = _len(code) - skip
sre_compile.py(189):             for av in av[1]:
sre_compile.py(190):                 skip = _len(code); emit(0)
sre_compile.py(192):                 _compile(code, av, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(155):         elif op in SUCCESS_CODES:
sre_compile.py(157):         elif op in ASSERT_CODES:
sre_compile.py(170):         elif op is CALL:
sre_compile.py(176):         elif op is AT:
sre_compile.py(177):             emit(OPCODES[op])
sre_compile.py(178):             if flags & SRE_FLAG_MULTILINE:
sre_compile.py(180):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(182):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(184):             emit(ATCODES[av])
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(193):                 emit(OPCODES[JUMP])
sre_compile.py(194):                 tailappend(_len(code)); emit(0)
sre_compile.py(195):                 code[skip] = _len(code) - skip
sre_compile.py(189):             for av in av[1]:
sre_compile.py(196):             emit(0) # end of branch
sre_compile.py(197):             for tail in tail:
sre_compile.py(198):                 code[tail] = _len(code) - tail
sre_compile.py(197):             for tail in tail:
sre_compile.py(198):                 code[tail] = _len(code) - tail
sre_compile.py(197):             for tail in tail:
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(563):     code.append(OPCODES[SUCCESS])
sre_compile.py(565):     return code
sre_compile.py(581):     if p.pattern.groups > 100:
sre_compile.py(587):     groupindex = p.pattern.groupdict
sre_compile.py(588):     indexgroup = [None] * p.pattern.groups
sre_compile.py(589):     for k, i in groupindex.items():
sre_compile.py(592):     return _sre.compile(
sre_compile.py(593):         pattern, flags | p.pattern.flags, code,
sre_compile.py(594):         p.pattern.groups-1,
sre_compile.py(595):         groupindex, indexgroup
re.py(252):     if not bypass_cache:
re.py(253):         if len(_cache) >= _MAXCACHE:
re.py(255):         if p.flags & LOCALE:
re.py(260):             loc = None
re.py(261):         _cache[cachekey] = p, loc
re.py(262):     return p
annotate.py(44):     else_re = re.compile(r"\s*else\s*:\s*(#|$)")
 --- modulename: re, funcname: compile
re.py(194):     return _compile(pattern, flags)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(240):         except KeyError:
re.py(241):             pass
re.py(242):     if isinstance(pattern, _pattern_type):
re.py(246):     if not sre_compile.isstring(pattern):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
re.py(248):     try:
re.py(249):         p = sre_compile.compile(pattern, flags)
 --- modulename: sre_compile, funcname: compile
sre_compile.py(570):     if isstring(p):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
sre_compile.py(571):         pattern = p
sre_compile.py(572):         p = sre_parse.parse(p, flags)
 --- modulename: sre_parse, funcname: parse
sre_parse.py(709):     source = Tokenizer(str)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(190):         self.string = string
sre_parse.py(191):         self.index = 0
sre_parse.py(192):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(711):     if pattern is None:
sre_parse.py(712):         pattern = Pattern()
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(68):         self.flags = 0
sre_parse.py(69):         self.open = []
sre_parse.py(70):         self.groups = 1
sre_parse.py(71):         self.groupdict = {}
sre_parse.py(72):         self.lookbehind = 0
sre_parse.py(713):     pattern.flags = flags
sre_parse.py(714):     pattern.str = str
sre_parse.py(716):     p = _parse_sub(source, pattern, 0)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(272):         return code
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(493):                 min, max = 0, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(272):         return code
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(493):                 min, max = 0, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(272):         return code
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(493):                 min, max = 0, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(326):             continue
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(695):             subpattern.append((AT, AT_END))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(337):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(338):     subpatternappend = subpattern.append
sre_parse.py(341):     while 1:
sre_parse.py(342):         prefix = None
sre_parse.py(343):         for item in items:
sre_parse.py(344):             if not item:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(346):             if prefix is None:
sre_parse.py(347):                 prefix = item[0]
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(343):         for item in items:
sre_parse.py(344):             if not item:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(346):             if prefix is None:
sre_parse.py(348):             elif item[0] != prefix:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(349):                 break
sre_parse.py(357):         break
sre_parse.py(360):     for item in items:
sre_parse.py(361):         if len(item) != 1 or item[0][0] != LITERAL:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(360):     for item in items:
sre_parse.py(361):         if len(item) != 1 or item[0][0] != LITERAL:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(362):             break
sre_parse.py(373):     subpattern.append((BRANCH, (None, items)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(374):     return subpattern
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(415):             break # end of pattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(328):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(718):     tail = source.get()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(719):     if tail == ")":
sre_parse.py(721):     elif tail:
sre_parse.py(724):     if flags & SRE_FLAG_DEBUG:
sre_parse.py(727):     if not (flags & SRE_FLAG_VERBOSE) and p.pattern.flags & SRE_FLAG_VERBOSE:
sre_parse.py(732):     return p
sre_compile.py(576):     code = _code(p, flags)
 --- modulename: sre_compile, funcname: _code
sre_compile.py(554):     flags = p.pattern.flags | flags
sre_compile.py(555):     code = []
sre_compile.py(558):     _compile_info(code, p, flags)
 --- modulename: sre_compile, funcname: _compile_info
sre_compile.py(437):     lo, hi = pattern.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(160):                 i = MAXREPEAT - 1
sre_parse.py(161):                 j = 0
sre_parse.py(162):                 for av in av[1]:
sre_parse.py(163):                     l, h = av.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(164):                     i = min(i, l)
sre_parse.py(165):                     j = max(j, h)
sre_parse.py(162):                 for av in av[1]:
sre_parse.py(163):                     l, h = av.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(183):             elif op == SUCCESS:
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(164):                     i = min(i, l)
sre_parse.py(165):                     j = max(j, h)
sre_parse.py(162):                 for av in av[1]:
sre_parse.py(166):                 lo = lo + i
sre_parse.py(167):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_compile.py(438):     if lo == 0:
sre_compile.py(441):     prefix = []
sre_compile.py(442):     prefixappend = prefix.append
sre_compile.py(443):     prefix_skip = 0
sre_compile.py(444):     charset = [] # not used
sre_compile.py(445):     charsetappend = charset.append
sre_compile.py(446):     if not (flags & SRE_FLAG_IGNORECASE):
sre_compile.py(448):         for op, av in pattern.data:
sre_compile.py(449):             if op is LITERAL:
sre_compile.py(453):             elif op is SUBPATTERN and len(av[1]) == 1:
sre_compile.py(460):                 break
sre_compile.py(462):         if not prefix and pattern.data:
sre_compile.py(463):             op, av = pattern.data[0]
sre_compile.py(464):             if op is SUBPATTERN and av[1]:
sre_compile.py(481):             elif op is BRANCH:
sre_compile.py(494):             elif op is IN:
sre_compile.py(501):     emit = code.append
sre_compile.py(502):     emit(OPCODES[INFO])
sre_compile.py(503):     skip = len(code); emit(0)
sre_compile.py(505):     mask = 0
sre_compile.py(506):     if prefix:
sre_compile.py(510):     elif charset:
sre_compile.py(512):     emit(mask)
sre_compile.py(514):     if lo < MAXCODE:
sre_compile.py(515):         emit(lo)
sre_compile.py(519):     if hi < MAXCODE:
sre_compile.py(522):         emit(0)
sre_compile.py(524):     if prefix:
sre_compile.py(535):     elif charset:
sre_compile.py(537):     code[skip] = len(code) - skip
sre_compile.py(561):     _compile(code, p.data, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(155):         elif op in SUCCESS_CODES:
sre_compile.py(157):         elif op in ASSERT_CODES:
sre_compile.py(170):         elif op is CALL:
sre_compile.py(176):         elif op is AT:
sre_compile.py(185):         elif op is BRANCH:
sre_compile.py(186):             emit(OPCODES[op])
sre_compile.py(187):             tail = []
sre_compile.py(188):             tailappend = tail.append
sre_compile.py(189):             for av in av[1]:
sre_compile.py(190):                 skip = _len(code); emit(0)
sre_compile.py(192):                 _compile(code, av, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(193):                 emit(OPCODES[JUMP])
sre_compile.py(194):                 tailappend(_len(code)); emit(0)
sre_compile.py(195):                 code[skip] = _len(code) - skip
sre_compile.py(189):             for av in av[1]:
sre_compile.py(190):                 skip = _len(code); emit(0)
sre_compile.py(192):                 _compile(code, av, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(155):         elif op in SUCCESS_CODES:
sre_compile.py(157):         elif op in ASSERT_CODES:
sre_compile.py(170):         elif op is CALL:
sre_compile.py(176):         elif op is AT:
sre_compile.py(177):             emit(OPCODES[op])
sre_compile.py(178):             if flags & SRE_FLAG_MULTILINE:
sre_compile.py(180):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(182):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(184):             emit(ATCODES[av])
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(193):                 emit(OPCODES[JUMP])
sre_compile.py(194):                 tailappend(_len(code)); emit(0)
sre_compile.py(195):                 code[skip] = _len(code) - skip
sre_compile.py(189):             for av in av[1]:
sre_compile.py(196):             emit(0) # end of branch
sre_compile.py(197):             for tail in tail:
sre_compile.py(198):                 code[tail] = _len(code) - tail
sre_compile.py(197):             for tail in tail:
sre_compile.py(198):                 code[tail] = _len(code) - tail
sre_compile.py(197):             for tail in tail:
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(563):     code.append(OPCODES[SUCCESS])
sre_compile.py(565):     return code
sre_compile.py(581):     if p.pattern.groups > 100:
sre_compile.py(587):     groupindex = p.pattern.groupdict
sre_compile.py(588):     indexgroup = [None] * p.pattern.groups
sre_compile.py(589):     for k, i in groupindex.items():
sre_compile.py(592):     return _sre.compile(
sre_compile.py(593):         pattern, flags | p.pattern.flags, code,
sre_compile.py(594):         p.pattern.groups-1,
sre_compile.py(595):         groupindex, indexgroup
re.py(252):     if not bypass_cache:
re.py(253):         if len(_cache) >= _MAXCACHE:
re.py(255):         if p.flags & LOCALE:
re.py(260):             loc = None
re.py(261):         _cache[cachekey] = p, loc
re.py(262):     return p
annotate.py(46):     def report(self, morfs, directory=None):
annotate.py(54):     def annotate_file(self, fr, analysis):
control.py(16): from coverage.backward import string_class, iitems
control.py(17): from coverage.collector import Collector
 --- modulename: collector, funcname: <module>
collector.py(4): """Raw data collector for coverage.py."""
collector.py(6): import os
collector.py(7): import sys
collector.py(9): from coverage import env
collector.py(10): from coverage.backward import iitems
collector.py(11): from coverage.files import abs_file
collector.py(12): from coverage.misc import CoverageException, isolate_module
collector.py(13): from coverage.pytracer import PyTracer
 --- modulename: pytracer, funcname: <module>
pytracer.py(4): """Raw data collector for coverage.py."""
pytracer.py(6): import dis
pytracer.py(7): import sys
pytracer.py(9): from coverage import env
pytracer.py(12): YIELD_VALUE = dis.opmap['YIELD_VALUE']
pytracer.py(13): if env.PY2:
pytracer.py(14):     YIELD_VALUE = chr(YIELD_VALUE)
pytracer.py(17): class PyTracer(object):
 --- modulename: pytracer, funcname: PyTracer
pytracer.py(17): class PyTracer(object):
pytracer.py(18):     """Python implementation of the raw data tracer."""
pytracer.py(36):     def __init__(self):
pytracer.py(55):     def __repr__(self):
pytracer.py(62):     def _trace(self, frame, event, arg_unused):
pytracer.py(122):     def start(self):
pytracer.py(134):     def stop(self):
pytracer.py(150):     def get_stats(self):
collector.py(15): os = isolate_module(os)
 --- modulename: misc, funcname: isolate_module
misc.py(28):     if mod not in ISOLATED_MODULES:
misc.py(36):     return ISOLATED_MODULES[mod]
collector.py(18): try:
collector.py(20):     from coverage.tracer import CTracer, CFileDisposition   # pylint: disable=no-name-in-module
collector.py(35): class FileDisposition(object):
 --- modulename: collector, funcname: FileDisposition
collector.py(35): class FileDisposition(object):
collector.py(36):     """A simple value type for recording what to do with a file."""
collector.py(37):     pass
collector.py(40): class Collector(object):
 --- modulename: collector, funcname: Collector
collector.py(40): class Collector(object):
collector.py(54):     """
collector.py(59):     _collectors = []
collector.py(61):     def __init__(self, should_trace, check_include, timid, branch, warn, concurrency):
collector.py(136):     def __repr__(self):
collector.py(139):     def tracer_name(self):
collector.py(143):     def reset(self):
collector.py(185):     def _start_tracer(self):
collector.py(221):     def _installation_trace(self, frame, event, arg):
collector.py(234):     def start(self):
collector.py(273):     def stop(self):
collector.py(289):     def pause(self):
collector.py(301):     def resume(self):
collector.py(310):     def save_data(self, covdata):
control.py(18): from coverage.config import CoverageConfig
 --- modulename: config, funcname: <module>
config.py(4): """Config file for coverage.py"""
config.py(6): import collections
config.py(7): import os
config.py(8): import re
config.py(9): import sys
config.py(11): from coverage.backward import configparser, iitems, string_class
config.py(12): from coverage.misc import CoverageException, isolate_module
config.py(14): os = isolate_module(os)
 --- modulename: misc, funcname: isolate_module
misc.py(28):     if mod not in ISOLATED_MODULES:
misc.py(36):     return ISOLATED_MODULES[mod]
config.py(17): class HandyConfigParser(configparser.RawConfigParser):
 --- modulename: config, funcname: HandyConfigParser
config.py(17): class HandyConfigParser(configparser.RawConfigParser):
config.py(18):     """Our specialization of ConfigParser."""
config.py(20):     def __init__(self, section_prefix):
config.py(24):     def read(self, filename):
config.py(31):     def has_option(self, section, option):
config.py(35):     def has_section(self, section):
config.py(39):     def options(self, section):
config.py(43):     def get_section(self, section):
config.py(50):     def get(self, section, *args, **kwargs):
config.py(81):     def getlist(self, section, option):
config.py(99):     def getregexlist(self, section, option):
config.py(125):     r'(?i)#\s*pragma[:\s]?\s*no\s*cover',
config.py(130):     r'(?i)#\s*pragma[:\s]?\s*no\s*branch',
config.py(137):     'while (True|1|False|0):',
config.py(138):     'if (True|1|False|0):',
config.py(142): class CoverageConfig(object):
 --- modulename: config, funcname: CoverageConfig
config.py(142): class CoverageConfig(object):
config.py(148):     """
config.py(149):     def __init__(self):
config.py(194):     MUST_BE_LIST = ["omit", "include", "debug", "plugins"]
config.py(196):     def from_args(self, **kwargs):
config.py(204):     def from_file(self, filename, section_prefix=""):
config.py(269):         ('branch', 'run:branch', 'boolean'),
config.py(270):         ('concurrency', 'run:concurrency'),
config.py(271):         ('cover_pylib', 'run:cover_pylib', 'boolean'),
config.py(272):         ('data_file', 'run:data_file'),
config.py(273):         ('debug', 'run:debug', 'list'),
config.py(274):         ('include', 'run:include', 'list'),
config.py(275):         ('note', 'run:note'),
config.py(276):         ('omit', 'run:omit', 'list'),
config.py(277):         ('parallel', 'run:parallel', 'boolean'),
config.py(278):         ('plugins', 'run:plugins', 'list'),
config.py(279):         ('source', 'run:source', 'list'),
config.py(280):         ('timid', 'run:timid', 'boolean'),
config.py(283):         ('exclude_list', 'report:exclude_lines', 'regexlist'),
config.py(284):         ('fail_under', 'report:fail_under', 'int'),
config.py(285):         ('ignore_errors', 'report:ignore_errors', 'boolean'),
config.py(286):         ('include', 'report:include', 'list'),
config.py(287):         ('omit', 'report:omit', 'list'),
config.py(288):         ('partial_always_list', 'report:partial_branches_always', 'regexlist'),
config.py(289):         ('partial_list', 'report:partial_branches', 'regexlist'),
config.py(290):         ('precision', 'report:precision', 'int'),
config.py(291):         ('show_missing', 'report:show_missing', 'boolean'),
config.py(292):         ('skip_covered', 'report:skip_covered', 'boolean'),
config.py(295):         ('extra_css', 'html:extra_css'),
config.py(296):         ('html_dir', 'html:directory'),
config.py(297):         ('html_title', 'html:title'),
config.py(300):         ('xml_output', 'xml:output'),
config.py(301):         ('xml_package_depth', 'xml:package_depth', 'int'),
config.py(304):     def _set_attr_from_config_option(self, cp, attr, where, type_=''):
config.py(311):     def get_plugin_options(self, plugin):
config.py(315):     def set_option(self, option_name, value):
config.py(342):     def get_option(self, option_name):
control.py(19): from coverage.data import CoverageData, CoverageDataFiles
 --- modulename: data, funcname: <module>
data.py(4): """Coverage data for coverage.py."""
data.py(6): import glob
 --- modulename: glob, funcname: <module>
glob.py(1): """Filename globbing utility."""
glob.py(3): import sys
glob.py(4): import os
glob.py(5): import re
glob.py(6): import fnmatch
glob.py(8): try:
glob.py(9):     _unicode = unicode
glob.py(16): __all__ = ["glob", "iglob"]
glob.py(18): def glob(pathname):
glob.py(29): def iglob(pathname):
glob.py(71): def glob1(dirname, pattern):
glob.py(85): def glob0(dirname, basename):
glob.py(97): magic_check = re.compile('[*?[]')
 --- modulename: re, funcname: compile
re.py(194):     return _compile(pattern, flags)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(240):         except KeyError:
re.py(241):             pass
re.py(242):     if isinstance(pattern, _pattern_type):
re.py(246):     if not sre_compile.isstring(pattern):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
re.py(248):     try:
re.py(249):         p = sre_compile.compile(pattern, flags)
 --- modulename: sre_compile, funcname: compile
sre_compile.py(570):     if isstring(p):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
sre_compile.py(571):         pattern = p
sre_compile.py(572):         p = sre_parse.parse(p, flags)
 --- modulename: sre_parse, funcname: parse
sre_parse.py(709):     source = Tokenizer(str)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(190):         self.string = string
sre_parse.py(191):         self.index = 0
sre_parse.py(192):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(711):     if pattern is None:
sre_parse.py(712):         pattern = Pattern()
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(68):         self.flags = 0
sre_parse.py(69):         self.open = []
sre_parse.py(70):         self.groups = 1
sre_parse.py(71):         self.groupdict = {}
sre_parse.py(72):         self.lookbehind = 0
sre_parse.py(713):     pattern.flags = flags
sre_parse.py(714):     pattern.str = str
sre_parse.py(716):     p = _parse_sub(source, pattern, 0)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(415):             break # end of pattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(328):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(718):     tail = source.get()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(719):     if tail == ")":
sre_parse.py(721):     elif tail:
sre_parse.py(724):     if flags & SRE_FLAG_DEBUG:
sre_parse.py(727):     if not (flags & SRE_FLAG_VERBOSE) and p.pattern.flags & SRE_FLAG_VERBOSE:
sre_parse.py(732):     return p
sre_compile.py(576):     code = _code(p, flags)
 --- modulename: sre_compile, funcname: _code
sre_compile.py(554):     flags = p.pattern.flags | flags
sre_compile.py(555):     code = []
sre_compile.py(558):     _compile_info(code, p, flags)
 --- modulename: sre_compile, funcname: _compile_info
sre_compile.py(437):     lo, hi = pattern.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_compile.py(438):     if lo == 0:
sre_compile.py(441):     prefix = []
sre_compile.py(442):     prefixappend = prefix.append
sre_compile.py(443):     prefix_skip = 0
sre_compile.py(444):     charset = [] # not used
sre_compile.py(445):     charsetappend = charset.append
sre_compile.py(446):     if not (flags & SRE_FLAG_IGNORECASE):
sre_compile.py(448):         for op, av in pattern.data:
sre_compile.py(449):             if op is LITERAL:
sre_compile.py(453):             elif op is SUBPATTERN and len(av[1]) == 1:
sre_compile.py(460):                 break
sre_compile.py(462):         if not prefix and pattern.data:
sre_compile.py(463):             op, av = pattern.data[0]
sre_compile.py(464):             if op is SUBPATTERN and av[1]:
sre_compile.py(481):             elif op is BRANCH:
sre_compile.py(494):             elif op is IN:
sre_compile.py(495):                 charset = av
sre_compile.py(501):     emit = code.append
sre_compile.py(502):     emit(OPCODES[INFO])
sre_compile.py(503):     skip = len(code); emit(0)
sre_compile.py(505):     mask = 0
sre_compile.py(506):     if prefix:
sre_compile.py(510):     elif charset:
sre_compile.py(511):         mask = mask + SRE_INFO_CHARSET
sre_compile.py(512):     emit(mask)
sre_compile.py(514):     if lo < MAXCODE:
sre_compile.py(515):         emit(lo)
sre_compile.py(519):     if hi < MAXCODE:
sre_compile.py(520):         emit(hi)
sre_compile.py(524):     if prefix:
sre_compile.py(535):     elif charset:
sre_compile.py(536):         _compile_charset(charset, flags, code)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(320):             runs = None
sre_compile.py(321):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(342):     if len(charmap) == 256:
sre_compile.py(343):         data = _mk_bitmap(charmap)
 --- modulename: sre_compile, funcname: _mk_bitmap
sre_compile.py(412):     s = bytes(bits).translate(_BITS_TRANS)[::-1]
sre_compile.py(413):     return [_int(s[i - _CODEBITS: i], 2)
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(344):         out.append((CHARSET, data))
sre_compile.py(345):         out += tail
sre_compile.py(346):         return out
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(242):             code.extend(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(537):     code[skip] = len(code) - skip
sre_compile.py(561):     _compile(code, p.data, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(320):             runs = None
sre_compile.py(321):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(342):     if len(charmap) == 256:
sre_compile.py(343):         data = _mk_bitmap(charmap)
 --- modulename: sre_compile, funcname: _mk_bitmap
sre_compile.py(412):     s = bytes(bits).translate(_BITS_TRANS)[::-1]
sre_compile.py(413):     return [_int(s[i - _CODEBITS: i], 2)
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(344):         out.append((CHARSET, data))
sre_compile.py(345):         out += tail
sre_compile.py(346):         return out
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(242):             code.extend(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(563):     code.append(OPCODES[SUCCESS])
sre_compile.py(565):     return code
sre_compile.py(581):     if p.pattern.groups > 100:
sre_compile.py(587):     groupindex = p.pattern.groupdict
sre_compile.py(588):     indexgroup = [None] * p.pattern.groups
sre_compile.py(589):     for k, i in groupindex.items():
sre_compile.py(592):     return _sre.compile(
sre_compile.py(593):         pattern, flags | p.pattern.flags, code,
sre_compile.py(594):         p.pattern.groups-1,
sre_compile.py(595):         groupindex, indexgroup
re.py(252):     if not bypass_cache:
re.py(253):         if len(_cache) >= _MAXCACHE:
re.py(255):         if p.flags & LOCALE:
re.py(260):             loc = None
re.py(261):         _cache[cachekey] = p, loc
re.py(262):     return p
glob.py(99): def has_magic(s):
data.py(7): import json
 --- modulename: __init__, funcname: <module>
__init__.py(99): """
__init__.py(100): __version__ = '2.0.9'
__init__.py(102):     'dump', 'dumps', 'load', 'loads',
__init__.py(103):     'JSONDecoder', 'JSONEncoder',
__init__.py(106): __author__ = 'Bob Ippolito <bob@redivi.com>'
__init__.py(108): from .decoder import JSONDecoder
 --- modulename: decoder, funcname: <module>
decoder.py(2): """
decoder.py(3): import re
decoder.py(4): import sys
decoder.py(5): import struct
 --- modulename: struct, funcname: <module>
struct.py(1): from _struct import *
struct.py(2): from _struct import _clearcache
struct.py(3): from _struct import __doc__
decoder.py(7): from json import scanner
 --- modulename: scanner, funcname: <module>
scanner.py(2): """
scanner.py(3): import re
scanner.py(4): try:
scanner.py(5):     from _json import make_scanner as c_make_scanner
scanner.py(9): __all__ = ['make_scanner']
scanner.py(11): NUMBER_RE = re.compile(
scanner.py(12):     r'(-?(?:0|[1-9]\d*))(\.\d+)?([eE][-+]?\d+)?',
scanner.py(13):     (re.VERBOSE | re.MULTILINE | re.DOTALL))
 --- modulename: re, funcname: compile
re.py(194):     return _compile(pattern, flags)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(240):         except KeyError:
re.py(241):             pass
re.py(242):     if isinstance(pattern, _pattern_type):
re.py(246):     if not sre_compile.isstring(pattern):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
re.py(248):     try:
re.py(249):         p = sre_compile.compile(pattern, flags)
 --- modulename: sre_compile, funcname: compile
sre_compile.py(570):     if isstring(p):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
sre_compile.py(571):         pattern = p
sre_compile.py(572):         p = sre_parse.parse(p, flags)
 --- modulename: sre_parse, funcname: parse
sre_parse.py(709):     source = Tokenizer(str)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(190):         self.string = string
sre_parse.py(191):         self.index = 0
sre_parse.py(192):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(711):     if pattern is None:
sre_parse.py(712):         pattern = Pattern()
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(68):         self.flags = 0
sre_parse.py(69):         self.open = []
sre_parse.py(70):         self.groups = 1
sre_parse.py(71):         self.groupdict = {}
sre_parse.py(72):         self.lookbehind = 0
sre_parse.py(713):     pattern.flags = flags
sre_parse.py(714):     pattern.str = str
sre_parse.py(716):     p = _parse_sub(source, pattern, 0)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(419):             if this in WHITESPACE:
sre_parse.py(421):             if this == "#":
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(419):             if this in WHITESPACE:
sre_parse.py(421):             if this == "#":
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(419):             if this in WHITESPACE:
sre_parse.py(421):             if this == "#":
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(491):                 min, max = 0, 1
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(419):             if this in WHITESPACE:
sre_parse.py(421):             if this == "#":
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(549):                 group = 0
sre_parse.py(551):                 if sourcematch("P"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(600):                 elif sourcematch(":"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(602):                     group = 2
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(670):                     group = None
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(419):             if this in WHITESPACE:
sre_parse.py(421):             if this == "#":
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(326):             continue
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(419):             if this in WHITESPACE:
sre_parse.py(421):             if this == "#":
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(453):                     this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(454):                     if this == "]":
sre_parse.py(460):                     elif this:
sre_parse.py(461):                         if this[0] == "\\":
sre_parse.py(464):                             code2 = LITERAL, ord(this)
sre_parse.py(465):                         if code1[0] != LITERAL or code2[0] != LITERAL:
sre_parse.py(467):                         lo = code1[1]
sre_parse.py(468):                         hi = code2[1]
sre_parse.py(469):                         if hi < lo:
sre_parse.py(471):                         setappend((RANGE, (lo, hi)))
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(419):             if this in WHITESPACE:
sre_parse.py(421):             if this == "#":
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(272):         return code
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(419):             if this in WHITESPACE:
sre_parse.py(421):             if this == "#":
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(493):                 min, max = 0, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(337):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(338):     subpatternappend = subpattern.append
sre_parse.py(341):     while 1:
sre_parse.py(342):         prefix = None
sre_parse.py(343):         for item in items:
sre_parse.py(344):             if not item:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(346):             if prefix is None:
sre_parse.py(347):                 prefix = item[0]
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(343):         for item in items:
sre_parse.py(344):             if not item:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(346):             if prefix is None:
sre_parse.py(348):             elif item[0] != prefix:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(349):                 break
sre_parse.py(357):         break
sre_parse.py(360):     for item in items:
sre_parse.py(361):         if len(item) != 1 or item[0][0] != LITERAL:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(360):     for item in items:
sre_parse.py(361):         if len(item) != 1 or item[0][0] != LITERAL:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(362):             break
sre_parse.py(373):     subpattern.append((BRANCH, (None, items)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(374):     return subpattern
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(419):             if this in WHITESPACE:
sre_parse.py(421):             if this == "#":
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(419):             if this in WHITESPACE:
sre_parse.py(421):             if this == "#":
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(273):     code = ESCAPES.get(escape)
sre_parse.py(274):     if code:
sre_parse.py(276):     try:
sre_parse.py(277):         c = escape[1:2]
sre_parse.py(278):         if c == "x":
sre_parse.py(285):         elif c == "0":
sre_parse.py(290):         elif c in DIGITS:
sre_parse.py(311):         if len(escape) == 2:
sre_parse.py(312):             return LITERAL, ord(escape[1])
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(419):             if this in WHITESPACE:
sre_parse.py(421):             if this == "#":
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(272):         return code
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(419):             if this in WHITESPACE:
sre_parse.py(421):             if this == "#":
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(495):             elif this == "+":
sre_parse.py(496):                 min, max = 1, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(419):             if this in WHITESPACE:
sre_parse.py(421):             if this == "#":
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(491):                 min, max = 0, 1
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(419):             if this in WHITESPACE:
sre_parse.py(421):             if this == "#":
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(419):             if this in WHITESPACE:
sre_parse.py(421):             if this == "#":
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(419):             if this in WHITESPACE:
sre_parse.py(421):             if this == "#":
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(419):             if this in WHITESPACE:
sre_parse.py(421):             if this == "#":
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(491):                 min, max = 0, 1
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(419):             if this in WHITESPACE:
sre_parse.py(421):             if this == "#":
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(272):         return code
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(419):             if this in WHITESPACE:
sre_parse.py(421):             if this == "#":
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(495):             elif this == "+":
sre_parse.py(496):                 min, max = 1, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(419):             if this in WHITESPACE:
sre_parse.py(421):             if this == "#":
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(491):                 min, max = 0, 1
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(415):             break # end of pattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(328):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(718):     tail = source.get()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(719):     if tail == ")":
sre_parse.py(721):     elif tail:
sre_parse.py(724):     if flags & SRE_FLAG_DEBUG:
sre_parse.py(727):     if not (flags & SRE_FLAG_VERBOSE) and p.pattern.flags & SRE_FLAG_VERBOSE:
sre_parse.py(732):     return p
sre_compile.py(576):     code = _code(p, flags)
 --- modulename: sre_compile, funcname: _code
sre_compile.py(554):     flags = p.pattern.flags | flags
sre_compile.py(555):     code = []
sre_compile.py(558):     _compile_info(code, p, flags)
 --- modulename: sre_compile, funcname: _compile_info
sre_compile.py(437):     lo, hi = pattern.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(160):                 i = MAXREPEAT - 1
sre_parse.py(161):                 j = 0
sre_parse.py(162):                 for av in av[1]:
sre_parse.py(163):                     l, h = av.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(164):                     i = min(i, l)
sre_parse.py(165):                     j = max(j, h)
sre_parse.py(162):                 for av in av[1]:
sre_parse.py(163):                     l, h = av.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(164):                     i = min(i, l)
sre_parse.py(165):                     j = max(j, h)
sre_parse.py(162):                 for av in av[1]:
sre_parse.py(166):                 lo = lo + i
sre_parse.py(167):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_compile.py(438):     if lo == 0:
sre_compile.py(441):     prefix = []
sre_compile.py(442):     prefixappend = prefix.append
sre_compile.py(443):     prefix_skip = 0
sre_compile.py(444):     charset = [] # not used
sre_compile.py(445):     charsetappend = charset.append
sre_compile.py(446):     if not (flags & SRE_FLAG_IGNORECASE):
sre_compile.py(448):         for op, av in pattern.data:
sre_compile.py(449):             if op is LITERAL:
sre_compile.py(453):             elif op is SUBPATTERN and len(av[1]) == 1:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_compile.py(460):                 break
sre_compile.py(462):         if not prefix and pattern.data:
sre_compile.py(463):             op, av = pattern.data[0]
sre_compile.py(464):             if op is SUBPATTERN and av[1]:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_compile.py(465):                 op, av = av[1][0]
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(466):                 if op is LITERAL:
sre_compile.py(468):                 elif op is BRANCH:
sre_compile.py(501):     emit = code.append
sre_compile.py(502):     emit(OPCODES[INFO])
sre_compile.py(503):     skip = len(code); emit(0)
sre_compile.py(505):     mask = 0
sre_compile.py(506):     if prefix:
sre_compile.py(510):     elif charset:
sre_compile.py(512):     emit(mask)
sre_compile.py(514):     if lo < MAXCODE:
sre_compile.py(515):         emit(lo)
sre_compile.py(519):     if hi < MAXCODE:
sre_compile.py(522):         emit(0)
sre_compile.py(524):     if prefix:
sre_compile.py(535):     elif charset:
sre_compile.py(537):     code[skip] = len(code) - skip
sre_compile.py(561):     _compile(code, p.data, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(155):         elif op in SUCCESS_CODES:
sre_compile.py(157):         elif op in ASSERT_CODES:
sre_compile.py(170):         elif op is CALL:
sre_compile.py(176):         elif op is AT:
sre_compile.py(185):         elif op is BRANCH:
sre_compile.py(186):             emit(OPCODES[op])
sre_compile.py(187):             tail = []
sre_compile.py(188):             tailappend = tail.append
sre_compile.py(189):             for av in av[1]:
sre_compile.py(190):                 skip = _len(code); emit(0)
sre_compile.py(192):                 _compile(code, av, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(193):                 emit(OPCODES[JUMP])
sre_compile.py(194):                 tailappend(_len(code)); emit(0)
sre_compile.py(195):                 code[skip] = _len(code) - skip
sre_compile.py(189):             for av in av[1]:
sre_compile.py(190):                 skip = _len(code); emit(0)
sre_compile.py(192):                 _compile(code, av, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(274):                     r = range(av[0], av[1]+1)
sre_compile.py(275):                     if fixup:
sre_compile.py(277):                     if fixup and fixes:
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(333):                 out.append((RANGE, (p, q - 1)))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(239):             emit(av[0])
sre_compile.py(240):             emit(av[1])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(193):                 emit(OPCODES[JUMP])
sre_compile.py(194):                 tailappend(_len(code)); emit(0)
sre_compile.py(195):                 code[skip] = _len(code) - skip
sre_compile.py(189):             for av in av[1]:
sre_compile.py(196):             emit(0) # end of branch
sre_compile.py(197):             for tail in tail:
sre_compile.py(198):                 code[tail] = _len(code) - tail
sre_compile.py(197):             for tail in tail:
sre_compile.py(198):                 code[tail] = _len(code) - tail
sre_compile.py(197):             for tail in tail:
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
sre_compile.py(136):                 emit(OPCODES[REPEAT])
sre_compile.py(137):                 skip = _len(code); emit(0)
sre_compile.py(138):                 emit(av[0])
sre_compile.py(139):                 emit(av[1])
sre_compile.py(140):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(141):                 code[skip] = _len(code) - skip
sre_compile.py(142):                 if op is MAX_REPEAT:
sre_compile.py(143):                     emit(OPCODES[MAX_UNTIL])
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
sre_compile.py(136):                 emit(OPCODES[REPEAT])
sre_compile.py(137):                 skip = _len(code); emit(0)
sre_compile.py(138):                 emit(av[0])
sre_compile.py(139):                 emit(av[1])
sre_compile.py(140):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(141):                 code[skip] = _len(code) - skip
sre_compile.py(142):                 if op is MAX_REPEAT:
sre_compile.py(143):                     emit(OPCODES[MAX_UNTIL])
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(563):     code.append(OPCODES[SUCCESS])
sre_compile.py(565):     return code
sre_compile.py(581):     if p.pattern.groups > 100:
sre_compile.py(587):     groupindex = p.pattern.groupdict
sre_compile.py(588):     indexgroup = [None] * p.pattern.groups
sre_compile.py(589):     for k, i in groupindex.items():
sre_compile.py(592):     return _sre.compile(
sre_compile.py(593):         pattern, flags | p.pattern.flags, code,
sre_compile.py(594):         p.pattern.groups-1,
sre_compile.py(595):         groupindex, indexgroup
re.py(252):     if not bypass_cache:
re.py(253):         if len(_cache) >= _MAXCACHE:
re.py(255):         if p.flags & LOCALE:
re.py(260):             loc = None
re.py(261):         _cache[cachekey] = p, loc
re.py(262):     return p
scanner.py(15): def py_make_scanner(context):
scanner.py(67): make_scanner = c_make_scanner or py_make_scanner
decoder.py(8): try:
decoder.py(9):     from _json import scanstring as c_scanstring
decoder.py(13): __all__ = ['JSONDecoder']
decoder.py(15): FLAGS = re.VERBOSE | re.MULTILINE | re.DOTALL
decoder.py(17): def _floatconstants():
decoder.py(22): NaN, PosInf, NegInf = _floatconstants()
 --- modulename: decoder, funcname: _floatconstants
decoder.py(18):     nan, = struct.unpack('>d', b'\x7f\xf8\x00\x00\x00\x00\x00\x00')
decoder.py(19):     inf, = struct.unpack('>d', b'\x7f\xf0\x00\x00\x00\x00\x00\x00')
decoder.py(20):     return nan, inf, -inf
decoder.py(25): def linecol(doc, pos):
decoder.py(34): def errmsg(msg, doc, pos, end=None):
decoder.py(49): _CONSTANTS = {
decoder.py(50):     '-Infinity': NegInf,
decoder.py(51):     'Infinity': PosInf,
decoder.py(52):     'NaN': NaN,
decoder.py(55): STRINGCHUNK = re.compile(r'(.*?)(["\\\x00-\x1f])', FLAGS)
 --- modulename: re, funcname: compile
re.py(194):     return _compile(pattern, flags)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(240):         except KeyError:
re.py(241):             pass
re.py(242):     if isinstance(pattern, _pattern_type):
re.py(246):     if not sre_compile.isstring(pattern):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
re.py(248):     try:
re.py(249):         p = sre_compile.compile(pattern, flags)
 --- modulename: sre_compile, funcname: compile
sre_compile.py(570):     if isstring(p):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
sre_compile.py(571):         pattern = p
sre_compile.py(572):         p = sre_parse.parse(p, flags)
 --- modulename: sre_parse, funcname: parse
sre_parse.py(709):     source = Tokenizer(str)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(190):         self.string = string
sre_parse.py(191):         self.index = 0
sre_parse.py(192):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(711):     if pattern is None:
sre_parse.py(712):         pattern = Pattern()
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(68):         self.flags = 0
sre_parse.py(69):         self.open = []
sre_parse.py(70):         self.groups = 1
sre_parse.py(71):         self.groupdict = {}
sre_parse.py(72):         self.lookbehind = 0
sre_parse.py(713):     pattern.flags = flags
sre_parse.py(714):     pattern.str = str
sre_parse.py(716):     p = _parse_sub(source, pattern, 0)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(419):             if this in WHITESPACE:
sre_parse.py(421):             if this == "#":
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(419):             if this in WHITESPACE:
sre_parse.py(421):             if this == "#":
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(542):             subpatternappend((ANY, None))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(419):             if this in WHITESPACE:
sre_parse.py(421):             if this == "#":
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(493):                 min, max = 0, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(537):                 subpattern[-1] = (MIN_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(419):             if this in WHITESPACE:
sre_parse.py(421):             if this == "#":
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(419):             if this in WHITESPACE:
sre_parse.py(421):             if this == "#":
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(240):         return code
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(241):     code = CATEGORIES.get(escape)
sre_parse.py(242):     if code and code[0] == IN:
sre_parse.py(244):     try:
sre_parse.py(245):         c = escape[1:2]
sre_parse.py(246):         if c == "x":
sre_parse.py(248):             while source.next in HEXDIGITS and len(escape) < 4:
sre_parse.py(249):                 escape = escape + source.get()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(248):             while source.next in HEXDIGITS and len(escape) < 4:
sre_parse.py(249):                 escape = escape + source.get()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(248):             while source.next in HEXDIGITS and len(escape) < 4:
sre_parse.py(250):             escape = escape[2:]
sre_parse.py(251):             if len(escape) != 2:
sre_parse.py(253):             return LITERAL, int(escape, 16) & 0xff
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(453):                     this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(454):                     if this == "]":
sre_parse.py(460):                     elif this:
sre_parse.py(461):                         if this[0] == "\\":
sre_parse.py(462):                             code2 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(241):     code = CATEGORIES.get(escape)
sre_parse.py(242):     if code and code[0] == IN:
sre_parse.py(244):     try:
sre_parse.py(245):         c = escape[1:2]
sre_parse.py(246):         if c == "x":
sre_parse.py(248):             while source.next in HEXDIGITS and len(escape) < 4:
sre_parse.py(249):                 escape = escape + source.get()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(248):             while source.next in HEXDIGITS and len(escape) < 4:
sre_parse.py(249):                 escape = escape + source.get()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(248):             while source.next in HEXDIGITS and len(escape) < 4:
sre_parse.py(250):             escape = escape[2:]
sre_parse.py(251):             if len(escape) != 2:
sre_parse.py(253):             return LITERAL, int(escape, 16) & 0xff
sre_parse.py(465):                         if code1[0] != LITERAL or code2[0] != LITERAL:
sre_parse.py(467):                         lo = code1[1]
sre_parse.py(468):                         hi = code2[1]
sre_parse.py(469):                         if hi < lo:
sre_parse.py(471):                         setappend((RANGE, (lo, hi)))
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(415):             break # end of pattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(328):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(718):     tail = source.get()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(719):     if tail == ")":
sre_parse.py(721):     elif tail:
sre_parse.py(724):     if flags & SRE_FLAG_DEBUG:
sre_parse.py(727):     if not (flags & SRE_FLAG_VERBOSE) and p.pattern.flags & SRE_FLAG_VERBOSE:
sre_parse.py(732):     return p
sre_compile.py(576):     code = _code(p, flags)
 --- modulename: sre_compile, funcname: _code
sre_compile.py(554):     flags = p.pattern.flags | flags
sre_compile.py(555):     code = []
sre_compile.py(558):     _compile_info(code, p, flags)
 --- modulename: sre_compile, funcname: _compile_info
sre_compile.py(437):     lo, hi = pattern.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_compile.py(438):     if lo == 0:
sre_compile.py(441):     prefix = []
sre_compile.py(442):     prefixappend = prefix.append
sre_compile.py(443):     prefix_skip = 0
sre_compile.py(444):     charset = [] # not used
sre_compile.py(445):     charsetappend = charset.append
sre_compile.py(446):     if not (flags & SRE_FLAG_IGNORECASE):
sre_compile.py(448):         for op, av in pattern.data:
sre_compile.py(449):             if op is LITERAL:
sre_compile.py(453):             elif op is SUBPATTERN and len(av[1]) == 1:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_compile.py(454):                 op, av = av[1][0]
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(455):                 if op is LITERAL:
sre_compile.py(458):                     break
sre_compile.py(462):         if not prefix and pattern.data:
sre_compile.py(463):             op, av = pattern.data[0]
sre_compile.py(464):             if op is SUBPATTERN and av[1]:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_compile.py(465):                 op, av = av[1][0]
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(466):                 if op is LITERAL:
sre_compile.py(468):                 elif op is BRANCH:
sre_compile.py(501):     emit = code.append
sre_compile.py(502):     emit(OPCODES[INFO])
sre_compile.py(503):     skip = len(code); emit(0)
sre_compile.py(505):     mask = 0
sre_compile.py(506):     if prefix:
sre_compile.py(510):     elif charset:
sre_compile.py(512):     emit(mask)
sre_compile.py(514):     if lo < MAXCODE:
sre_compile.py(515):         emit(lo)
sre_compile.py(519):     if hi < MAXCODE:
sre_compile.py(522):         emit(0)
sre_compile.py(524):     if prefix:
sre_compile.py(535):     elif charset:
sre_compile.py(537):     code[skip] = len(code) - skip
sre_compile.py(561):     _compile(code, p.data, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(128):                     emit(OPCODES[MIN_REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(110):             if flags & SRE_FLAG_DOTALL:
sre_compile.py(111):                 emit(OPCODES[ANY_ALL])
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(274):                     r = range(av[0], av[1]+1)
sre_compile.py(275):                     if fixup:
sre_compile.py(277):                     if fixup and fixes:
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(320):             runs = None
sre_compile.py(321):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(342):     if len(charmap) == 256:
sre_compile.py(343):         data = _mk_bitmap(charmap)
 --- modulename: sre_compile, funcname: _mk_bitmap
sre_compile.py(412):     s = bytes(bits).translate(_BITS_TRANS)[::-1]
sre_compile.py(413):     return [_int(s[i - _CODEBITS: i], 2)
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(344):         out.append((CHARSET, data))
sre_compile.py(345):         out += tail
sre_compile.py(346):         return out
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(242):             code.extend(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(563):     code.append(OPCODES[SUCCESS])
sre_compile.py(565):     return code
sre_compile.py(581):     if p.pattern.groups > 100:
sre_compile.py(587):     groupindex = p.pattern.groupdict
sre_compile.py(588):     indexgroup = [None] * p.pattern.groups
sre_compile.py(589):     for k, i in groupindex.items():
sre_compile.py(592):     return _sre.compile(
sre_compile.py(593):         pattern, flags | p.pattern.flags, code,
sre_compile.py(594):         p.pattern.groups-1,
sre_compile.py(595):         groupindex, indexgroup
re.py(252):     if not bypass_cache:
re.py(253):         if len(_cache) >= _MAXCACHE:
re.py(255):         if p.flags & LOCALE:
re.py(260):             loc = None
re.py(261):         _cache[cachekey] = p, loc
re.py(262):     return p
decoder.py(56): BACKSLASH = {
decoder.py(57):     '"': u'"', '\\': u'\\', '/': u'/',
decoder.py(58):     'b': u'\b', 'f': u'\f', 'n': u'\n', 'r': u'\r', 't': u'\t',
decoder.py(61): DEFAULT_ENCODING = "utf-8"
decoder.py(63): def _decode_uXXXX(s, pos):
decoder.py(73): def py_scanstring(s, end, encoding=None, strict=True,
decoder.py(74):         _b=BACKSLASH, _m=STRINGCHUNK.match):
decoder.py(143): scanstring = c_scanstring or py_scanstring
decoder.py(145): WHITESPACE = re.compile(r'[ \t\n\r]*', FLAGS)
 --- modulename: re, funcname: compile
re.py(194):     return _compile(pattern, flags)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(240):         except KeyError:
re.py(241):             pass
re.py(242):     if isinstance(pattern, _pattern_type):
re.py(246):     if not sre_compile.isstring(pattern):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
re.py(248):     try:
re.py(249):         p = sre_compile.compile(pattern, flags)
 --- modulename: sre_compile, funcname: compile
sre_compile.py(570):     if isstring(p):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
sre_compile.py(571):         pattern = p
sre_compile.py(572):         p = sre_parse.parse(p, flags)
 --- modulename: sre_parse, funcname: parse
sre_parse.py(709):     source = Tokenizer(str)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(190):         self.string = string
sre_parse.py(191):         self.index = 0
sre_parse.py(192):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(711):     if pattern is None:
sre_parse.py(712):         pattern = Pattern()
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(68):         self.flags = 0
sre_parse.py(69):         self.open = []
sre_parse.py(70):         self.groups = 1
sre_parse.py(71):         self.groupdict = {}
sre_parse.py(72):         self.lookbehind = 0
sre_parse.py(713):     pattern.flags = flags
sre_parse.py(714):     pattern.str = str
sre_parse.py(716):     p = _parse_sub(source, pattern, 0)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(419):             if this in WHITESPACE:
sre_parse.py(421):             if this == "#":
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(240):         return code
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(240):         return code
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(240):         return code
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(419):             if this in WHITESPACE:
sre_parse.py(421):             if this == "#":
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(493):                 min, max = 0, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(415):             break # end of pattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(328):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(718):     tail = source.get()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(719):     if tail == ")":
sre_parse.py(721):     elif tail:
sre_parse.py(724):     if flags & SRE_FLAG_DEBUG:
sre_parse.py(727):     if not (flags & SRE_FLAG_VERBOSE) and p.pattern.flags & SRE_FLAG_VERBOSE:
sre_parse.py(732):     return p
sre_compile.py(576):     code = _code(p, flags)
 --- modulename: sre_compile, funcname: _code
sre_compile.py(554):     flags = p.pattern.flags | flags
sre_compile.py(555):     code = []
sre_compile.py(558):     _compile_info(code, p, flags)
 --- modulename: sre_compile, funcname: _compile_info
sre_compile.py(437):     lo, hi = pattern.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_compile.py(438):     if lo == 0:
sre_compile.py(439):         return # not worth it
sre_compile.py(561):     _compile(code, p.data, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(320):             runs = None
sre_compile.py(321):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(342):     if len(charmap) == 256:
sre_compile.py(343):         data = _mk_bitmap(charmap)
 --- modulename: sre_compile, funcname: _mk_bitmap
sre_compile.py(412):     s = bytes(bits).translate(_BITS_TRANS)[::-1]
sre_compile.py(413):     return [_int(s[i - _CODEBITS: i], 2)
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(344):         out.append((CHARSET, data))
sre_compile.py(345):         out += tail
sre_compile.py(346):         return out
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(242):             code.extend(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(563):     code.append(OPCODES[SUCCESS])
sre_compile.py(565):     return code
sre_compile.py(581):     if p.pattern.groups > 100:
sre_compile.py(587):     groupindex = p.pattern.groupdict
sre_compile.py(588):     indexgroup = [None] * p.pattern.groups
sre_compile.py(589):     for k, i in groupindex.items():
sre_compile.py(592):     return _sre.compile(
sre_compile.py(593):         pattern, flags | p.pattern.flags, code,
sre_compile.py(594):         p.pattern.groups-1,
sre_compile.py(595):         groupindex, indexgroup
re.py(252):     if not bypass_cache:
re.py(253):         if len(_cache) >= _MAXCACHE:
re.py(255):         if p.flags & LOCALE:
re.py(260):             loc = None
re.py(261):         _cache[cachekey] = p, loc
re.py(262):     return p
decoder.py(146): WHITESPACE_STR = ' \t\n\r'
decoder.py(149):                object_pairs_hook, _w=WHITESPACE.match, _ws=WHITESPACE_STR):
decoder.py(236): def JSONArray(s_and_end, scan_once, _w=WHITESPACE.match, _ws=WHITESPACE_STR):
decoder.py(272): class JSONDecoder(object):
 --- modulename: decoder, funcname: JSONDecoder
decoder.py(272): class JSONDecoder(object):
decoder.py(300):     """
decoder.py(302):     def __init__(self, encoding=None, object_hook=None, parse_float=None,
decoder.py(303):             parse_int=None, parse_constant=None, strict=True,
decoder.py(304):             object_pairs_hook=None):
decoder.py(359):     def decode(self, s, _w=WHITESPACE.match):
decoder.py(370):     def raw_decode(self, s, idx=0):
__init__.py(109): from .encoder import JSONEncoder
 --- modulename: encoder, funcname: <module>
encoder.py(2): """
encoder.py(3): import re
encoder.py(5): try:
encoder.py(6):     from _json import encode_basestring_ascii as c_encode_basestring_ascii
encoder.py(9): try:
encoder.py(10):     from _json import make_encoder as c_make_encoder
encoder.py(14): ESCAPE = re.compile(r'[\x00-\x1f\\"\b\f\n\r\t]')
 --- modulename: re, funcname: compile
re.py(194):     return _compile(pattern, flags)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(240):         except KeyError:
re.py(241):             pass
re.py(242):     if isinstance(pattern, _pattern_type):
re.py(246):     if not sre_compile.isstring(pattern):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
re.py(248):     try:
re.py(249):         p = sre_compile.compile(pattern, flags)
 --- modulename: sre_compile, funcname: compile
sre_compile.py(570):     if isstring(p):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
sre_compile.py(571):         pattern = p
sre_compile.py(572):         p = sre_parse.parse(p, flags)
 --- modulename: sre_parse, funcname: parse
sre_parse.py(709):     source = Tokenizer(str)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(190):         self.string = string
sre_parse.py(191):         self.index = 0
sre_parse.py(192):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(711):     if pattern is None:
sre_parse.py(712):         pattern = Pattern()
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(68):         self.flags = 0
sre_parse.py(69):         self.open = []
sre_parse.py(70):         self.groups = 1
sre_parse.py(71):         self.groupdict = {}
sre_parse.py(72):         self.lookbehind = 0
sre_parse.py(713):     pattern.flags = flags
sre_parse.py(714):     pattern.str = str
sre_parse.py(716):     p = _parse_sub(source, pattern, 0)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(241):     code = CATEGORIES.get(escape)
sre_parse.py(242):     if code and code[0] == IN:
sre_parse.py(244):     try:
sre_parse.py(245):         c = escape[1:2]
sre_parse.py(246):         if c == "x":
sre_parse.py(248):             while source.next in HEXDIGITS and len(escape) < 4:
sre_parse.py(249):                 escape = escape + source.get()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(248):             while source.next in HEXDIGITS and len(escape) < 4:
sre_parse.py(249):                 escape = escape + source.get()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(248):             while source.next in HEXDIGITS and len(escape) < 4:
sre_parse.py(250):             escape = escape[2:]
sre_parse.py(251):             if len(escape) != 2:
sre_parse.py(253):             return LITERAL, int(escape, 16) & 0xff
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(453):                     this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(454):                     if this == "]":
sre_parse.py(460):                     elif this:
sre_parse.py(461):                         if this[0] == "\\":
sre_parse.py(462):                             code2 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(241):     code = CATEGORIES.get(escape)
sre_parse.py(242):     if code and code[0] == IN:
sre_parse.py(244):     try:
sre_parse.py(245):         c = escape[1:2]
sre_parse.py(246):         if c == "x":
sre_parse.py(248):             while source.next in HEXDIGITS and len(escape) < 4:
sre_parse.py(249):                 escape = escape + source.get()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(248):             while source.next in HEXDIGITS and len(escape) < 4:
sre_parse.py(249):                 escape = escape + source.get()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(248):             while source.next in HEXDIGITS and len(escape) < 4:
sre_parse.py(250):             escape = escape[2:]
sre_parse.py(251):             if len(escape) != 2:
sre_parse.py(253):             return LITERAL, int(escape, 16) & 0xff
sre_parse.py(465):                         if code1[0] != LITERAL or code2[0] != LITERAL:
sre_parse.py(467):                         lo = code1[1]
sre_parse.py(468):                         hi = code2[1]
sre_parse.py(469):                         if hi < lo:
sre_parse.py(471):                         setappend((RANGE, (lo, hi)))
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(240):         return code
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(240):         return code
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(240):         return code
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(240):         return code
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(240):         return code
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(240):         return code
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(415):             break # end of pattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(328):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(718):     tail = source.get()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(719):     if tail == ")":
sre_parse.py(721):     elif tail:
sre_parse.py(724):     if flags & SRE_FLAG_DEBUG:
sre_parse.py(727):     if not (flags & SRE_FLAG_VERBOSE) and p.pattern.flags & SRE_FLAG_VERBOSE:
sre_parse.py(732):     return p
sre_compile.py(576):     code = _code(p, flags)
 --- modulename: sre_compile, funcname: _code
sre_compile.py(554):     flags = p.pattern.flags | flags
sre_compile.py(555):     code = []
sre_compile.py(558):     _compile_info(code, p, flags)
 --- modulename: sre_compile, funcname: _compile_info
sre_compile.py(437):     lo, hi = pattern.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_compile.py(438):     if lo == 0:
sre_compile.py(441):     prefix = []
sre_compile.py(442):     prefixappend = prefix.append
sre_compile.py(443):     prefix_skip = 0
sre_compile.py(444):     charset = [] # not used
sre_compile.py(445):     charsetappend = charset.append
sre_compile.py(446):     if not (flags & SRE_FLAG_IGNORECASE):
sre_compile.py(448):         for op, av in pattern.data:
sre_compile.py(449):             if op is LITERAL:
sre_compile.py(453):             elif op is SUBPATTERN and len(av[1]) == 1:
sre_compile.py(460):                 break
sre_compile.py(462):         if not prefix and pattern.data:
sre_compile.py(463):             op, av = pattern.data[0]
sre_compile.py(464):             if op is SUBPATTERN and av[1]:
sre_compile.py(481):             elif op is BRANCH:
sre_compile.py(494):             elif op is IN:
sre_compile.py(495):                 charset = av
sre_compile.py(501):     emit = code.append
sre_compile.py(502):     emit(OPCODES[INFO])
sre_compile.py(503):     skip = len(code); emit(0)
sre_compile.py(505):     mask = 0
sre_compile.py(506):     if prefix:
sre_compile.py(510):     elif charset:
sre_compile.py(511):         mask = mask + SRE_INFO_CHARSET
sre_compile.py(512):     emit(mask)
sre_compile.py(514):     if lo < MAXCODE:
sre_compile.py(515):         emit(lo)
sre_compile.py(519):     if hi < MAXCODE:
sre_compile.py(520):         emit(hi)
sre_compile.py(524):     if prefix:
sre_compile.py(535):     elif charset:
sre_compile.py(536):         _compile_charset(charset, flags, code)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(274):                     r = range(av[0], av[1]+1)
sre_compile.py(275):                     if fixup:
sre_compile.py(277):                     if fixup and fixes:
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(320):             runs = None
sre_compile.py(321):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(342):     if len(charmap) == 256:
sre_compile.py(343):         data = _mk_bitmap(charmap)
 --- modulename: sre_compile, funcname: _mk_bitmap
sre_compile.py(412):     s = bytes(bits).translate(_BITS_TRANS)[::-1]
sre_compile.py(413):     return [_int(s[i - _CODEBITS: i], 2)
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(344):         out.append((CHARSET, data))
sre_compile.py(345):         out += tail
sre_compile.py(346):         return out
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(242):             code.extend(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(537):     code[skip] = len(code) - skip
sre_compile.py(561):     _compile(code, p.data, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(274):                     r = range(av[0], av[1]+1)
sre_compile.py(275):                     if fixup:
sre_compile.py(277):                     if fixup and fixes:
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(320):             runs = None
sre_compile.py(321):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(342):     if len(charmap) == 256:
sre_compile.py(343):         data = _mk_bitmap(charmap)
 --- modulename: sre_compile, funcname: _mk_bitmap
sre_compile.py(412):     s = bytes(bits).translate(_BITS_TRANS)[::-1]
sre_compile.py(413):     return [_int(s[i - _CODEBITS: i], 2)
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(344):         out.append((CHARSET, data))
sre_compile.py(345):         out += tail
sre_compile.py(346):         return out
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(242):             code.extend(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(563):     code.append(OPCODES[SUCCESS])
sre_compile.py(565):     return code
sre_compile.py(581):     if p.pattern.groups > 100:
sre_compile.py(587):     groupindex = p.pattern.groupdict
sre_compile.py(588):     indexgroup = [None] * p.pattern.groups
sre_compile.py(589):     for k, i in groupindex.items():
sre_compile.py(592):     return _sre.compile(
sre_compile.py(593):         pattern, flags | p.pattern.flags, code,
sre_compile.py(594):         p.pattern.groups-1,
sre_compile.py(595):         groupindex, indexgroup
re.py(252):     if not bypass_cache:
re.py(253):         if len(_cache) >= _MAXCACHE:
re.py(255):         if p.flags & LOCALE:
re.py(260):             loc = None
re.py(261):         _cache[cachekey] = p, loc
re.py(262):     return p
encoder.py(15): ESCAPE_ASCII = re.compile(r'([\\"]|[^\ -~])')
 --- modulename: re, funcname: compile
re.py(194):     return _compile(pattern, flags)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(240):         except KeyError:
re.py(241):             pass
re.py(242):     if isinstance(pattern, _pattern_type):
re.py(246):     if not sre_compile.isstring(pattern):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
re.py(248):     try:
re.py(249):         p = sre_compile.compile(pattern, flags)
 --- modulename: sre_compile, funcname: compile
sre_compile.py(570):     if isstring(p):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
sre_compile.py(571):         pattern = p
sre_compile.py(572):         p = sre_parse.parse(p, flags)
 --- modulename: sre_parse, funcname: parse
sre_parse.py(709):     source = Tokenizer(str)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(190):         self.string = string
sre_parse.py(191):         self.index = 0
sre_parse.py(192):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(711):     if pattern is None:
sre_parse.py(712):         pattern = Pattern()
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(68):         self.flags = 0
sre_parse.py(69):         self.open = []
sre_parse.py(70):         self.groups = 1
sre_parse.py(71):         self.groupdict = {}
sre_parse.py(72):         self.lookbehind = 0
sre_parse.py(713):     pattern.flags = flags
sre_parse.py(714):     pattern.str = str
sre_parse.py(716):     p = _parse_sub(source, pattern, 0)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(240):         return code
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(326):             continue
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(438):                 setappend((NEGATE, None))
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(241):     code = CATEGORIES.get(escape)
sre_parse.py(242):     if code and code[0] == IN:
sre_parse.py(244):     try:
sre_parse.py(245):         c = escape[1:2]
sre_parse.py(246):         if c == "x":
sre_parse.py(254):         elif c in OCTDIGITS:
sre_parse.py(260):         elif c in DIGITS:
sre_parse.py(262):         if len(escape) == 2:
sre_parse.py(263):             return LITERAL, ord(escape[1])
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(453):                     this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(454):                     if this == "]":
sre_parse.py(460):                     elif this:
sre_parse.py(461):                         if this[0] == "\\":
sre_parse.py(464):                             code2 = LITERAL, ord(this)
sre_parse.py(465):                         if code1[0] != LITERAL or code2[0] != LITERAL:
sre_parse.py(467):                         lo = code1[1]
sre_parse.py(468):                         hi = code2[1]
sre_parse.py(469):                         if hi < lo:
sre_parse.py(471):                         setappend((RANGE, (lo, hi)))
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(337):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(338):     subpatternappend = subpattern.append
sre_parse.py(341):     while 1:
sre_parse.py(342):         prefix = None
sre_parse.py(343):         for item in items:
sre_parse.py(344):             if not item:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(346):             if prefix is None:
sre_parse.py(347):                 prefix = item[0]
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(343):         for item in items:
sre_parse.py(344):             if not item:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(346):             if prefix is None:
sre_parse.py(348):             elif item[0] != prefix:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(349):                 break
sre_parse.py(357):         break
sre_parse.py(360):     for item in items:
sre_parse.py(361):         if len(item) != 1 or item[0][0] != LITERAL:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(362):             break
sre_parse.py(373):     subpattern.append((BRANCH, (None, items)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(374):     return subpattern
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(415):             break # end of pattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(328):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(718):     tail = source.get()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(719):     if tail == ")":
sre_parse.py(721):     elif tail:
sre_parse.py(724):     if flags & SRE_FLAG_DEBUG:
sre_parse.py(727):     if not (flags & SRE_FLAG_VERBOSE) and p.pattern.flags & SRE_FLAG_VERBOSE:
sre_parse.py(732):     return p
sre_compile.py(576):     code = _code(p, flags)
 --- modulename: sre_compile, funcname: _code
sre_compile.py(554):     flags = p.pattern.flags | flags
sre_compile.py(555):     code = []
sre_compile.py(558):     _compile_info(code, p, flags)
 --- modulename: sre_compile, funcname: _compile_info
sre_compile.py(437):     lo, hi = pattern.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(160):                 i = MAXREPEAT - 1
sre_parse.py(161):                 j = 0
sre_parse.py(162):                 for av in av[1]:
sre_parse.py(163):                     l, h = av.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(164):                     i = min(i, l)
sre_parse.py(165):                     j = max(j, h)
sre_parse.py(162):                 for av in av[1]:
sre_parse.py(163):                     l, h = av.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(164):                     i = min(i, l)
sre_parse.py(165):                     j = max(j, h)
sre_parse.py(162):                 for av in av[1]:
sre_parse.py(166):                 lo = lo + i
sre_parse.py(167):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_compile.py(438):     if lo == 0:
sre_compile.py(441):     prefix = []
sre_compile.py(442):     prefixappend = prefix.append
sre_compile.py(443):     prefix_skip = 0
sre_compile.py(444):     charset = [] # not used
sre_compile.py(445):     charsetappend = charset.append
sre_compile.py(446):     if not (flags & SRE_FLAG_IGNORECASE):
sre_compile.py(448):         for op, av in pattern.data:
sre_compile.py(449):             if op is LITERAL:
sre_compile.py(453):             elif op is SUBPATTERN and len(av[1]) == 1:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_compile.py(454):                 op, av = av[1][0]
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(455):                 if op is LITERAL:
sre_compile.py(458):                     break
sre_compile.py(462):         if not prefix and pattern.data:
sre_compile.py(463):             op, av = pattern.data[0]
sre_compile.py(464):             if op is SUBPATTERN and av[1]:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_compile.py(465):                 op, av = av[1][0]
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(466):                 if op is LITERAL:
sre_compile.py(468):                 elif op is BRANCH:
sre_compile.py(469):                     c = []
sre_compile.py(470):                     cappend = c.append
sre_compile.py(471):                     for p in av[1]:
sre_compile.py(472):                         if not p:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_compile.py(474):                         op, av = p[0]
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(475):                         if op is LITERAL:
sre_compile.py(478):                             break
sre_compile.py(501):     emit = code.append
sre_compile.py(502):     emit(OPCODES[INFO])
sre_compile.py(503):     skip = len(code); emit(0)
sre_compile.py(505):     mask = 0
sre_compile.py(506):     if prefix:
sre_compile.py(510):     elif charset:
sre_compile.py(512):     emit(mask)
sre_compile.py(514):     if lo < MAXCODE:
sre_compile.py(515):         emit(lo)
sre_compile.py(519):     if hi < MAXCODE:
sre_compile.py(520):         emit(hi)
sre_compile.py(524):     if prefix:
sre_compile.py(535):     elif charset:
sre_compile.py(537):     code[skip] = len(code) - skip
sre_compile.py(561):     _compile(code, p.data, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(155):         elif op in SUCCESS_CODES:
sre_compile.py(157):         elif op in ASSERT_CODES:
sre_compile.py(170):         elif op is CALL:
sre_compile.py(176):         elif op is AT:
sre_compile.py(185):         elif op is BRANCH:
sre_compile.py(186):             emit(OPCODES[op])
sre_compile.py(187):             tail = []
sre_compile.py(188):             tailappend = tail.append
sre_compile.py(189):             for av in av[1]:
sre_compile.py(190):                 skip = _len(code); emit(0)
sre_compile.py(192):                 _compile(code, av, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(193):                 emit(OPCODES[JUMP])
sre_compile.py(194):                 tailappend(_len(code)); emit(0)
sre_compile.py(195):                 code[skip] = _len(code) - skip
sre_compile.py(189):             for av in av[1]:
sre_compile.py(190):                 skip = _len(code); emit(0)
sre_compile.py(192):                 _compile(code, av, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(287):                     out.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(274):                     r = range(av[0], av[1]+1)
sre_compile.py(275):                     if fixup:
sre_compile.py(277):                     if fixup and fixes:
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(333):                 out.append((RANGE, (p, q - 1)))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(235):             pass
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(239):             emit(av[0])
sre_compile.py(240):             emit(av[1])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(193):                 emit(OPCODES[JUMP])
sre_compile.py(194):                 tailappend(_len(code)); emit(0)
sre_compile.py(195):                 code[skip] = _len(code) - skip
sre_compile.py(189):             for av in av[1]:
sre_compile.py(196):             emit(0) # end of branch
sre_compile.py(197):             for tail in tail:
sre_compile.py(198):                 code[tail] = _len(code) - tail
sre_compile.py(197):             for tail in tail:
sre_compile.py(198):                 code[tail] = _len(code) - tail
sre_compile.py(197):             for tail in tail:
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(563):     code.append(OPCODES[SUCCESS])
sre_compile.py(565):     return code
sre_compile.py(581):     if p.pattern.groups > 100:
sre_compile.py(587):     groupindex = p.pattern.groupdict
sre_compile.py(588):     indexgroup = [None] * p.pattern.groups
sre_compile.py(589):     for k, i in groupindex.items():
sre_compile.py(592):     return _sre.compile(
sre_compile.py(593):         pattern, flags | p.pattern.flags, code,
sre_compile.py(594):         p.pattern.groups-1,
sre_compile.py(595):         groupindex, indexgroup
re.py(252):     if not bypass_cache:
re.py(253):         if len(_cache) >= _MAXCACHE:
re.py(255):         if p.flags & LOCALE:
re.py(260):             loc = None
re.py(261):         _cache[cachekey] = p, loc
re.py(262):     return p
encoder.py(16): HAS_UTF8 = re.compile(r'[\x80-\xff]')
 --- modulename: re, funcname: compile
re.py(194):     return _compile(pattern, flags)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(240):         except KeyError:
re.py(241):             pass
re.py(242):     if isinstance(pattern, _pattern_type):
re.py(246):     if not sre_compile.isstring(pattern):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
re.py(248):     try:
re.py(249):         p = sre_compile.compile(pattern, flags)
 --- modulename: sre_compile, funcname: compile
sre_compile.py(570):     if isstring(p):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
sre_compile.py(571):         pattern = p
sre_compile.py(572):         p = sre_parse.parse(p, flags)
 --- modulename: sre_parse, funcname: parse
sre_parse.py(709):     source = Tokenizer(str)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(190):         self.string = string
sre_parse.py(191):         self.index = 0
sre_parse.py(192):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(711):     if pattern is None:
sre_parse.py(712):         pattern = Pattern()
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(68):         self.flags = 0
sre_parse.py(69):         self.open = []
sre_parse.py(70):         self.groups = 1
sre_parse.py(71):         self.groupdict = {}
sre_parse.py(72):         self.lookbehind = 0
sre_parse.py(713):     pattern.flags = flags
sre_parse.py(714):     pattern.str = str
sre_parse.py(716):     p = _parse_sub(source, pattern, 0)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(241):     code = CATEGORIES.get(escape)
sre_parse.py(242):     if code and code[0] == IN:
sre_parse.py(244):     try:
sre_parse.py(245):         c = escape[1:2]
sre_parse.py(246):         if c == "x":
sre_parse.py(248):             while source.next in HEXDIGITS and len(escape) < 4:
sre_parse.py(249):                 escape = escape + source.get()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(248):             while source.next in HEXDIGITS and len(escape) < 4:
sre_parse.py(249):                 escape = escape + source.get()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(248):             while source.next in HEXDIGITS and len(escape) < 4:
sre_parse.py(250):             escape = escape[2:]
sre_parse.py(251):             if len(escape) != 2:
sre_parse.py(253):             return LITERAL, int(escape, 16) & 0xff
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(453):                     this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(454):                     if this == "]":
sre_parse.py(460):                     elif this:
sre_parse.py(461):                         if this[0] == "\\":
sre_parse.py(462):                             code2 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(241):     code = CATEGORIES.get(escape)
sre_parse.py(242):     if code and code[0] == IN:
sre_parse.py(244):     try:
sre_parse.py(245):         c = escape[1:2]
sre_parse.py(246):         if c == "x":
sre_parse.py(248):             while source.next in HEXDIGITS and len(escape) < 4:
sre_parse.py(249):                 escape = escape + source.get()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(248):             while source.next in HEXDIGITS and len(escape) < 4:
sre_parse.py(249):                 escape = escape + source.get()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(248):             while source.next in HEXDIGITS and len(escape) < 4:
sre_parse.py(250):             escape = escape[2:]
sre_parse.py(251):             if len(escape) != 2:
sre_parse.py(253):             return LITERAL, int(escape, 16) & 0xff
sre_parse.py(465):                         if code1[0] != LITERAL or code2[0] != LITERAL:
sre_parse.py(467):                         lo = code1[1]
sre_parse.py(468):                         hi = code2[1]
sre_parse.py(469):                         if hi < lo:
sre_parse.py(471):                         setappend((RANGE, (lo, hi)))
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(415):             break # end of pattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(328):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(718):     tail = source.get()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(719):     if tail == ")":
sre_parse.py(721):     elif tail:
sre_parse.py(724):     if flags & SRE_FLAG_DEBUG:
sre_parse.py(727):     if not (flags & SRE_FLAG_VERBOSE) and p.pattern.flags & SRE_FLAG_VERBOSE:
sre_parse.py(732):     return p
sre_compile.py(576):     code = _code(p, flags)
 --- modulename: sre_compile, funcname: _code
sre_compile.py(554):     flags = p.pattern.flags | flags
sre_compile.py(555):     code = []
sre_compile.py(558):     _compile_info(code, p, flags)
 --- modulename: sre_compile, funcname: _compile_info
sre_compile.py(437):     lo, hi = pattern.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_compile.py(438):     if lo == 0:
sre_compile.py(441):     prefix = []
sre_compile.py(442):     prefixappend = prefix.append
sre_compile.py(443):     prefix_skip = 0
sre_compile.py(444):     charset = [] # not used
sre_compile.py(445):     charsetappend = charset.append
sre_compile.py(446):     if not (flags & SRE_FLAG_IGNORECASE):
sre_compile.py(448):         for op, av in pattern.data:
sre_compile.py(449):             if op is LITERAL:
sre_compile.py(453):             elif op is SUBPATTERN and len(av[1]) == 1:
sre_compile.py(460):                 break
sre_compile.py(462):         if not prefix and pattern.data:
sre_compile.py(463):             op, av = pattern.data[0]
sre_compile.py(464):             if op is SUBPATTERN and av[1]:
sre_compile.py(481):             elif op is BRANCH:
sre_compile.py(494):             elif op is IN:
sre_compile.py(495):                 charset = av
sre_compile.py(501):     emit = code.append
sre_compile.py(502):     emit(OPCODES[INFO])
sre_compile.py(503):     skip = len(code); emit(0)
sre_compile.py(505):     mask = 0
sre_compile.py(506):     if prefix:
sre_compile.py(510):     elif charset:
sre_compile.py(511):         mask = mask + SRE_INFO_CHARSET
sre_compile.py(512):     emit(mask)
sre_compile.py(514):     if lo < MAXCODE:
sre_compile.py(515):         emit(lo)
sre_compile.py(519):     if hi < MAXCODE:
sre_compile.py(520):         emit(hi)
sre_compile.py(524):     if prefix:
sre_compile.py(535):     elif charset:
sre_compile.py(536):         _compile_charset(charset, flags, code)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(274):                     r = range(av[0], av[1]+1)
sre_compile.py(275):                     if fixup:
sre_compile.py(277):                     if fixup and fixes:
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(324):             runs.append((p, len(charmap)))
sre_compile.py(325):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(333):                 out.append((RANGE, (p, q - 1)))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(239):             emit(av[0])
sre_compile.py(240):             emit(av[1])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(537):     code[skip] = len(code) - skip
sre_compile.py(561):     _compile(code, p.data, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(274):                     r = range(av[0], av[1]+1)
sre_compile.py(275):                     if fixup:
sre_compile.py(277):                     if fixup and fixes:
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(324):             runs.append((p, len(charmap)))
sre_compile.py(325):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(333):                 out.append((RANGE, (p, q - 1)))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(239):             emit(av[0])
sre_compile.py(240):             emit(av[1])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(563):     code.append(OPCODES[SUCCESS])
sre_compile.py(565):     return code
sre_compile.py(581):     if p.pattern.groups > 100:
sre_compile.py(587):     groupindex = p.pattern.groupdict
sre_compile.py(588):     indexgroup = [None] * p.pattern.groups
sre_compile.py(589):     for k, i in groupindex.items():
sre_compile.py(592):     return _sre.compile(
sre_compile.py(593):         pattern, flags | p.pattern.flags, code,
sre_compile.py(594):         p.pattern.groups-1,
sre_compile.py(595):         groupindex, indexgroup
re.py(252):     if not bypass_cache:
re.py(253):         if len(_cache) >= _MAXCACHE:
re.py(255):         if p.flags & LOCALE:
re.py(260):             loc = None
re.py(261):         _cache[cachekey] = p, loc
re.py(262):     return p
encoder.py(17): ESCAPE_DCT = {
encoder.py(18):     '\\': '\\\\',
encoder.py(19):     '"': '\\"',
encoder.py(20):     '\b': '\\b',
encoder.py(21):     '\f': '\\f',
encoder.py(22):     '\n': '\\n',
encoder.py(23):     '\r': '\\r',
encoder.py(24):     '\t': '\\t',
encoder.py(26): for i in range(0x20):
encoder.py(27):     ESCAPE_DCT.setdefault(chr(i), '\\u{0:04x}'.format(i))
encoder.py(26): for i in range(0x20):
encoder.py(27):     ESCAPE_DCT.setdefault(chr(i), '\\u{0:04x}'.format(i))
encoder.py(26): for i in range(0x20):
encoder.py(27):     ESCAPE_DCT.setdefault(chr(i), '\\u{0:04x}'.format(i))
encoder.py(26): for i in range(0x20):
encoder.py(27):     ESCAPE_DCT.setdefault(chr(i), '\\u{0:04x}'.format(i))
encoder.py(26): for i in range(0x20):
encoder.py(27):     ESCAPE_DCT.setdefault(chr(i), '\\u{0:04x}'.format(i))
encoder.py(26): for i in range(0x20):
encoder.py(27):     ESCAPE_DCT.setdefault(chr(i), '\\u{0:04x}'.format(i))
encoder.py(26): for i in range(0x20):
encoder.py(27):     ESCAPE_DCT.setdefault(chr(i), '\\u{0:04x}'.format(i))
encoder.py(26): for i in range(0x20):
encoder.py(27):     ESCAPE_DCT.setdefault(chr(i), '\\u{0:04x}'.format(i))
encoder.py(26): for i in range(0x20):
encoder.py(27):     ESCAPE_DCT.setdefault(chr(i), '\\u{0:04x}'.format(i))
encoder.py(26): for i in range(0x20):
encoder.py(27):     ESCAPE_DCT.setdefault(chr(i), '\\u{0:04x}'.format(i))
encoder.py(26): for i in range(0x20):
encoder.py(27):     ESCAPE_DCT.setdefault(chr(i), '\\u{0:04x}'.format(i))
encoder.py(26): for i in range(0x20):
encoder.py(27):     ESCAPE_DCT.setdefault(chr(i), '\\u{0:04x}'.format(i))
encoder.py(26): for i in range(0x20):
encoder.py(27):     ESCAPE_DCT.setdefault(chr(i), '\\u{0:04x}'.format(i))
encoder.py(26): for i in range(0x20):
encoder.py(27):     ESCAPE_DCT.setdefault(chr(i), '\\u{0:04x}'.format(i))
encoder.py(26): for i in range(0x20):
encoder.py(27):     ESCAPE_DCT.setdefault(chr(i), '\\u{0:04x}'.format(i))
encoder.py(26): for i in range(0x20):
encoder.py(27):     ESCAPE_DCT.setdefault(chr(i), '\\u{0:04x}'.format(i))
encoder.py(26): for i in range(0x20):
encoder.py(27):     ESCAPE_DCT.setdefault(chr(i), '\\u{0:04x}'.format(i))
encoder.py(26): for i in range(0x20):
encoder.py(27):     ESCAPE_DCT.setdefault(chr(i), '\\u{0:04x}'.format(i))
encoder.py(26): for i in range(0x20):
encoder.py(27):     ESCAPE_DCT.setdefault(chr(i), '\\u{0:04x}'.format(i))
encoder.py(26): for i in range(0x20):
encoder.py(27):     ESCAPE_DCT.setdefault(chr(i), '\\u{0:04x}'.format(i))
encoder.py(26): for i in range(0x20):
encoder.py(27):     ESCAPE_DCT.setdefault(chr(i), '\\u{0:04x}'.format(i))
encoder.py(26): for i in range(0x20):
encoder.py(27):     ESCAPE_DCT.setdefault(chr(i), '\\u{0:04x}'.format(i))
encoder.py(26): for i in range(0x20):
encoder.py(27):     ESCAPE_DCT.setdefault(chr(i), '\\u{0:04x}'.format(i))
encoder.py(26): for i in range(0x20):
encoder.py(27):     ESCAPE_DCT.setdefault(chr(i), '\\u{0:04x}'.format(i))
encoder.py(26): for i in range(0x20):
encoder.py(27):     ESCAPE_DCT.setdefault(chr(i), '\\u{0:04x}'.format(i))
encoder.py(26): for i in range(0x20):
encoder.py(27):     ESCAPE_DCT.setdefault(chr(i), '\\u{0:04x}'.format(i))
encoder.py(26): for i in range(0x20):
encoder.py(27):     ESCAPE_DCT.setdefault(chr(i), '\\u{0:04x}'.format(i))
encoder.py(26): for i in range(0x20):
encoder.py(27):     ESCAPE_DCT.setdefault(chr(i), '\\u{0:04x}'.format(i))
encoder.py(26): for i in range(0x20):
encoder.py(27):     ESCAPE_DCT.setdefault(chr(i), '\\u{0:04x}'.format(i))
encoder.py(26): for i in range(0x20):
encoder.py(27):     ESCAPE_DCT.setdefault(chr(i), '\\u{0:04x}'.format(i))
encoder.py(26): for i in range(0x20):
encoder.py(27):     ESCAPE_DCT.setdefault(chr(i), '\\u{0:04x}'.format(i))
encoder.py(26): for i in range(0x20):
encoder.py(27):     ESCAPE_DCT.setdefault(chr(i), '\\u{0:04x}'.format(i))
encoder.py(26): for i in range(0x20):
encoder.py(30): INFINITY = float('inf')
encoder.py(31): FLOAT_REPR = repr
encoder.py(33): def encode_basestring(s):
encoder.py(42): def py_encode_basestring_ascii(s):
encoder.py(68):     c_encode_basestring_ascii or py_encode_basestring_ascii)
encoder.py(70): class JSONEncoder(object):
 --- modulename: encoder, funcname: JSONEncoder
encoder.py(70): class JSONEncoder(object):
encoder.py(98):     """
encoder.py(99):     item_separator = ', '
encoder.py(100):     key_separator = ': '
encoder.py(101):     def __init__(self, skipkeys=False, ensure_ascii=True,
encoder.py(102):             check_circular=True, allow_nan=True, sort_keys=False,
encoder.py(103):             indent=None, separators=None, encoding='utf-8', default=None):
encoder.py(165):     def default(self, o):
encoder.py(186):     def encode(self, o):
encoder.py(212):     def iterencode(self, o, _one_shot=False):
encoder.py(275):         ValueError=ValueError,
encoder.py(276):         basestring=basestring,
encoder.py(277):         dict=dict,
encoder.py(278):         float=float,
encoder.py(279):         id=id,
encoder.py(280):         int=int,
encoder.py(281):         isinstance=isinstance,
encoder.py(282):         list=list,
encoder.py(283):         long=long,
encoder.py(284):         str=str,
encoder.py(285):         tuple=tuple,
__init__.py(111): _default_encoder = JSONEncoder(
__init__.py(112):     skipkeys=False,
__init__.py(113):     ensure_ascii=True,
__init__.py(114):     check_circular=True,
__init__.py(115):     allow_nan=True,
__init__.py(116):     indent=None,
__init__.py(117):     separators=None,
__init__.py(118):     encoding='utf-8',
__init__.py(119):     default=None,
 --- modulename: encoder, funcname: __init__
encoder.py(153):         self.skipkeys = skipkeys
encoder.py(154):         self.ensure_ascii = ensure_ascii
encoder.py(155):         self.check_circular = check_circular
encoder.py(156):         self.allow_nan = allow_nan
encoder.py(157):         self.sort_keys = sort_keys
encoder.py(158):         self.indent = indent
encoder.py(159):         if separators is not None:
encoder.py(161):         if default is not None:
encoder.py(163):         self.encoding = encoding
__init__.py(122): def dump(obj, fp, skipkeys=False, ensure_ascii=True, check_circular=True,
__init__.py(123):         allow_nan=True, cls=None, indent=None, separators=None,
__init__.py(124):         encoding='utf-8', default=None, sort_keys=False, **kw):
__init__.py(193): def dumps(obj, skipkeys=False, ensure_ascii=True, check_circular=True,
__init__.py(194):         allow_nan=True, cls=None, indent=None, separators=None,
__init__.py(195):         encoding='utf-8', default=None, sort_keys=False, **kw):
__init__.py(254): _default_decoder = JSONDecoder(encoding=None, object_hook=None,
__init__.py(255):                                object_pairs_hook=None)
 --- modulename: decoder, funcname: __init__
decoder.py(347):         self.encoding = encoding
decoder.py(348):         self.object_hook = object_hook
decoder.py(349):         self.object_pairs_hook = object_pairs_hook
decoder.py(350):         self.parse_float = parse_float or float
decoder.py(351):         self.parse_int = parse_int or int
decoder.py(352):         self.parse_constant = parse_constant or _CONSTANTS.__getitem__
decoder.py(353):         self.strict = strict
decoder.py(354):         self.parse_object = JSONObject
decoder.py(355):         self.parse_array = JSONArray
decoder.py(356):         self.parse_string = scanstring
decoder.py(357):         self.scan_once = scanner.make_scanner(self)
__init__.py(258): def load(fp, encoding=None, cls=None, object_hook=None, parse_float=None,
__init__.py(259):         parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):
__init__.py(294): def loads(s, encoding=None, cls=None, object_hook=None, parse_float=None,
__init__.py(295):         parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):
data.py(8): import optparse
 --- modulename: optparse, funcname: <module>
optparse.py(22): """
optparse.py(24): __version__ = "1.5.3"
optparse.py(26): __all__ = ['Option',
optparse.py(27):            'make_option',
optparse.py(28):            'SUPPRESS_HELP',
optparse.py(29):            'SUPPRESS_USAGE',
optparse.py(30):            'Values',
optparse.py(31):            'OptionContainer',
optparse.py(32):            'OptionGroup',
optparse.py(33):            'OptionParser',
optparse.py(34):            'HelpFormatter',
optparse.py(35):            'IndentedHelpFormatter',
optparse.py(36):            'TitledHelpFormatter',
optparse.py(37):            'OptParseError',
optparse.py(38):            'OptionError',
optparse.py(39):            'OptionConflictError',
optparse.py(40):            'OptionValueError',
optparse.py(41):            'BadOptionError']
optparse.py(73): """
optparse.py(75): import sys, os
optparse.py(76): import types
optparse.py(77): import textwrap
 --- modulename: textwrap, funcname: <module>
textwrap.py(2): """
textwrap.py(8): __revision__ = "$Id$"
textwrap.py(10): import string, re
textwrap.py(12): try:
textwrap.py(13):     _unicode = unicode
textwrap.py(28): __all__ = ['TextWrapper', 'wrap', 'fill', 'dedent']
textwrap.py(38): _whitespace = '\t\n\x0b\x0c\r '
textwrap.py(40): class TextWrapper:
 --- modulename: textwrap, funcname: TextWrapper
textwrap.py(40): class TextWrapper:
textwrap.py(80):     """
textwrap.py(82):     whitespace_trans = string.maketrans(_whitespace, ' ' * len(_whitespace))
textwrap.py(84):     unicode_whitespace_trans = {}
textwrap.py(85):     uspace = ord(u' ')
textwrap.py(86):     for x in map(ord, _whitespace):
textwrap.py(87):         unicode_whitespace_trans[x] = uspace
textwrap.py(86):     for x in map(ord, _whitespace):
textwrap.py(87):         unicode_whitespace_trans[x] = uspace
textwrap.py(86):     for x in map(ord, _whitespace):
textwrap.py(87):         unicode_whitespace_trans[x] = uspace
textwrap.py(86):     for x in map(ord, _whitespace):
textwrap.py(87):         unicode_whitespace_trans[x] = uspace
textwrap.py(86):     for x in map(ord, _whitespace):
textwrap.py(87):         unicode_whitespace_trans[x] = uspace
textwrap.py(86):     for x in map(ord, _whitespace):
textwrap.py(87):         unicode_whitespace_trans[x] = uspace
textwrap.py(86):     for x in map(ord, _whitespace):
textwrap.py(95):     wordsep_re = re.compile(
textwrap.py(96):         r'(\s+|'                                  # any whitespace
 --- modulename: re, funcname: compile
re.py(194):     return _compile(pattern, flags)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(240):         except KeyError:
re.py(241):             pass
re.py(242):     if isinstance(pattern, _pattern_type):
re.py(246):     if not sre_compile.isstring(pattern):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
re.py(248):     try:
re.py(249):         p = sre_compile.compile(pattern, flags)
 --- modulename: sre_compile, funcname: compile
sre_compile.py(570):     if isstring(p):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
sre_compile.py(571):         pattern = p
sre_compile.py(572):         p = sre_parse.parse(p, flags)
 --- modulename: sre_parse, funcname: parse
sre_parse.py(709):     source = Tokenizer(str)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(190):         self.string = string
sre_parse.py(191):         self.index = 0
sre_parse.py(192):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(711):     if pattern is None:
sre_parse.py(712):         pattern = Pattern()
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(68):         self.flags = 0
sre_parse.py(69):         self.open = []
sre_parse.py(70):         self.groups = 1
sre_parse.py(71):         self.groupdict = {}
sre_parse.py(72):         self.lookbehind = 0
sre_parse.py(713):     pattern.flags = flags
sre_parse.py(714):     pattern.str = str
sre_parse.py(716):     p = _parse_sub(source, pattern, 0)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(272):         return code
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(495):             elif this == "+":
sre_parse.py(496):                 min, max = 1, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(326):             continue
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(438):                 setappend((NEGATE, None))
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(241):     code = CATEGORIES.get(escape)
sre_parse.py(242):     if code and code[0] == IN:
sre_parse.py(243):         return code
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(476):                         code1 = code1[1][0]
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(241):     code = CATEGORIES.get(escape)
sre_parse.py(242):     if code and code[0] == IN:
sre_parse.py(243):         return code
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(476):                         code1 = code1[1][0]
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(493):                 min, max = 0, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(272):         return code
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(495):             elif this == "+":
sre_parse.py(496):                 min, max = 1, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(438):                 setappend((NEGATE, None))
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(453):                     this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(454):                     if this == "]":
sre_parse.py(460):                     elif this:
sre_parse.py(461):                         if this[0] == "\\":
sre_parse.py(464):                             code2 = LITERAL, ord(this)
sre_parse.py(465):                         if code1[0] != LITERAL or code2[0] != LITERAL:
sre_parse.py(467):                         lo = code1[1]
sre_parse.py(468):                         hi = code2[1]
sre_parse.py(469):                         if hi < lo:
sre_parse.py(471):                         setappend((RANGE, (lo, hi)))
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(241):     code = CATEGORIES.get(escape)
sre_parse.py(242):     if code and code[0] == IN:
sre_parse.py(243):         return code
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(476):                         code1 = code1[1][0]
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(549):                 group = 0
sre_parse.py(551):                 if sourcematch("P"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(600):                 elif sourcematch(":"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(603):                 elif sourcematch("#"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(612):                 elif source.next in ASSERTCHARS:
sre_parse.py(614):                     char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(615):                     dir = 1
sre_parse.py(616):                     if char == "<":
sre_parse.py(622):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(272):         return code
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(495):             elif this == "+":
sre_parse.py(496):                 min, max = 1, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(438):                 setappend((NEGATE, None))
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(453):                     this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(454):                     if this == "]":
sre_parse.py(460):                     elif this:
sre_parse.py(461):                         if this[0] == "\\":
sre_parse.py(464):                             code2 = LITERAL, ord(this)
sre_parse.py(465):                         if code1[0] != LITERAL or code2[0] != LITERAL:
sre_parse.py(467):                         lo = code1[1]
sre_parse.py(468):                         hi = code2[1]
sre_parse.py(469):                         if hi < lo:
sre_parse.py(471):                         setappend((RANGE, (lo, hi)))
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(241):     code = CATEGORIES.get(escape)
sre_parse.py(242):     if code and code[0] == IN:
sre_parse.py(243):         return code
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(476):                         code1 = code1[1][0]
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(623):                     if dir < 0:
sre_parse.py(625):                     if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(627):                     if char == "=":
sre_parse.py(628):                         subpatternappend((ASSERT, (dir, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(326):             continue
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(549):                 group = 0
sre_parse.py(551):                 if sourcematch("P"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(600):                 elif sourcematch(":"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(603):                 elif sourcematch("#"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(612):                 elif source.next in ASSERTCHARS:
sre_parse.py(614):                     char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(615):                     dir = 1
sre_parse.py(616):                     if char == "<":
sre_parse.py(617):                         if source.next not in LOOKBEHINDASSERTCHARS:
sre_parse.py(619):                         dir = -1 # lookbehind
sre_parse.py(620):                         char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(621):                         state.lookbehind += 1
sre_parse.py(622):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(241):     code = CATEGORIES.get(escape)
sre_parse.py(242):     if code and code[0] == IN:
sre_parse.py(243):         return code
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(476):                         code1 = code1[1][0]
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(241):     code = CATEGORIES.get(escape)
sre_parse.py(242):     if code and code[0] == IN:
sre_parse.py(244):     try:
sre_parse.py(245):         c = escape[1:2]
sre_parse.py(246):         if c == "x":
sre_parse.py(254):         elif c in OCTDIGITS:
sre_parse.py(260):         elif c in DIGITS:
sre_parse.py(262):         if len(escape) == 2:
sre_parse.py(263):             return LITERAL, ord(escape[1])
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(241):     code = CATEGORIES.get(escape)
sre_parse.py(242):     if code and code[0] == IN:
sre_parse.py(244):     try:
sre_parse.py(245):         c = escape[1:2]
sre_parse.py(246):         if c == "x":
sre_parse.py(254):         elif c in OCTDIGITS:
sre_parse.py(260):         elif c in DIGITS:
sre_parse.py(262):         if len(escape) == 2:
sre_parse.py(263):             return LITERAL, ord(escape[1])
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(241):     code = CATEGORIES.get(escape)
sre_parse.py(242):     if code and code[0] == IN:
sre_parse.py(244):     try:
sre_parse.py(245):         c = escape[1:2]
sre_parse.py(246):         if c == "x":
sre_parse.py(254):         elif c in OCTDIGITS:
sre_parse.py(260):         elif c in DIGITS:
sre_parse.py(262):         if len(escape) == 2:
sre_parse.py(263):             return LITERAL, ord(escape[1])
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(241):     code = CATEGORIES.get(escape)
sre_parse.py(242):     if code and code[0] == IN:
sre_parse.py(244):     try:
sre_parse.py(245):         c = escape[1:2]
sre_parse.py(246):         if c == "x":
sre_parse.py(254):         elif c in OCTDIGITS:
sre_parse.py(260):         elif c in DIGITS:
sre_parse.py(262):         if len(escape) == 2:
sre_parse.py(263):             return LITERAL, ord(escape[1])
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(241):     code = CATEGORIES.get(escape)
sre_parse.py(242):     if code and code[0] == IN:
sre_parse.py(244):     try:
sre_parse.py(245):         c = escape[1:2]
sre_parse.py(246):         if c == "x":
sre_parse.py(254):         elif c in OCTDIGITS:
sre_parse.py(260):         elif c in DIGITS:
sre_parse.py(262):         if len(escape) == 2:
sre_parse.py(263):             return LITERAL, ord(escape[1])
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(241):     code = CATEGORIES.get(escape)
sre_parse.py(242):     if code and code[0] == IN:
sre_parse.py(244):     try:
sre_parse.py(245):         c = escape[1:2]
sre_parse.py(246):         if c == "x":
sre_parse.py(254):         elif c in OCTDIGITS:
sre_parse.py(260):         elif c in DIGITS:
sre_parse.py(262):         if len(escape) == 2:
sre_parse.py(263):             return LITERAL, ord(escape[1])
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(241):     code = CATEGORIES.get(escape)
sre_parse.py(242):     if code and code[0] == IN:
sre_parse.py(244):     try:
sre_parse.py(245):         c = escape[1:2]
sre_parse.py(246):         if c == "x":
sre_parse.py(254):         elif c in OCTDIGITS:
sre_parse.py(260):         elif c in DIGITS:
sre_parse.py(262):         if len(escape) == 2:
sre_parse.py(263):             return LITERAL, ord(escape[1])
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(623):                     if dir < 0:
sre_parse.py(624):                         state.lookbehind -= 1
sre_parse.py(625):                     if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(627):                     if char == "=":
sre_parse.py(628):                         subpatternappend((ASSERT, (dir, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(495):             elif this == "+":
sre_parse.py(497):             elif this == "{":
sre_parse.py(498):                 if source.next == "}":
sre_parse.py(501):                 here = source.tell()
 --- modulename: sre_parse, funcname: tell
sre_parse.py(217):         return self.index, self.next
sre_parse.py(502):                 min, max = 0, MAXREPEAT
sre_parse.py(503):                 lo = hi = ""
sre_parse.py(504):                 while source.next in DIGITS:
sre_parse.py(505):                     lo = lo + source.get()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(504):                 while source.next in DIGITS:
sre_parse.py(506):                 if sourcematch(","):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(507):                     while source.next in DIGITS:
sre_parse.py(511):                 if not sourcematch("}"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(515):                 if lo:
sre_parse.py(516):                     min = int(lo)
sre_parse.py(517):                     if min >= MAXREPEAT:
sre_parse.py(519):                 if hi:
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(549):                 group = 0
sre_parse.py(551):                 if sourcematch("P"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(600):                 elif sourcematch(":"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(603):                 elif sourcematch("#"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(612):                 elif source.next in ASSERTCHARS:
sre_parse.py(614):                     char = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(615):                     dir = 1
sre_parse.py(616):                     if char == "<":
sre_parse.py(622):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(272):         return code
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(623):                     if dir < 0:
sre_parse.py(625):                     if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(627):                     if char == "=":
sre_parse.py(628):                         subpatternappend((ASSERT, (dir, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(337):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(338):     subpatternappend = subpattern.append
sre_parse.py(341):     while 1:
sre_parse.py(342):         prefix = None
sre_parse.py(343):         for item in items:
sre_parse.py(344):             if not item:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(346):             if prefix is None:
sre_parse.py(347):                 prefix = item[0]
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(343):         for item in items:
sre_parse.py(344):             if not item:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(346):             if prefix is None:
sre_parse.py(348):             elif item[0] != prefix:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(349):                 break
sre_parse.py(357):         break
sre_parse.py(360):     for item in items:
sre_parse.py(361):         if len(item) != 1 or item[0][0] != LITERAL:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(362):             break
sre_parse.py(373):     subpattern.append((BRANCH, (None, items)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(374):     return subpattern
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(415):             break # end of pattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(328):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(718):     tail = source.get()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(719):     if tail == ")":
sre_parse.py(721):     elif tail:
sre_parse.py(724):     if flags & SRE_FLAG_DEBUG:
sre_parse.py(727):     if not (flags & SRE_FLAG_VERBOSE) and p.pattern.flags & SRE_FLAG_VERBOSE:
sre_parse.py(732):     return p
sre_compile.py(576):     code = _code(p, flags)
 --- modulename: sre_compile, funcname: _code
sre_compile.py(554):     flags = p.pattern.flags | flags
sre_compile.py(555):     code = []
sre_compile.py(558):     _compile_info(code, p, flags)
 --- modulename: sre_compile, funcname: _compile_info
sre_compile.py(437):     lo, hi = pattern.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(160):                 i = MAXREPEAT - 1
sre_parse.py(161):                 j = 0
sre_parse.py(162):                 for av in av[1]:
sre_parse.py(163):                     l, h = av.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(164):                     i = min(i, l)
sre_parse.py(165):                     j = max(j, h)
sre_parse.py(162):                 for av in av[1]:
sre_parse.py(163):                     l, h = av.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(183):             elif op == SUCCESS:
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(164):                     i = min(i, l)
sre_parse.py(165):                     j = max(j, h)
sre_parse.py(162):                 for av in av[1]:
sre_parse.py(163):                     l, h = av.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(183):             elif op == SUCCESS:
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(183):             elif op == SUCCESS:
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(164):                     i = min(i, l)
sre_parse.py(165):                     j = max(j, h)
sre_parse.py(162):                 for av in av[1]:
sre_parse.py(166):                 lo = lo + i
sre_parse.py(167):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_compile.py(438):     if lo == 0:
sre_compile.py(441):     prefix = []
sre_compile.py(442):     prefixappend = prefix.append
sre_compile.py(443):     prefix_skip = 0
sre_compile.py(444):     charset = [] # not used
sre_compile.py(445):     charsetappend = charset.append
sre_compile.py(446):     if not (flags & SRE_FLAG_IGNORECASE):
sre_compile.py(448):         for op, av in pattern.data:
sre_compile.py(449):             if op is LITERAL:
sre_compile.py(453):             elif op is SUBPATTERN and len(av[1]) == 1:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_compile.py(454):                 op, av = av[1][0]
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(455):                 if op is LITERAL:
sre_compile.py(458):                     break
sre_compile.py(462):         if not prefix and pattern.data:
sre_compile.py(463):             op, av = pattern.data[0]
sre_compile.py(464):             if op is SUBPATTERN and av[1]:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_compile.py(465):                 op, av = av[1][0]
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(466):                 if op is LITERAL:
sre_compile.py(468):                 elif op is BRANCH:
sre_compile.py(469):                     c = []
sre_compile.py(470):                     cappend = c.append
sre_compile.py(471):                     for p in av[1]:
sre_compile.py(472):                         if not p:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_compile.py(474):                         op, av = p[0]
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(475):                         if op is LITERAL:
sre_compile.py(478):                             break
sre_compile.py(501):     emit = code.append
sre_compile.py(502):     emit(OPCODES[INFO])
sre_compile.py(503):     skip = len(code); emit(0)
sre_compile.py(505):     mask = 0
sre_compile.py(506):     if prefix:
sre_compile.py(510):     elif charset:
sre_compile.py(512):     emit(mask)
sre_compile.py(514):     if lo < MAXCODE:
sre_compile.py(515):         emit(lo)
sre_compile.py(519):     if hi < MAXCODE:
sre_compile.py(522):         emit(0)
sre_compile.py(524):     if prefix:
sre_compile.py(535):     elif charset:
sre_compile.py(537):     code[skip] = len(code) - skip
sre_compile.py(561):     _compile(code, p.data, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(155):         elif op in SUCCESS_CODES:
sre_compile.py(157):         elif op in ASSERT_CODES:
sre_compile.py(170):         elif op is CALL:
sre_compile.py(176):         elif op is AT:
sre_compile.py(185):         elif op is BRANCH:
sre_compile.py(186):             emit(OPCODES[op])
sre_compile.py(187):             tail = []
sre_compile.py(188):             tailappend = tail.append
sre_compile.py(189):             for av in av[1]:
sre_compile.py(190):                 skip = _len(code); emit(0)
sre_compile.py(192):                 _compile(code, av, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(193):                 emit(OPCODES[JUMP])
sre_compile.py(194):                 tailappend(_len(code)); emit(0)
sre_compile.py(195):                 code[skip] = _len(code) - skip
sre_compile.py(189):             for av in av[1]:
sre_compile.py(190):                 skip = _len(code); emit(0)
sre_compile.py(192):                 _compile(code, av, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(287):                     out.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(235):             pass
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(287):                     out.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(274):                     r = range(av[0], av[1]+1)
sre_compile.py(275):                     if fixup:
sre_compile.py(277):                     if fixup and fixes:
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(333):                 out.append((RANGE, (p, q - 1)))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(235):             pass
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(239):             emit(av[0])
sre_compile.py(240):             emit(av[1])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(155):         elif op in SUCCESS_CODES:
sre_compile.py(157):         elif op in ASSERT_CODES:
sre_compile.py(158):             emit(OPCODES[op])
sre_compile.py(159):             skip = _len(code); emit(0)
sre_compile.py(160):             if av[0] >= 0:
sre_compile.py(161):                 emit(0) # look ahead
sre_compile.py(167):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(287):                     out.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(274):                     r = range(av[0], av[1]+1)
sre_compile.py(275):                     if fixup:
sre_compile.py(277):                     if fixup and fixes:
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(333):                 out.append((RANGE, (p, q - 1)))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(235):             pass
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(239):             emit(av[0])
sre_compile.py(240):             emit(av[1])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(168):             emit(OPCODES[SUCCESS])
sre_compile.py(169):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(193):                 emit(OPCODES[JUMP])
sre_compile.py(194):                 tailappend(_len(code)); emit(0)
sre_compile.py(195):                 code[skip] = _len(code) - skip
sre_compile.py(189):             for av in av[1]:
sre_compile.py(190):                 skip = _len(code); emit(0)
sre_compile.py(192):                 _compile(code, av, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(155):         elif op in SUCCESS_CODES:
sre_compile.py(157):         elif op in ASSERT_CODES:
sre_compile.py(158):             emit(OPCODES[op])
sre_compile.py(159):             skip = _len(code); emit(0)
sre_compile.py(160):             if av[0] >= 0:
sre_compile.py(163):                 lo, hi = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_compile.py(164):                 if lo != hi:
sre_compile.py(166):                 emit(lo) # look behind
sre_compile.py(167):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(320):             runs = None
sre_compile.py(321):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(342):     if len(charmap) == 256:
sre_compile.py(343):         data = _mk_bitmap(charmap)
 --- modulename: sre_compile, funcname: _mk_bitmap
sre_compile.py(412):     s = bytes(bits).translate(_BITS_TRANS)[::-1]
sre_compile.py(413):     return [_int(s[i - _CODEBITS: i], 2)
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(344):         out.append((CHARSET, data))
sre_compile.py(345):         out += tail
sre_compile.py(346):         return out
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(242):             code.extend(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(168):             emit(OPCODES[SUCCESS])
sre_compile.py(169):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(155):         elif op in SUCCESS_CODES:
sre_compile.py(157):         elif op in ASSERT_CODES:
sre_compile.py(158):             emit(OPCODES[op])
sre_compile.py(159):             skip = _len(code); emit(0)
sre_compile.py(160):             if av[0] >= 0:
sre_compile.py(161):                 emit(0) # look ahead
sre_compile.py(167):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(168):             emit(OPCODES[SUCCESS])
sre_compile.py(169):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(193):                 emit(OPCODES[JUMP])
sre_compile.py(194):                 tailappend(_len(code)); emit(0)
sre_compile.py(195):                 code[skip] = _len(code) - skip
sre_compile.py(189):             for av in av[1]:
sre_compile.py(196):             emit(0) # end of branch
sre_compile.py(197):             for tail in tail:
sre_compile.py(198):                 code[tail] = _len(code) - tail
sre_compile.py(197):             for tail in tail:
sre_compile.py(198):                 code[tail] = _len(code) - tail
sre_compile.py(197):             for tail in tail:
sre_compile.py(198):                 code[tail] = _len(code) - tail
sre_compile.py(197):             for tail in tail:
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(563):     code.append(OPCODES[SUCCESS])
sre_compile.py(565):     return code
sre_compile.py(581):     if p.pattern.groups > 100:
sre_compile.py(587):     groupindex = p.pattern.groupdict
sre_compile.py(588):     indexgroup = [None] * p.pattern.groups
sre_compile.py(589):     for k, i in groupindex.items():
sre_compile.py(592):     return _sre.compile(
sre_compile.py(593):         pattern, flags | p.pattern.flags, code,
sre_compile.py(594):         p.pattern.groups-1,
sre_compile.py(595):         groupindex, indexgroup
re.py(252):     if not bypass_cache:
re.py(253):         if len(_cache) >= _MAXCACHE:
re.py(255):         if p.flags & LOCALE:
re.py(260):             loc = None
re.py(261):         _cache[cachekey] = p, loc
re.py(262):     return p
textwrap.py(104):     wordsep_simple_re = re.compile(r'(\s+)')
 --- modulename: re, funcname: compile
re.py(194):     return _compile(pattern, flags)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(240):         except KeyError:
re.py(241):             pass
re.py(242):     if isinstance(pattern, _pattern_type):
re.py(246):     if not sre_compile.isstring(pattern):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
re.py(248):     try:
re.py(249):         p = sre_compile.compile(pattern, flags)
 --- modulename: sre_compile, funcname: compile
sre_compile.py(570):     if isstring(p):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
sre_compile.py(571):         pattern = p
sre_compile.py(572):         p = sre_parse.parse(p, flags)
 --- modulename: sre_parse, funcname: parse
sre_parse.py(709):     source = Tokenizer(str)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(190):         self.string = string
sre_parse.py(191):         self.index = 0
sre_parse.py(192):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(711):     if pattern is None:
sre_parse.py(712):         pattern = Pattern()
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(68):         self.flags = 0
sre_parse.py(69):         self.open = []
sre_parse.py(70):         self.groups = 1
sre_parse.py(71):         self.groupdict = {}
sre_parse.py(72):         self.lookbehind = 0
sre_parse.py(713):     pattern.flags = flags
sre_parse.py(714):     pattern.str = str
sre_parse.py(716):     p = _parse_sub(source, pattern, 0)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(272):         return code
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(495):             elif this == "+":
sre_parse.py(496):                 min, max = 1, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(415):             break # end of pattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(328):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(718):     tail = source.get()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(719):     if tail == ")":
sre_parse.py(721):     elif tail:
sre_parse.py(724):     if flags & SRE_FLAG_DEBUG:
sre_parse.py(727):     if not (flags & SRE_FLAG_VERBOSE) and p.pattern.flags & SRE_FLAG_VERBOSE:
sre_parse.py(732):     return p
sre_compile.py(576):     code = _code(p, flags)
 --- modulename: sre_compile, funcname: _code
sre_compile.py(554):     flags = p.pattern.flags | flags
sre_compile.py(555):     code = []
sre_compile.py(558):     _compile_info(code, p, flags)
 --- modulename: sre_compile, funcname: _compile_info
sre_compile.py(437):     lo, hi = pattern.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_compile.py(438):     if lo == 0:
sre_compile.py(441):     prefix = []
sre_compile.py(442):     prefixappend = prefix.append
sre_compile.py(443):     prefix_skip = 0
sre_compile.py(444):     charset = [] # not used
sre_compile.py(445):     charsetappend = charset.append
sre_compile.py(446):     if not (flags & SRE_FLAG_IGNORECASE):
sre_compile.py(448):         for op, av in pattern.data:
sre_compile.py(449):             if op is LITERAL:
sre_compile.py(453):             elif op is SUBPATTERN and len(av[1]) == 1:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_compile.py(454):                 op, av = av[1][0]
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(455):                 if op is LITERAL:
sre_compile.py(458):                     break
sre_compile.py(462):         if not prefix and pattern.data:
sre_compile.py(463):             op, av = pattern.data[0]
sre_compile.py(464):             if op is SUBPATTERN and av[1]:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_compile.py(465):                 op, av = av[1][0]
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(466):                 if op is LITERAL:
sre_compile.py(468):                 elif op is BRANCH:
sre_compile.py(501):     emit = code.append
sre_compile.py(502):     emit(OPCODES[INFO])
sre_compile.py(503):     skip = len(code); emit(0)
sre_compile.py(505):     mask = 0
sre_compile.py(506):     if prefix:
sre_compile.py(510):     elif charset:
sre_compile.py(512):     emit(mask)
sre_compile.py(514):     if lo < MAXCODE:
sre_compile.py(515):         emit(lo)
sre_compile.py(519):     if hi < MAXCODE:
sre_compile.py(522):         emit(0)
sre_compile.py(524):     if prefix:
sre_compile.py(535):     elif charset:
sre_compile.py(537):     code[skip] = len(code) - skip
sre_compile.py(561):     _compile(code, p.data, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(563):     code.append(OPCODES[SUCCESS])
sre_compile.py(565):     return code
sre_compile.py(581):     if p.pattern.groups > 100:
sre_compile.py(587):     groupindex = p.pattern.groupdict
sre_compile.py(588):     indexgroup = [None] * p.pattern.groups
sre_compile.py(589):     for k, i in groupindex.items():
sre_compile.py(592):     return _sre.compile(
sre_compile.py(593):         pattern, flags | p.pattern.flags, code,
sre_compile.py(594):         p.pattern.groups-1,
sre_compile.py(595):         groupindex, indexgroup
re.py(252):     if not bypass_cache:
re.py(253):         if len(_cache) >= _MAXCACHE:
re.py(255):         if p.flags & LOCALE:
re.py(260):             loc = None
re.py(261):         _cache[cachekey] = p, loc
re.py(262):     return p
textwrap.py(108):     sentence_end_re = re.compile(r'[%s]'              # lowercase letter
textwrap.py(112):                                  % string.lowercase)
 --- modulename: re, funcname: compile
re.py(194):     return _compile(pattern, flags)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(240):         except KeyError:
re.py(241):             pass
re.py(242):     if isinstance(pattern, _pattern_type):
re.py(246):     if not sre_compile.isstring(pattern):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
re.py(248):     try:
re.py(249):         p = sre_compile.compile(pattern, flags)
 --- modulename: sre_compile, funcname: compile
sre_compile.py(570):     if isstring(p):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
sre_compile.py(571):         pattern = p
sre_compile.py(572):         p = sre_parse.parse(p, flags)
 --- modulename: sre_parse, funcname: parse
sre_parse.py(709):     source = Tokenizer(str)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(190):         self.string = string
sre_parse.py(191):         self.index = 0
sre_parse.py(192):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(711):     if pattern is None:
sre_parse.py(712):         pattern = Pattern()
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(68):         self.flags = 0
sre_parse.py(69):         self.open = []
sre_parse.py(70):         self.groups = 1
sre_parse.py(71):         self.groupdict = {}
sre_parse.py(72):         self.lookbehind = 0
sre_parse.py(713):     pattern.flags = flags
sre_parse.py(714):     pattern.str = str
sre_parse.py(716):     p = _parse_sub(source, pattern, 0)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(241):     code = CATEGORIES.get(escape)
sre_parse.py(242):     if code and code[0] == IN:
sre_parse.py(244):     try:
sre_parse.py(245):         c = escape[1:2]
sre_parse.py(246):         if c == "x":
sre_parse.py(254):         elif c in OCTDIGITS:
sre_parse.py(260):         elif c in DIGITS:
sre_parse.py(262):         if len(escape) == 2:
sre_parse.py(263):             return LITERAL, ord(escape[1])
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(241):     code = CATEGORIES.get(escape)
sre_parse.py(242):     if code and code[0] == IN:
sre_parse.py(244):     try:
sre_parse.py(245):         c = escape[1:2]
sre_parse.py(246):         if c == "x":
sre_parse.py(254):         elif c in OCTDIGITS:
sre_parse.py(260):         elif c in DIGITS:
sre_parse.py(262):         if len(escape) == 2:
sre_parse.py(263):             return LITERAL, ord(escape[1])
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(241):     code = CATEGORIES.get(escape)
sre_parse.py(242):     if code and code[0] == IN:
sre_parse.py(244):     try:
sre_parse.py(245):         c = escape[1:2]
sre_parse.py(246):         if c == "x":
sre_parse.py(254):         elif c in OCTDIGITS:
sre_parse.py(260):         elif c in DIGITS:
sre_parse.py(262):         if len(escape) == 2:
sre_parse.py(263):             return LITERAL, ord(escape[1])
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(241):     code = CATEGORIES.get(escape)
sre_parse.py(242):     if code and code[0] == IN:
sre_parse.py(244):     try:
sre_parse.py(245):         c = escape[1:2]
sre_parse.py(246):         if c == "x":
sre_parse.py(254):         elif c in OCTDIGITS:
sre_parse.py(260):         elif c in DIGITS:
sre_parse.py(262):         if len(escape) == 2:
sre_parse.py(263):             return LITERAL, ord(escape[1])
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(241):     code = CATEGORIES.get(escape)
sre_parse.py(242):     if code and code[0] == IN:
sre_parse.py(244):     try:
sre_parse.py(245):         c = escape[1:2]
sre_parse.py(246):         if c == "x":
sre_parse.py(254):         elif c in OCTDIGITS:
sre_parse.py(260):         elif c in DIGITS:
sre_parse.py(262):         if len(escape) == 2:
sre_parse.py(263):             return LITERAL, ord(escape[1])
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(491):                 min, max = 0, 1
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(697):         elif this and this[0] == "\\":
sre_parse.py(698):             code = _escape(source, this, state)
 --- modulename: sre_parse, funcname: _escape
sre_parse.py(270):     code = CATEGORIES.get(escape)
sre_parse.py(271):     if code:
sre_parse.py(272):         return code
sre_parse.py(699):             subpatternappend(code)
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(415):             break # end of pattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(328):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(718):     tail = source.get()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(719):     if tail == ")":
sre_parse.py(721):     elif tail:
sre_parse.py(724):     if flags & SRE_FLAG_DEBUG:
sre_parse.py(727):     if not (flags & SRE_FLAG_VERBOSE) and p.pattern.flags & SRE_FLAG_VERBOSE:
sre_parse.py(732):     return p
sre_compile.py(576):     code = _code(p, flags)
 --- modulename: sre_compile, funcname: _code
sre_compile.py(554):     flags = p.pattern.flags | flags
sre_compile.py(555):     code = []
sre_compile.py(558):     _compile_info(code, p, flags)
 --- modulename: sre_compile, funcname: _compile_info
sre_compile.py(437):     lo, hi = pattern.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(183):             elif op == SUCCESS:
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_compile.py(438):     if lo == 0:
sre_compile.py(441):     prefix = []
sre_compile.py(442):     prefixappend = prefix.append
sre_compile.py(443):     prefix_skip = 0
sre_compile.py(444):     charset = [] # not used
sre_compile.py(445):     charsetappend = charset.append
sre_compile.py(446):     if not (flags & SRE_FLAG_IGNORECASE):
sre_compile.py(448):         for op, av in pattern.data:
sre_compile.py(449):             if op is LITERAL:
sre_compile.py(453):             elif op is SUBPATTERN and len(av[1]) == 1:
sre_compile.py(460):                 break
sre_compile.py(462):         if not prefix and pattern.data:
sre_compile.py(463):             op, av = pattern.data[0]
sre_compile.py(464):             if op is SUBPATTERN and av[1]:
sre_compile.py(481):             elif op is BRANCH:
sre_compile.py(494):             elif op is IN:
sre_compile.py(495):                 charset = av
sre_compile.py(501):     emit = code.append
sre_compile.py(502):     emit(OPCODES[INFO])
sre_compile.py(503):     skip = len(code); emit(0)
sre_compile.py(505):     mask = 0
sre_compile.py(506):     if prefix:
sre_compile.py(510):     elif charset:
sre_compile.py(511):         mask = mask + SRE_INFO_CHARSET
sre_compile.py(512):     emit(mask)
sre_compile.py(514):     if lo < MAXCODE:
sre_compile.py(515):         emit(lo)
sre_compile.py(519):     if hi < MAXCODE:
sre_compile.py(520):         emit(hi)
sre_compile.py(524):     if prefix:
sre_compile.py(535):     elif charset:
sre_compile.py(536):         _compile_charset(charset, flags, code)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(333):                 out.append((RANGE, (p, q - 1)))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(337):             return out
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(239):             emit(av[0])
sre_compile.py(240):             emit(av[1])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(537):     code[skip] = len(code) - skip
sre_compile.py(561):     _compile(code, p.data, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(333):                 out.append((RANGE, (p, q - 1)))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(337):             return out
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(239):             emit(av[0])
sre_compile.py(240):             emit(av[1])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(320):             runs = None
sre_compile.py(321):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(342):     if len(charmap) == 256:
sre_compile.py(343):         data = _mk_bitmap(charmap)
 --- modulename: sre_compile, funcname: _mk_bitmap
sre_compile.py(412):     s = bytes(bits).translate(_BITS_TRANS)[::-1]
sre_compile.py(413):     return [_int(s[i - _CODEBITS: i], 2)
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(344):         out.append((CHARSET, data))
sre_compile.py(345):         out += tail
sre_compile.py(346):         return out
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(242):             code.extend(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(155):         elif op in SUCCESS_CODES:
sre_compile.py(157):         elif op in ASSERT_CODES:
sre_compile.py(170):         elif op is CALL:
sre_compile.py(176):         elif op is AT:
sre_compile.py(177):             emit(OPCODES[op])
sre_compile.py(178):             if flags & SRE_FLAG_MULTILINE:
sre_compile.py(180):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(182):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(184):             emit(ATCODES[av])
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(563):     code.append(OPCODES[SUCCESS])
sre_compile.py(565):     return code
sre_compile.py(581):     if p.pattern.groups > 100:
sre_compile.py(587):     groupindex = p.pattern.groupdict
sre_compile.py(588):     indexgroup = [None] * p.pattern.groups
sre_compile.py(589):     for k, i in groupindex.items():
sre_compile.py(592):     return _sre.compile(
sre_compile.py(593):         pattern, flags | p.pattern.flags, code,
sre_compile.py(594):         p.pattern.groups-1,
sre_compile.py(595):         groupindex, indexgroup
re.py(252):     if not bypass_cache:
re.py(253):         if len(_cache) >= _MAXCACHE:
re.py(255):         if p.flags & LOCALE:
re.py(260):             loc = None
re.py(261):         _cache[cachekey] = p, loc
re.py(262):     return p
textwrap.py(116):                  width=70,
textwrap.py(117):                  initial_indent="",
textwrap.py(118):                  subsequent_indent="",
textwrap.py(119):                  expand_tabs=True,
textwrap.py(120):                  replace_whitespace=True,
textwrap.py(121):                  fix_sentence_endings=False,
textwrap.py(122):                  break_long_words=True,
textwrap.py(123):                  drop_whitespace=True,
textwrap.py(124):                  break_on_hyphens=True):
textwrap.py(146):     def _munge_whitespace(self, text):
textwrap.py(163):     def _split(self, text):
textwrap.py(192):     def _fix_sentence_endings(self, chunks):
textwrap.py(210):     def _handle_long_word(self, reversed_chunks, cur_line, cur_len, width):
textwrap.py(243):     def _wrap_chunks(self, chunks):
textwrap.py(316):     def wrap(self, text):
textwrap.py(331):     def fill(self, text):
textwrap.py(343): def wrap(text, width=70, **kwargs):
textwrap.py(356): def fill(text, width=70, **kwargs):
textwrap.py(371): _whitespace_only_re = re.compile('^[ \t]+$', re.MULTILINE)
 --- modulename: re, funcname: compile
re.py(194):     return _compile(pattern, flags)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(240):         except KeyError:
re.py(241):             pass
re.py(242):     if isinstance(pattern, _pattern_type):
re.py(246):     if not sre_compile.isstring(pattern):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
re.py(248):     try:
re.py(249):         p = sre_compile.compile(pattern, flags)
 --- modulename: sre_compile, funcname: compile
sre_compile.py(570):     if isstring(p):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
sre_compile.py(571):         pattern = p
sre_compile.py(572):         p = sre_parse.parse(p, flags)
 --- modulename: sre_parse, funcname: parse
sre_parse.py(709):     source = Tokenizer(str)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(190):         self.string = string
sre_parse.py(191):         self.index = 0
sre_parse.py(192):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(711):     if pattern is None:
sre_parse.py(712):         pattern = Pattern()
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(68):         self.flags = 0
sre_parse.py(69):         self.open = []
sre_parse.py(70):         self.groups = 1
sre_parse.py(71):         self.groupdict = {}
sre_parse.py(72):         self.lookbehind = 0
sre_parse.py(713):     pattern.flags = flags
sre_parse.py(714):     pattern.str = str
sre_parse.py(716):     p = _parse_sub(source, pattern, 0)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(692):             subpatternappend((AT, AT_BEGINNING))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(495):             elif this == "+":
sre_parse.py(496):                 min, max = 1, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(695):             subpattern.append((AT, AT_END))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(415):             break # end of pattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(328):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(718):     tail = source.get()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(719):     if tail == ")":
sre_parse.py(721):     elif tail:
sre_parse.py(724):     if flags & SRE_FLAG_DEBUG:
sre_parse.py(727):     if not (flags & SRE_FLAG_VERBOSE) and p.pattern.flags & SRE_FLAG_VERBOSE:
sre_parse.py(732):     return p
sre_compile.py(576):     code = _code(p, flags)
 --- modulename: sre_compile, funcname: _code
sre_compile.py(554):     flags = p.pattern.flags | flags
sre_compile.py(555):     code = []
sre_compile.py(558):     _compile_info(code, p, flags)
 --- modulename: sre_compile, funcname: _compile_info
sre_compile.py(437):     lo, hi = pattern.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(183):             elif op == SUCCESS:
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(183):             elif op == SUCCESS:
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_compile.py(438):     if lo == 0:
sre_compile.py(441):     prefix = []
sre_compile.py(442):     prefixappend = prefix.append
sre_compile.py(443):     prefix_skip = 0
sre_compile.py(444):     charset = [] # not used
sre_compile.py(445):     charsetappend = charset.append
sre_compile.py(446):     if not (flags & SRE_FLAG_IGNORECASE):
sre_compile.py(448):         for op, av in pattern.data:
sre_compile.py(449):             if op is LITERAL:
sre_compile.py(453):             elif op is SUBPATTERN and len(av[1]) == 1:
sre_compile.py(460):                 break
sre_compile.py(462):         if not prefix and pattern.data:
sre_compile.py(463):             op, av = pattern.data[0]
sre_compile.py(464):             if op is SUBPATTERN and av[1]:
sre_compile.py(481):             elif op is BRANCH:
sre_compile.py(494):             elif op is IN:
sre_compile.py(501):     emit = code.append
sre_compile.py(502):     emit(OPCODES[INFO])
sre_compile.py(503):     skip = len(code); emit(0)
sre_compile.py(505):     mask = 0
sre_compile.py(506):     if prefix:
sre_compile.py(510):     elif charset:
sre_compile.py(512):     emit(mask)
sre_compile.py(514):     if lo < MAXCODE:
sre_compile.py(515):         emit(lo)
sre_compile.py(519):     if hi < MAXCODE:
sre_compile.py(522):         emit(0)
sre_compile.py(524):     if prefix:
sre_compile.py(535):     elif charset:
sre_compile.py(537):     code[skip] = len(code) - skip
sre_compile.py(561):     _compile(code, p.data, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(155):         elif op in SUCCESS_CODES:
sre_compile.py(157):         elif op in ASSERT_CODES:
sre_compile.py(170):         elif op is CALL:
sre_compile.py(176):         elif op is AT:
sre_compile.py(177):             emit(OPCODES[op])
sre_compile.py(178):             if flags & SRE_FLAG_MULTILINE:
sre_compile.py(179):                 av = AT_MULTILINE.get(av, av)
sre_compile.py(180):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(182):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(184):             emit(ATCODES[av])
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(155):         elif op in SUCCESS_CODES:
sre_compile.py(157):         elif op in ASSERT_CODES:
sre_compile.py(170):         elif op is CALL:
sre_compile.py(176):         elif op is AT:
sre_compile.py(177):             emit(OPCODES[op])
sre_compile.py(178):             if flags & SRE_FLAG_MULTILINE:
sre_compile.py(179):                 av = AT_MULTILINE.get(av, av)
sre_compile.py(180):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(182):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(184):             emit(ATCODES[av])
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(563):     code.append(OPCODES[SUCCESS])
sre_compile.py(565):     return code
sre_compile.py(581):     if p.pattern.groups > 100:
sre_compile.py(587):     groupindex = p.pattern.groupdict
sre_compile.py(588):     indexgroup = [None] * p.pattern.groups
sre_compile.py(589):     for k, i in groupindex.items():
sre_compile.py(592):     return _sre.compile(
sre_compile.py(593):         pattern, flags | p.pattern.flags, code,
sre_compile.py(594):         p.pattern.groups-1,
sre_compile.py(595):         groupindex, indexgroup
re.py(252):     if not bypass_cache:
re.py(253):         if len(_cache) >= _MAXCACHE:
re.py(255):         if p.flags & LOCALE:
re.py(260):             loc = None
re.py(261):         _cache[cachekey] = p, loc
re.py(262):     return p
textwrap.py(372): _leading_whitespace_re = re.compile('(^[ \t]*)(?:[^ \t\n])', re.MULTILINE)
 --- modulename: re, funcname: compile
re.py(194):     return _compile(pattern, flags)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(240):         except KeyError:
re.py(241):             pass
re.py(242):     if isinstance(pattern, _pattern_type):
re.py(246):     if not sre_compile.isstring(pattern):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
re.py(248):     try:
re.py(249):         p = sre_compile.compile(pattern, flags)
 --- modulename: sre_compile, funcname: compile
sre_compile.py(570):     if isstring(p):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
sre_compile.py(571):         pattern = p
sre_compile.py(572):         p = sre_parse.parse(p, flags)
 --- modulename: sre_parse, funcname: parse
sre_parse.py(709):     source = Tokenizer(str)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(190):         self.string = string
sre_parse.py(191):         self.index = 0
sre_parse.py(192):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(711):     if pattern is None:
sre_parse.py(712):         pattern = Pattern()
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(68):         self.flags = 0
sre_parse.py(69):         self.open = []
sre_parse.py(70):         self.groups = 1
sre_parse.py(71):         self.groupdict = {}
sre_parse.py(72):         self.lookbehind = 0
sre_parse.py(713):     pattern.flags = flags
sre_parse.py(714):     pattern.str = str
sre_parse.py(716):     p = _parse_sub(source, pattern, 0)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(692):             subpatternappend((AT, AT_BEGINNING))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(493):                 min, max = 0, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(549):                 group = 0
sre_parse.py(551):                 if sourcematch("P"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(600):                 elif sourcematch(":"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(602):                     group = 2
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(670):                     group = None
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(438):                 setappend((NEGATE, None))
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(415):             break # end of pattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(328):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(718):     tail = source.get()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(719):     if tail == ")":
sre_parse.py(721):     elif tail:
sre_parse.py(724):     if flags & SRE_FLAG_DEBUG:
sre_parse.py(727):     if not (flags & SRE_FLAG_VERBOSE) and p.pattern.flags & SRE_FLAG_VERBOSE:
sre_parse.py(732):     return p
sre_compile.py(576):     code = _code(p, flags)
 --- modulename: sre_compile, funcname: _code
sre_compile.py(554):     flags = p.pattern.flags | flags
sre_compile.py(555):     code = []
sre_compile.py(558):     _compile_info(code, p, flags)
 --- modulename: sre_compile, funcname: _compile_info
sre_compile.py(437):     lo, hi = pattern.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(183):             elif op == SUCCESS:
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_compile.py(438):     if lo == 0:
sre_compile.py(441):     prefix = []
sre_compile.py(442):     prefixappend = prefix.append
sre_compile.py(443):     prefix_skip = 0
sre_compile.py(444):     charset = [] # not used
sre_compile.py(445):     charsetappend = charset.append
sre_compile.py(446):     if not (flags & SRE_FLAG_IGNORECASE):
sre_compile.py(448):         for op, av in pattern.data:
sre_compile.py(449):             if op is LITERAL:
sre_compile.py(453):             elif op is SUBPATTERN and len(av[1]) == 1:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_compile.py(460):                 break
sre_compile.py(462):         if not prefix and pattern.data:
sre_compile.py(463):             op, av = pattern.data[0]
sre_compile.py(464):             if op is SUBPATTERN and av[1]:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_compile.py(465):                 op, av = av[1][0]
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(466):                 if op is LITERAL:
sre_compile.py(468):                 elif op is BRANCH:
sre_compile.py(501):     emit = code.append
sre_compile.py(502):     emit(OPCODES[INFO])
sre_compile.py(503):     skip = len(code); emit(0)
sre_compile.py(505):     mask = 0
sre_compile.py(506):     if prefix:
sre_compile.py(510):     elif charset:
sre_compile.py(512):     emit(mask)
sre_compile.py(514):     if lo < MAXCODE:
sre_compile.py(515):         emit(lo)
sre_compile.py(519):     if hi < MAXCODE:
sre_compile.py(522):         emit(0)
sre_compile.py(524):     if prefix:
sre_compile.py(535):     elif charset:
sre_compile.py(537):     code[skip] = len(code) - skip
sre_compile.py(561):     _compile(code, p.data, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(155):         elif op in SUCCESS_CODES:
sre_compile.py(157):         elif op in ASSERT_CODES:
sre_compile.py(170):         elif op is CALL:
sre_compile.py(176):         elif op is AT:
sre_compile.py(177):             emit(OPCODES[op])
sre_compile.py(178):             if flags & SRE_FLAG_MULTILINE:
sre_compile.py(179):                 av = AT_MULTILINE.get(av, av)
sre_compile.py(180):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(182):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(184):             emit(ATCODES[av])
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(287):                     out.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(333):                 out.append((RANGE, (p, q - 1)))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(337):             return out
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(235):             pass
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(239):             emit(av[0])
sre_compile.py(240):             emit(av[1])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(563):     code.append(OPCODES[SUCCESS])
sre_compile.py(565):     return code
sre_compile.py(581):     if p.pattern.groups > 100:
sre_compile.py(587):     groupindex = p.pattern.groupdict
sre_compile.py(588):     indexgroup = [None] * p.pattern.groups
sre_compile.py(589):     for k, i in groupindex.items():
sre_compile.py(592):     return _sre.compile(
sre_compile.py(593):         pattern, flags | p.pattern.flags, code,
sre_compile.py(594):         p.pattern.groups-1,
sre_compile.py(595):         groupindex, indexgroup
re.py(252):     if not bypass_cache:
re.py(253):         if len(_cache) >= _MAXCACHE:
re.py(255):         if p.flags & LOCALE:
re.py(260):             loc = None
re.py(261):         _cache[cachekey] = p, loc
re.py(262):     return p
textwrap.py(374): def dedent(text):
textwrap.py(426): if __name__ == "__main__":
optparse.py(79): def _repr(self):
optparse.py(89): try:
optparse.py(90):     from gettext import gettext
 --- modulename: gettext, funcname: <module>
gettext.py(11): """
gettext.py(49): import locale, copy, os, re, struct, sys
 --- modulename: copy, funcname: <module>
copy.py(49): """
copy.py(51): import types
copy.py(52): import weakref
 --- modulename: weakref, funcname: <module>
weakref.py(6): """
weakref.py(12): import UserDict
weakref.py(14): from _weakref import (
weakref.py(23): from _weakrefset import WeakSet, _IterationGuard
weakref.py(25): from exceptions import ReferenceError
weakref.py(28): ProxyTypes = (ProxyType, CallableProxyType)
weakref.py(30): __all__ = ["ref", "proxy", "getweakrefcount", "getweakrefs",
weakref.py(31):            "WeakKeyDictionary", "ReferenceError", "ReferenceType", "ProxyType",
weakref.py(32):            "CallableProxyType", "ProxyTypes", "WeakValueDictionary", 'WeakSet']
weakref.py(35): class WeakValueDictionary(UserDict.UserDict):
 --- modulename: weakref, funcname: WeakValueDictionary
weakref.py(35): class WeakValueDictionary(UserDict.UserDict):
weakref.py(40):     """
weakref.py(47):     def __init__(*args, **kw):
weakref.py(68):     def _commit_removals(self):
weakref.py(76):     def __getitem__(self, key):
weakref.py(83):     def __delitem__(self, key):
weakref.py(88):     def __contains__(self, key):
weakref.py(95):     def has_key(self, key):
weakref.py(102):     def __repr__(self):
weakref.py(105):     def __setitem__(self, key, value):
weakref.py(110):     def clear(self):
weakref.py(115):     def copy(self):
weakref.py(123):     __copy__ = copy
weakref.py(125):     def __deepcopy__(self, memo):
weakref.py(134):     def get(self, key, default=None):
weakref.py(147):     def items(self):
weakref.py(155):     def iteritems(self):
weakref.py(162):     def iterkeys(self):
weakref.py(167):     __iter__ = iterkeys
weakref.py(169):     def itervaluerefs(self):
weakref.py(183):     def itervalues(self):
weakref.py(190):     def popitem(self):
weakref.py(199):     def pop(self, key, *args):
weakref.py(213):     def setdefault(self, key, default=None):
weakref.py(224):     def update(*args, **kwargs):
weakref.py(244):     def valuerefs(self):
weakref.py(256):     def values(self):
weakref.py(265): class KeyedRef(ref):
 --- modulename: weakref, funcname: KeyedRef
weakref.py(265): class KeyedRef(ref):
weakref.py(273):     """
weakref.py(275):     __slots__ = "key",
weakref.py(277):     def __new__(type, ob, callback, key):
weakref.py(282):     def __init__(self, ob, callback, key):
weakref.py(286): class WeakKeyDictionary(UserDict.UserDict):
 --- modulename: weakref, funcname: WeakKeyDictionary
weakref.py(286): class WeakKeyDictionary(UserDict.UserDict):
weakref.py(295):     """
weakref.py(297):     def __init__(self, dict=None):
weakref.py(313):     def _commit_removals(self):
weakref.py(326):     def __delitem__(self, key):
weakref.py(329):     def __getitem__(self, key):
weakref.py(332):     def __repr__(self):
weakref.py(335):     def __setitem__(self, key, value):
weakref.py(338):     def copy(self):
weakref.py(346):     __copy__ = copy
weakref.py(348):     def __deepcopy__(self, memo):
weakref.py(357):     def get(self, key, default=None):
weakref.py(360):     def has_key(self, key):
weakref.py(367):     def __contains__(self, key):
weakref.py(374):     def items(self):
weakref.py(382):     def iteritems(self):
weakref.py(389):     def iterkeyrefs(self):
weakref.py(403):     def iterkeys(self):
weakref.py(410):     __iter__ = iterkeys
weakref.py(412):     def itervalues(self):
weakref.py(417):     def keyrefs(self):
weakref.py(429):     def keys(self):
weakref.py(437):     def popitem(self):
weakref.py(444):     def pop(self, key, *args):
weakref.py(447):     def setdefault(self, key, default=None):
weakref.py(450):     def update(self, dict=None, **kwargs):
copy.py(53): from copy_reg import dispatch_table
copy.py(55): class Error(Exception):
 --- modulename: copy, funcname: Error
copy.py(55): class Error(Exception):
copy.py(56):     pass
copy.py(57): error = Error   # backward compatibility
copy.py(59): try:
copy.py(60):     from org.python.core import PyStringMap
copy.py(61): except ImportError:
copy.py(62):     PyStringMap = None
copy.py(64): __all__ = ["Error", "copy", "deepcopy"]
copy.py(66): def copy(x):
copy.py(99): _copy_dispatch = d = {}
copy.py(101): def _copy_immutable(x):
copy.py(103): for t in (type(None), int, long, float, bool, str, tuple,
copy.py(104):           frozenset, type, xrange, types.ClassType,
copy.py(105):           types.BuiltinFunctionType, type(Ellipsis),
copy.py(106):           types.FunctionType, weakref.ref):
copy.py(107):     d[t] = _copy_immutable
copy.py(106):           types.FunctionType, weakref.ref):
copy.py(107):     d[t] = _copy_immutable
copy.py(106):           types.FunctionType, weakref.ref):
copy.py(107):     d[t] = _copy_immutable
copy.py(106):           types.FunctionType, weakref.ref):
copy.py(107):     d[t] = _copy_immutable
copy.py(106):           types.FunctionType, weakref.ref):
copy.py(107):     d[t] = _copy_immutable
copy.py(106):           types.FunctionType, weakref.ref):
copy.py(107):     d[t] = _copy_immutable
copy.py(106):           types.FunctionType, weakref.ref):
copy.py(107):     d[t] = _copy_immutable
copy.py(106):           types.FunctionType, weakref.ref):
copy.py(107):     d[t] = _copy_immutable
copy.py(106):           types.FunctionType, weakref.ref):
copy.py(107):     d[t] = _copy_immutable
copy.py(106):           types.FunctionType, weakref.ref):
copy.py(107):     d[t] = _copy_immutable
copy.py(106):           types.FunctionType, weakref.ref):
copy.py(107):     d[t] = _copy_immutable
copy.py(106):           types.FunctionType, weakref.ref):
copy.py(107):     d[t] = _copy_immutable
copy.py(106):           types.FunctionType, weakref.ref):
copy.py(107):     d[t] = _copy_immutable
copy.py(106):           types.FunctionType, weakref.ref):
copy.py(107):     d[t] = _copy_immutable
copy.py(106):           types.FunctionType, weakref.ref):
copy.py(107):     d[t] = _copy_immutable
copy.py(106):           types.FunctionType, weakref.ref):
copy.py(108): for name in ("ComplexType", "UnicodeType", "CodeType"):
copy.py(109):     t = getattr(types, name, None)
copy.py(110):     if t is not None:
copy.py(111):         d[t] = _copy_immutable
copy.py(108): for name in ("ComplexType", "UnicodeType", "CodeType"):
copy.py(109):     t = getattr(types, name, None)
copy.py(110):     if t is not None:
copy.py(111):         d[t] = _copy_immutable
copy.py(108): for name in ("ComplexType", "UnicodeType", "CodeType"):
copy.py(109):     t = getattr(types, name, None)
copy.py(110):     if t is not None:
copy.py(111):         d[t] = _copy_immutable
copy.py(108): for name in ("ComplexType", "UnicodeType", "CodeType"):
copy.py(113): def _copy_with_constructor(x):
copy.py(115): for t in (list, dict, set):
copy.py(116):     d[t] = _copy_with_constructor
copy.py(115): for t in (list, dict, set):
copy.py(116):     d[t] = _copy_with_constructor
copy.py(115): for t in (list, dict, set):
copy.py(116):     d[t] = _copy_with_constructor
copy.py(115): for t in (list, dict, set):
copy.py(118): def _copy_with_copy_method(x):
copy.py(120): if PyStringMap is not None:
copy.py(123): def _copy_inst(x):
copy.py(141): d[types.InstanceType] = _copy_inst
copy.py(143): del d
copy.py(145): def deepcopy(x, memo=None, _nil=[]):
copy.py(196): _deepcopy_dispatch = d = {}
copy.py(198): def _deepcopy_atomic(x, memo):
copy.py(200): d[type(None)] = _deepcopy_atomic
copy.py(201): d[type(Ellipsis)] = _deepcopy_atomic
copy.py(202): d[int] = _deepcopy_atomic
copy.py(203): d[long] = _deepcopy_atomic
copy.py(204): d[float] = _deepcopy_atomic
copy.py(205): d[bool] = _deepcopy_atomic
copy.py(206): try:
copy.py(207):     d[complex] = _deepcopy_atomic
copy.py(210): d[str] = _deepcopy_atomic
copy.py(211): try:
copy.py(212):     d[unicode] = _deepcopy_atomic
copy.py(215): try:
copy.py(216):     d[types.CodeType] = _deepcopy_atomic
copy.py(219): d[type] = _deepcopy_atomic
copy.py(220): d[xrange] = _deepcopy_atomic
copy.py(221): d[types.ClassType] = _deepcopy_atomic
copy.py(222): d[types.BuiltinFunctionType] = _deepcopy_atomic
copy.py(223): d[types.FunctionType] = _deepcopy_atomic
copy.py(224): d[weakref.ref] = _deepcopy_atomic
copy.py(226): def _deepcopy_list(x, memo):
copy.py(232): d[list] = _deepcopy_list
copy.py(234): def _deepcopy_tuple(x, memo):
copy.py(251): d[tuple] = _deepcopy_tuple
copy.py(253): def _deepcopy_dict(x, memo):
copy.py(259): d[dict] = _deepcopy_dict
copy.py(260): if PyStringMap is not None:
copy.py(263): def _deepcopy_method(x, memo): # Copy instance methods
copy.py(265): _deepcopy_dispatch[types.MethodType] = _deepcopy_method
copy.py(267): def _keep_alive(x, memo):
copy.py(283): def _deepcopy_inst(x, memo):
copy.py(304): d[types.InstanceType] = _deepcopy_inst
copy.py(306): def _reconstruct(x, info, deep, memo=None):
copy.py(361): del d
copy.py(363): del types
copy.py(366): class _EmptyClass:
 --- modulename: copy, funcname: _EmptyClass
copy.py(366): class _EmptyClass:
copy.py(367):     pass
copy.py(369): def _test():
copy.py(432): if __name__ == '__main__':
gettext.py(50): from errno import ENOENT
gettext.py(53): __all__ = ['NullTranslations', 'GNUTranslations', 'Catalog',
gettext.py(54):            'find', 'translation', 'install', 'textdomain', 'bindtextdomain',
gettext.py(55):            'bind_textdomain_codeset',
gettext.py(56):            'dgettext', 'dngettext', 'gettext', 'lgettext', 'ldgettext',
gettext.py(57):            'ldngettext', 'lngettext', 'ngettext',
gettext.py(60): _default_localedir = os.path.join(sys.prefix, 'share', 'locale')
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
gettext.py(63): def test(condition, true, false):
gettext.py(77): def c2py(plural):
gettext.py(132): def _expand_lang(locale):
gettext.py(175): class NullTranslations:
 --- modulename: gettext, funcname: NullTranslations
gettext.py(175): class NullTranslations:
gettext.py(176):     def __init__(self, fp=None):
gettext.py(184):     def _parse(self, fp):
gettext.py(187):     def add_fallback(self, fallback):
gettext.py(193):     def gettext(self, message):
gettext.py(198):     def lgettext(self, message):
gettext.py(203):     def ngettext(self, msgid1, msgid2, n):
gettext.py(211):     def lngettext(self, msgid1, msgid2, n):
gettext.py(219):     def ugettext(self, message):
gettext.py(224):     def ungettext(self, msgid1, msgid2, n):
gettext.py(232):     def info(self):
gettext.py(235):     def charset(self):
gettext.py(238):     def output_charset(self):
gettext.py(241):     def set_output_charset(self, charset):
gettext.py(244):     def install(self, unicode=False, names=None):
gettext.py(259): class GNUTranslations(NullTranslations):
 --- modulename: gettext, funcname: GNUTranslations
gettext.py(259): class GNUTranslations(NullTranslations):
gettext.py(261):     LE_MAGIC = 0x950412deL
gettext.py(262):     BE_MAGIC = 0xde120495L
gettext.py(264):     def _parse(self, fp):
gettext.py(346):     def gettext(self, message):
gettext.py(360):     def lgettext(self, message):
gettext.py(371):     def ngettext(self, msgid1, msgid2, n):
gettext.py(387):     def lngettext(self, msgid1, msgid2, n):
gettext.py(401):     def ugettext(self, message):
gettext.py(410):     def ungettext(self, msgid1, msgid2, n):
gettext.py(424): def find(domain, localedir=None, languages=None, all=0):
gettext.py(477): _translations = {}
gettext.py(479): def translation(domain, localedir=None, languages=None,
gettext.py(480):                 class_=None, fallback=False, codeset=None):
gettext.py(510): def install(domain, localedir=None, unicode=False, codeset=None, names=None):
gettext.py(517): _localedirs = {}
gettext.py(519): _localecodesets = {}
gettext.py(521): _current_domain = 'messages'
gettext.py(524): def textdomain(domain=None):
gettext.py(531): def bindtextdomain(domain, localedir=None):
gettext.py(538): def bind_textdomain_codeset(domain, codeset=None):
gettext.py(545): def dgettext(domain, message):
gettext.py(553): def ldgettext(domain, message):
gettext.py(561): def dngettext(domain, msgid1, msgid2, n):
gettext.py(572): def ldngettext(domain, msgid1, msgid2, n):
gettext.py(583): def gettext(message):
gettext.py(586): def lgettext(message):
gettext.py(589): def ngettext(msgid1, msgid2, n):
gettext.py(592): def lngettext(msgid1, msgid2, n):
gettext.py(609): Catalog = translation
optparse.py(94): _ = gettext
optparse.py(97): class OptParseError (Exception):
 --- modulename: optparse, funcname: OptParseError
optparse.py(97): class OptParseError (Exception):
optparse.py(98):     def __init__(self, msg):
optparse.py(101):     def __str__(self):
optparse.py(105): class OptionError (OptParseError):
 --- modulename: optparse, funcname: OptionError
optparse.py(105): class OptionError (OptParseError):
optparse.py(109):     """
optparse.py(111):     def __init__(self, msg, option):
optparse.py(115):     def __str__(self):
optparse.py(121): class OptionConflictError (OptionError):
 --- modulename: optparse, funcname: OptionConflictError
optparse.py(121): class OptionConflictError (OptionError):
optparse.py(124):     """
optparse.py(126): class OptionValueError (OptParseError):
 --- modulename: optparse, funcname: OptionValueError
optparse.py(126): class OptionValueError (OptParseError):
optparse.py(130):     """
optparse.py(132): class BadOptionError (OptParseError):
 --- modulename: optparse, funcname: BadOptionError
optparse.py(132): class BadOptionError (OptParseError):
optparse.py(135):     """
optparse.py(136):     def __init__(self, opt_str):
optparse.py(139):     def __str__(self):
optparse.py(142): class AmbiguousOptionError (BadOptionError):
 --- modulename: optparse, funcname: AmbiguousOptionError
optparse.py(142): class AmbiguousOptionError (BadOptionError):
optparse.py(145):     """
optparse.py(146):     def __init__(self, opt_str, possibilities):
optparse.py(150):     def __str__(self):
optparse.py(155): class HelpFormatter:
 --- modulename: optparse, funcname: HelpFormatter
optparse.py(155): class HelpFormatter:
optparse.py(196):     """
optparse.py(198):     NO_DEFAULT_VALUE = "none"
optparse.py(200):     def __init__(self,
optparse.py(225):     def set_parser(self, parser):
optparse.py(228):     def set_short_opt_delimiter(self, delim):
optparse.py(234):     def set_long_opt_delimiter(self, delim):
optparse.py(240):     def indent(self):
optparse.py(244):     def dedent(self):
optparse.py(249):     def format_usage(self, usage):
optparse.py(252):     def format_heading(self, heading):
optparse.py(255):     def _format_text(self, text):
optparse.py(267):     def format_description(self, description):
optparse.py(273):     def format_epilog(self, epilog):
optparse.py(280):     def expand_default(self, option):
optparse.py(290):     def format_option(self, option):
optparse.py(325):     def store_option_strings(self, parser):
optparse.py(343):     def format_option_strings(self, option):
optparse.py(362): class IndentedHelpFormatter (HelpFormatter):
 --- modulename: optparse, funcname: IndentedHelpFormatter
optparse.py(362): class IndentedHelpFormatter (HelpFormatter):
optparse.py(364):     """
optparse.py(367):                  indent_increment=2,
optparse.py(368):                  max_help_position=24,
optparse.py(369):                  width=None,
optparse.py(370):                  short_first=1):
optparse.py(374):     def format_usage(self, usage):
optparse.py(377):     def format_heading(self, heading):
optparse.py(381): class TitledHelpFormatter (HelpFormatter):
 --- modulename: optparse, funcname: TitledHelpFormatter
optparse.py(381): class TitledHelpFormatter (HelpFormatter):
optparse.py(383):     """
optparse.py(386):                  indent_increment=0,
optparse.py(387):                  max_help_position=24,
optparse.py(388):                  width=None,
optparse.py(389):                  short_first=0):
optparse.py(393):     def format_usage(self, usage):
optparse.py(396):     def format_heading(self, heading):
optparse.py(400): def _parse_num(val, type):
optparse.py(413): def _parse_int(val):
optparse.py(416): def _parse_long(val):
optparse.py(419): _builtin_cvt = { "int" : (_parse_int, _("integer")),
 --- modulename: gettext, funcname: gettext
gettext.py(584):     return dgettext(_current_domain, message)
 --- modulename: gettext, funcname: dgettext
gettext.py(546):     try:
gettext.py(547):         t = translation(domain, _localedirs.get(domain, None),
gettext.py(548):                         codeset=_localecodesets.get(domain))
 --- modulename: gettext, funcname: translation
gettext.py(481):     if class_ is None:
gettext.py(482):         class_ = GNUTranslations
gettext.py(483):     mofiles = find(domain, localedir, languages, all=1)
 --- modulename: gettext, funcname: find
gettext.py(426):     if localedir is None:
gettext.py(427):         localedir = _default_localedir
gettext.py(428):     if languages is None:
gettext.py(429):         languages = []
gettext.py(430):         for envar in ('LANGUAGE', 'LC_ALL', 'LC_MESSAGES', 'LANG'):
gettext.py(431):             val = os.environ.get(envar)
 --- modulename: UserDict, funcname: get
UserDict.py(92):         if key not in self:
 --- modulename: UserDict, funcname: __contains__
UserDict.py(104):         return key in self.data
UserDict.py(94):         return self[key]
 --- modulename: UserDict, funcname: __getitem__
UserDict.py(36):         if key in self.data:
UserDict.py(37):             return self.data[key]
gettext.py(432):             if val:
gettext.py(430):         for envar in ('LANGUAGE', 'LC_ALL', 'LC_MESSAGES', 'LANG'):
gettext.py(431):             val = os.environ.get(envar)
 --- modulename: UserDict, funcname: get
UserDict.py(92):         if key not in self:
 --- modulename: UserDict, funcname: __contains__
UserDict.py(104):         return key in self.data
UserDict.py(93):             return failobj
gettext.py(432):             if val:
gettext.py(430):         for envar in ('LANGUAGE', 'LC_ALL', 'LC_MESSAGES', 'LANG'):
gettext.py(431):             val = os.environ.get(envar)
 --- modulename: UserDict, funcname: get
UserDict.py(92):         if key not in self:
 --- modulename: UserDict, funcname: __contains__
UserDict.py(104):         return key in self.data
UserDict.py(93):             return failobj
gettext.py(432):             if val:
gettext.py(430):         for envar in ('LANGUAGE', 'LC_ALL', 'LC_MESSAGES', 'LANG'):
gettext.py(431):             val = os.environ.get(envar)
 --- modulename: UserDict, funcname: get
UserDict.py(92):         if key not in self:
 --- modulename: UserDict, funcname: __contains__
UserDict.py(104):         return key in self.data
UserDict.py(94):         return self[key]
 --- modulename: UserDict, funcname: __getitem__
UserDict.py(36):         if key in self.data:
UserDict.py(37):             return self.data[key]
gettext.py(432):             if val:
gettext.py(433):                 languages = val.split(':')
gettext.py(434):                 break
gettext.py(435):         if 'C' not in languages:
gettext.py(436):             languages.append('C')
gettext.py(438):     nelangs = []
gettext.py(439):     for lang in languages:
gettext.py(440):         for nelang in _expand_lang(lang):
 --- modulename: gettext, funcname: _expand_lang
gettext.py(133):     from locale import normalize
gettext.py(134):     locale = normalize(locale)
 --- modulename: locale, funcname: normalize
locale.py(380):     if isinstance(localename, _unicode):
locale.py(382):     code = localename.translate(_ascii_lower_map)
locale.py(383):     if ':' in code:
locale.py(386):     if '@' in code:
locale.py(389):         modifier = ''
locale.py(390):     if '.' in code:
locale.py(391):         langname, encoding = code.split('.')[:2]
locale.py(397):     lang_enc = langname
locale.py(398):     if encoding:
locale.py(399):         norm_encoding = encoding.replace('-', '')
locale.py(400):         norm_encoding = norm_encoding.replace('_', '')
locale.py(401):         lang_enc += '.' + norm_encoding
locale.py(402):     lookup_name = lang_enc
locale.py(403):     if modifier:
locale.py(405):     code = locale_alias.get(lookup_name, None)
locale.py(406):     if code is not None:
locale.py(410):     if modifier:
locale.py(421):     if encoding:
locale.py(423):         lookup_name = langname
locale.py(424):         if modifier:
locale.py(426):         code = locale_alias.get(lookup_name, None)
locale.py(427):         if code is not None:
locale.py(429):             if '@' not in code:
locale.py(430):                 return _replace_encoding(code, encoding)
 --- modulename: locale, funcname: _replace_encoding
locale.py(348):     if '.' in code:
locale.py(349):         langname = code[:code.index('.')]
locale.py(353):     norm_encoding = encodings.normalize_encoding(encoding)
 --- modulename: __init__, funcname: normalize_encoding
__init__.py(64):     if hasattr(__builtin__, "unicode") and isinstance(encoding, unicode):
__init__.py(69):     return '_'.join(encoding.translate(_norm_encoding_map).split())
locale.py(355):     norm_encoding = encodings.aliases.aliases.get(norm_encoding,
locale.py(356):                                                   norm_encoding)
locale.py(358):     encoding = locale_encoding_alias.get(norm_encoding,
locale.py(359):                                          norm_encoding)
locale.py(361):     return langname + '.' + encoding
gettext.py(135):     COMPONENT_CODESET   = 1 << 0
gettext.py(136):     COMPONENT_TERRITORY = 1 << 1
gettext.py(137):     COMPONENT_MODIFIER  = 1 << 2
gettext.py(139):     mask = 0
gettext.py(140):     pos = locale.find('@')
gettext.py(141):     if pos >= 0:
gettext.py(146):         modifier = ''
gettext.py(147):     pos = locale.find('.')
gettext.py(148):     if pos >= 0:
gettext.py(149):         codeset = locale[pos:]
gettext.py(150):         locale = locale[:pos]
gettext.py(151):         mask |= COMPONENT_CODESET
gettext.py(154):     pos = locale.find('_')
gettext.py(155):     if pos >= 0:
gettext.py(156):         territory = locale[pos:]
gettext.py(157):         locale = locale[:pos]
gettext.py(158):         mask |= COMPONENT_TERRITORY
gettext.py(161):     language = locale
gettext.py(162):     ret = []
gettext.py(163):     for i in range(mask+1):
gettext.py(164):         if not (i & ~mask):  # if all components for this combo exist ...
gettext.py(165):             val = language
gettext.py(166):             if i & COMPONENT_TERRITORY: val += territory
gettext.py(167):             if i & COMPONENT_CODESET:   val += codeset
gettext.py(168):             if i & COMPONENT_MODIFIER:  val += modifier
gettext.py(169):             ret.append(val)
gettext.py(163):     for i in range(mask+1):
gettext.py(164):         if not (i & ~mask):  # if all components for this combo exist ...
gettext.py(165):             val = language
gettext.py(166):             if i & COMPONENT_TERRITORY: val += territory
gettext.py(167):             if i & COMPONENT_CODESET:   val += codeset
gettext.py(168):             if i & COMPONENT_MODIFIER:  val += modifier
gettext.py(169):             ret.append(val)
gettext.py(163):     for i in range(mask+1):
gettext.py(164):         if not (i & ~mask):  # if all components for this combo exist ...
gettext.py(165):             val = language
gettext.py(166):             if i & COMPONENT_TERRITORY: val += territory
gettext.py(167):             if i & COMPONENT_CODESET:   val += codeset
gettext.py(168):             if i & COMPONENT_MODIFIER:  val += modifier
gettext.py(169):             ret.append(val)
gettext.py(163):     for i in range(mask+1):
gettext.py(164):         if not (i & ~mask):  # if all components for this combo exist ...
gettext.py(165):             val = language
gettext.py(166):             if i & COMPONENT_TERRITORY: val += territory
gettext.py(167):             if i & COMPONENT_CODESET:   val += codeset
gettext.py(168):             if i & COMPONENT_MODIFIER:  val += modifier
gettext.py(169):             ret.append(val)
gettext.py(163):     for i in range(mask+1):
gettext.py(170):     ret.reverse()
gettext.py(171):     return ret
gettext.py(441):             if nelang not in nelangs:
gettext.py(442):                 nelangs.append(nelang)
gettext.py(440):         for nelang in _expand_lang(lang):
gettext.py(441):             if nelang not in nelangs:
gettext.py(442):                 nelangs.append(nelang)
gettext.py(440):         for nelang in _expand_lang(lang):
gettext.py(441):             if nelang not in nelangs:
gettext.py(442):                 nelangs.append(nelang)
gettext.py(440):         for nelang in _expand_lang(lang):
gettext.py(441):             if nelang not in nelangs:
gettext.py(442):                 nelangs.append(nelang)
gettext.py(440):         for nelang in _expand_lang(lang):
gettext.py(439):     for lang in languages:
gettext.py(440):         for nelang in _expand_lang(lang):
 --- modulename: gettext, funcname: _expand_lang
gettext.py(133):     from locale import normalize
gettext.py(134):     locale = normalize(locale)
 --- modulename: locale, funcname: normalize
locale.py(380):     if isinstance(localename, _unicode):
locale.py(382):     code = localename.translate(_ascii_lower_map)
locale.py(383):     if ':' in code:
locale.py(386):     if '@' in code:
locale.py(389):         modifier = ''
locale.py(390):     if '.' in code:
locale.py(393):         langname = code
locale.py(394):         encoding = ''
locale.py(397):     lang_enc = langname
locale.py(398):     if encoding:
locale.py(402):     lookup_name = lang_enc
locale.py(403):     if modifier:
locale.py(405):     code = locale_alias.get(lookup_name, None)
locale.py(406):     if code is not None:
locale.py(407):         return code
gettext.py(135):     COMPONENT_CODESET   = 1 << 0
gettext.py(136):     COMPONENT_TERRITORY = 1 << 1
gettext.py(137):     COMPONENT_MODIFIER  = 1 << 2
gettext.py(139):     mask = 0
gettext.py(140):     pos = locale.find('@')
gettext.py(141):     if pos >= 0:
gettext.py(146):         modifier = ''
gettext.py(147):     pos = locale.find('.')
gettext.py(148):     if pos >= 0:
gettext.py(153):         codeset = ''
gettext.py(154):     pos = locale.find('_')
gettext.py(155):     if pos >= 0:
gettext.py(160):         territory = ''
gettext.py(161):     language = locale
gettext.py(162):     ret = []
gettext.py(163):     for i in range(mask+1):
gettext.py(164):         if not (i & ~mask):  # if all components for this combo exist ...
gettext.py(165):             val = language
gettext.py(166):             if i & COMPONENT_TERRITORY: val += territory
gettext.py(167):             if i & COMPONENT_CODESET:   val += codeset
gettext.py(168):             if i & COMPONENT_MODIFIER:  val += modifier
gettext.py(169):             ret.append(val)
gettext.py(163):     for i in range(mask+1):
gettext.py(170):     ret.reverse()
gettext.py(171):     return ret
gettext.py(441):             if nelang not in nelangs:
gettext.py(442):                 nelangs.append(nelang)
gettext.py(440):         for nelang in _expand_lang(lang):
gettext.py(439):     for lang in languages:
gettext.py(444):     if all:
gettext.py(445):         result = []
gettext.py(448):     for lang in nelangs:
gettext.py(449):         if lang == 'C':
gettext.py(451):         mofile = os.path.join(localedir, lang, 'LC_MESSAGES', '%s.mo' % domain)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
gettext.py(452):         mofile_lp = os.path.join("/usr/share/locale-langpack", lang,
gettext.py(453):                                'LC_MESSAGES', '%s.mo' % domain)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
gettext.py(459):         if os.path.exists(mofile):
 --- modulename: genericpath, funcname: exists
genericpath.py(25):     try:
genericpath.py(26):         os.stat(path)
genericpath.py(27):     except os.error:
genericpath.py(28):         return False
gettext.py(466):         if os.path.exists(mofile_lp): 
 --- modulename: genericpath, funcname: exists
genericpath.py(25):     try:
genericpath.py(26):         os.stat(path)
genericpath.py(27):     except os.error:
genericpath.py(28):         return False
gettext.py(448):     for lang in nelangs:
gettext.py(449):         if lang == 'C':
gettext.py(451):         mofile = os.path.join(localedir, lang, 'LC_MESSAGES', '%s.mo' % domain)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
gettext.py(452):         mofile_lp = os.path.join("/usr/share/locale-langpack", lang,
gettext.py(453):                                'LC_MESSAGES', '%s.mo' % domain)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
gettext.py(459):         if os.path.exists(mofile):
 --- modulename: genericpath, funcname: exists
genericpath.py(25):     try:
genericpath.py(26):         os.stat(path)
genericpath.py(27):     except os.error:
genericpath.py(28):         return False
gettext.py(466):         if os.path.exists(mofile_lp): 
 --- modulename: genericpath, funcname: exists
genericpath.py(25):     try:
genericpath.py(26):         os.stat(path)
genericpath.py(27):     except os.error:
genericpath.py(28):         return False
gettext.py(448):     for lang in nelangs:
gettext.py(449):         if lang == 'C':
gettext.py(451):         mofile = os.path.join(localedir, lang, 'LC_MESSAGES', '%s.mo' % domain)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
gettext.py(452):         mofile_lp = os.path.join("/usr/share/locale-langpack", lang,
gettext.py(453):                                'LC_MESSAGES', '%s.mo' % domain)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
gettext.py(459):         if os.path.exists(mofile):
 --- modulename: genericpath, funcname: exists
genericpath.py(25):     try:
genericpath.py(26):         os.stat(path)
genericpath.py(27):     except os.error:
genericpath.py(28):         return False
gettext.py(466):         if os.path.exists(mofile_lp): 
 --- modulename: genericpath, funcname: exists
genericpath.py(25):     try:
genericpath.py(26):         os.stat(path)
genericpath.py(27):     except os.error:
genericpath.py(28):         return False
gettext.py(448):     for lang in nelangs:
gettext.py(449):         if lang == 'C':
gettext.py(451):         mofile = os.path.join(localedir, lang, 'LC_MESSAGES', '%s.mo' % domain)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
gettext.py(452):         mofile_lp = os.path.join("/usr/share/locale-langpack", lang,
gettext.py(453):                                'LC_MESSAGES', '%s.mo' % domain)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
gettext.py(459):         if os.path.exists(mofile):
 --- modulename: genericpath, funcname: exists
genericpath.py(25):     try:
genericpath.py(26):         os.stat(path)
genericpath.py(27):     except os.error:
genericpath.py(28):         return False
gettext.py(466):         if os.path.exists(mofile_lp): 
 --- modulename: genericpath, funcname: exists
genericpath.py(25):     try:
genericpath.py(26):         os.stat(path)
genericpath.py(27):     except os.error:
genericpath.py(28):         return False
gettext.py(448):     for lang in nelangs:
gettext.py(449):         if lang == 'C':
gettext.py(450):             break
gettext.py(472):     return result
gettext.py(484):     if not mofiles:
gettext.py(485):         if fallback:
gettext.py(487):         raise IOError(ENOENT, 'No translation file found for domain', domain)
gettext.py(549):     except IOError:
gettext.py(550):         return message
optparse.py(420):                  "long" : (_parse_long, _("long integer")),
 --- modulename: gettext, funcname: gettext
gettext.py(584):     return dgettext(_current_domain, message)
 --- modulename: gettext, funcname: dgettext
gettext.py(546):     try:
gettext.py(547):         t = translation(domain, _localedirs.get(domain, None),
gettext.py(548):                         codeset=_localecodesets.get(domain))
 --- modulename: gettext, funcname: translation
gettext.py(481):     if class_ is None:
gettext.py(482):         class_ = GNUTranslations
gettext.py(483):     mofiles = find(domain, localedir, languages, all=1)
 --- modulename: gettext, funcname: find
gettext.py(426):     if localedir is None:
gettext.py(427):         localedir = _default_localedir
gettext.py(428):     if languages is None:
gettext.py(429):         languages = []
gettext.py(430):         for envar in ('LANGUAGE', 'LC_ALL', 'LC_MESSAGES', 'LANG'):
gettext.py(431):             val = os.environ.get(envar)
 --- modulename: UserDict, funcname: get
UserDict.py(92):         if key not in self:
 --- modulename: UserDict, funcname: __contains__
UserDict.py(104):         return key in self.data
UserDict.py(94):         return self[key]
 --- modulename: UserDict, funcname: __getitem__
UserDict.py(36):         if key in self.data:
UserDict.py(37):             return self.data[key]
gettext.py(432):             if val:
gettext.py(430):         for envar in ('LANGUAGE', 'LC_ALL', 'LC_MESSAGES', 'LANG'):
gettext.py(431):             val = os.environ.get(envar)
 --- modulename: UserDict, funcname: get
UserDict.py(92):         if key not in self:
 --- modulename: UserDict, funcname: __contains__
UserDict.py(104):         return key in self.data
UserDict.py(93):             return failobj
gettext.py(432):             if val:
gettext.py(430):         for envar in ('LANGUAGE', 'LC_ALL', 'LC_MESSAGES', 'LANG'):
gettext.py(431):             val = os.environ.get(envar)
 --- modulename: UserDict, funcname: get
UserDict.py(92):         if key not in self:
 --- modulename: UserDict, funcname: __contains__
UserDict.py(104):         return key in self.data
UserDict.py(93):             return failobj
gettext.py(432):             if val:
gettext.py(430):         for envar in ('LANGUAGE', 'LC_ALL', 'LC_MESSAGES', 'LANG'):
gettext.py(431):             val = os.environ.get(envar)
 --- modulename: UserDict, funcname: get
UserDict.py(92):         if key not in self:
 --- modulename: UserDict, funcname: __contains__
UserDict.py(104):         return key in self.data
UserDict.py(94):         return self[key]
 --- modulename: UserDict, funcname: __getitem__
UserDict.py(36):         if key in self.data:
UserDict.py(37):             return self.data[key]
gettext.py(432):             if val:
gettext.py(433):                 languages = val.split(':')
gettext.py(434):                 break
gettext.py(435):         if 'C' not in languages:
gettext.py(436):             languages.append('C')
gettext.py(438):     nelangs = []
gettext.py(439):     for lang in languages:
gettext.py(440):         for nelang in _expand_lang(lang):
 --- modulename: gettext, funcname: _expand_lang
gettext.py(133):     from locale import normalize
gettext.py(134):     locale = normalize(locale)
 --- modulename: locale, funcname: normalize
locale.py(380):     if isinstance(localename, _unicode):
locale.py(382):     code = localename.translate(_ascii_lower_map)
locale.py(383):     if ':' in code:
locale.py(386):     if '@' in code:
locale.py(389):         modifier = ''
locale.py(390):     if '.' in code:
locale.py(391):         langname, encoding = code.split('.')[:2]
locale.py(397):     lang_enc = langname
locale.py(398):     if encoding:
locale.py(399):         norm_encoding = encoding.replace('-', '')
locale.py(400):         norm_encoding = norm_encoding.replace('_', '')
locale.py(401):         lang_enc += '.' + norm_encoding
locale.py(402):     lookup_name = lang_enc
locale.py(403):     if modifier:
locale.py(405):     code = locale_alias.get(lookup_name, None)
locale.py(406):     if code is not None:
locale.py(410):     if modifier:
locale.py(421):     if encoding:
locale.py(423):         lookup_name = langname
locale.py(424):         if modifier:
locale.py(426):         code = locale_alias.get(lookup_name, None)
locale.py(427):         if code is not None:
locale.py(429):             if '@' not in code:
locale.py(430):                 return _replace_encoding(code, encoding)
 --- modulename: locale, funcname: _replace_encoding
locale.py(348):     if '.' in code:
locale.py(349):         langname = code[:code.index('.')]
locale.py(353):     norm_encoding = encodings.normalize_encoding(encoding)
 --- modulename: __init__, funcname: normalize_encoding
__init__.py(64):     if hasattr(__builtin__, "unicode") and isinstance(encoding, unicode):
__init__.py(69):     return '_'.join(encoding.translate(_norm_encoding_map).split())
locale.py(355):     norm_encoding = encodings.aliases.aliases.get(norm_encoding,
locale.py(356):                                                   norm_encoding)
locale.py(358):     encoding = locale_encoding_alias.get(norm_encoding,
locale.py(359):                                          norm_encoding)
locale.py(361):     return langname + '.' + encoding
gettext.py(135):     COMPONENT_CODESET   = 1 << 0
gettext.py(136):     COMPONENT_TERRITORY = 1 << 1
gettext.py(137):     COMPONENT_MODIFIER  = 1 << 2
gettext.py(139):     mask = 0
gettext.py(140):     pos = locale.find('@')
gettext.py(141):     if pos >= 0:
gettext.py(146):         modifier = ''
gettext.py(147):     pos = locale.find('.')
gettext.py(148):     if pos >= 0:
gettext.py(149):         codeset = locale[pos:]
gettext.py(150):         locale = locale[:pos]
gettext.py(151):         mask |= COMPONENT_CODESET
gettext.py(154):     pos = locale.find('_')
gettext.py(155):     if pos >= 0:
gettext.py(156):         territory = locale[pos:]
gettext.py(157):         locale = locale[:pos]
gettext.py(158):         mask |= COMPONENT_TERRITORY
gettext.py(161):     language = locale
gettext.py(162):     ret = []
gettext.py(163):     for i in range(mask+1):
gettext.py(164):         if not (i & ~mask):  # if all components for this combo exist ...
gettext.py(165):             val = language
gettext.py(166):             if i & COMPONENT_TERRITORY: val += territory
gettext.py(167):             if i & COMPONENT_CODESET:   val += codeset
gettext.py(168):             if i & COMPONENT_MODIFIER:  val += modifier
gettext.py(169):             ret.append(val)
gettext.py(163):     for i in range(mask+1):
gettext.py(164):         if not (i & ~mask):  # if all components for this combo exist ...
gettext.py(165):             val = language
gettext.py(166):             if i & COMPONENT_TERRITORY: val += territory
gettext.py(167):             if i & COMPONENT_CODESET:   val += codeset
gettext.py(168):             if i & COMPONENT_MODIFIER:  val += modifier
gettext.py(169):             ret.append(val)
gettext.py(163):     for i in range(mask+1):
gettext.py(164):         if not (i & ~mask):  # if all components for this combo exist ...
gettext.py(165):             val = language
gettext.py(166):             if i & COMPONENT_TERRITORY: val += territory
gettext.py(167):             if i & COMPONENT_CODESET:   val += codeset
gettext.py(168):             if i & COMPONENT_MODIFIER:  val += modifier
gettext.py(169):             ret.append(val)
gettext.py(163):     for i in range(mask+1):
gettext.py(164):         if not (i & ~mask):  # if all components for this combo exist ...
gettext.py(165):             val = language
gettext.py(166):             if i & COMPONENT_TERRITORY: val += territory
gettext.py(167):             if i & COMPONENT_CODESET:   val += codeset
gettext.py(168):             if i & COMPONENT_MODIFIER:  val += modifier
gettext.py(169):             ret.append(val)
gettext.py(163):     for i in range(mask+1):
gettext.py(170):     ret.reverse()
gettext.py(171):     return ret
gettext.py(441):             if nelang not in nelangs:
gettext.py(442):                 nelangs.append(nelang)
gettext.py(440):         for nelang in _expand_lang(lang):
gettext.py(441):             if nelang not in nelangs:
gettext.py(442):                 nelangs.append(nelang)
gettext.py(440):         for nelang in _expand_lang(lang):
gettext.py(441):             if nelang not in nelangs:
gettext.py(442):                 nelangs.append(nelang)
gettext.py(440):         for nelang in _expand_lang(lang):
gettext.py(441):             if nelang not in nelangs:
gettext.py(442):                 nelangs.append(nelang)
gettext.py(440):         for nelang in _expand_lang(lang):
gettext.py(439):     for lang in languages:
gettext.py(440):         for nelang in _expand_lang(lang):
 --- modulename: gettext, funcname: _expand_lang
gettext.py(133):     from locale import normalize
gettext.py(134):     locale = normalize(locale)
 --- modulename: locale, funcname: normalize
locale.py(380):     if isinstance(localename, _unicode):
locale.py(382):     code = localename.translate(_ascii_lower_map)
locale.py(383):     if ':' in code:
locale.py(386):     if '@' in code:
locale.py(389):         modifier = ''
locale.py(390):     if '.' in code:
locale.py(393):         langname = code
locale.py(394):         encoding = ''
locale.py(397):     lang_enc = langname
locale.py(398):     if encoding:
locale.py(402):     lookup_name = lang_enc
locale.py(403):     if modifier:
locale.py(405):     code = locale_alias.get(lookup_name, None)
locale.py(406):     if code is not None:
locale.py(407):         return code
gettext.py(135):     COMPONENT_CODESET   = 1 << 0
gettext.py(136):     COMPONENT_TERRITORY = 1 << 1
gettext.py(137):     COMPONENT_MODIFIER  = 1 << 2
gettext.py(139):     mask = 0
gettext.py(140):     pos = locale.find('@')
gettext.py(141):     if pos >= 0:
gettext.py(146):         modifier = ''
gettext.py(147):     pos = locale.find('.')
gettext.py(148):     if pos >= 0:
gettext.py(153):         codeset = ''
gettext.py(154):     pos = locale.find('_')
gettext.py(155):     if pos >= 0:
gettext.py(160):         territory = ''
gettext.py(161):     language = locale
gettext.py(162):     ret = []
gettext.py(163):     for i in range(mask+1):
gettext.py(164):         if not (i & ~mask):  # if all components for this combo exist ...
gettext.py(165):             val = language
gettext.py(166):             if i & COMPONENT_TERRITORY: val += territory
gettext.py(167):             if i & COMPONENT_CODESET:   val += codeset
gettext.py(168):             if i & COMPONENT_MODIFIER:  val += modifier
gettext.py(169):             ret.append(val)
gettext.py(163):     for i in range(mask+1):
gettext.py(170):     ret.reverse()
gettext.py(171):     return ret
gettext.py(441):             if nelang not in nelangs:
gettext.py(442):                 nelangs.append(nelang)
gettext.py(440):         for nelang in _expand_lang(lang):
gettext.py(439):     for lang in languages:
gettext.py(444):     if all:
gettext.py(445):         result = []
gettext.py(448):     for lang in nelangs:
gettext.py(449):         if lang == 'C':
gettext.py(451):         mofile = os.path.join(localedir, lang, 'LC_MESSAGES', '%s.mo' % domain)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
gettext.py(452):         mofile_lp = os.path.join("/usr/share/locale-langpack", lang,
gettext.py(453):                                'LC_MESSAGES', '%s.mo' % domain)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
gettext.py(459):         if os.path.exists(mofile):
 --- modulename: genericpath, funcname: exists
genericpath.py(25):     try:
genericpath.py(26):         os.stat(path)
genericpath.py(27):     except os.error:
genericpath.py(28):         return False
gettext.py(466):         if os.path.exists(mofile_lp): 
 --- modulename: genericpath, funcname: exists
genericpath.py(25):     try:
genericpath.py(26):         os.stat(path)
genericpath.py(27):     except os.error:
genericpath.py(28):         return False
gettext.py(448):     for lang in nelangs:
gettext.py(449):         if lang == 'C':
gettext.py(451):         mofile = os.path.join(localedir, lang, 'LC_MESSAGES', '%s.mo' % domain)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
gettext.py(452):         mofile_lp = os.path.join("/usr/share/locale-langpack", lang,
gettext.py(453):                                'LC_MESSAGES', '%s.mo' % domain)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
gettext.py(459):         if os.path.exists(mofile):
 --- modulename: genericpath, funcname: exists
genericpath.py(25):     try:
genericpath.py(26):         os.stat(path)
genericpath.py(27):     except os.error:
genericpath.py(28):         return False
gettext.py(466):         if os.path.exists(mofile_lp): 
 --- modulename: genericpath, funcname: exists
genericpath.py(25):     try:
genericpath.py(26):         os.stat(path)
genericpath.py(27):     except os.error:
genericpath.py(28):         return False
gettext.py(448):     for lang in nelangs:
gettext.py(449):         if lang == 'C':
gettext.py(451):         mofile = os.path.join(localedir, lang, 'LC_MESSAGES', '%s.mo' % domain)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
gettext.py(452):         mofile_lp = os.path.join("/usr/share/locale-langpack", lang,
gettext.py(453):                                'LC_MESSAGES', '%s.mo' % domain)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
gettext.py(459):         if os.path.exists(mofile):
 --- modulename: genericpath, funcname: exists
genericpath.py(25):     try:
genericpath.py(26):         os.stat(path)
genericpath.py(27):     except os.error:
genericpath.py(28):         return False
gettext.py(466):         if os.path.exists(mofile_lp): 
 --- modulename: genericpath, funcname: exists
genericpath.py(25):     try:
genericpath.py(26):         os.stat(path)
genericpath.py(27):     except os.error:
genericpath.py(28):         return False
gettext.py(448):     for lang in nelangs:
gettext.py(449):         if lang == 'C':
gettext.py(451):         mofile = os.path.join(localedir, lang, 'LC_MESSAGES', '%s.mo' % domain)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
gettext.py(452):         mofile_lp = os.path.join("/usr/share/locale-langpack", lang,
gettext.py(453):                                'LC_MESSAGES', '%s.mo' % domain)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
gettext.py(459):         if os.path.exists(mofile):
 --- modulename: genericpath, funcname: exists
genericpath.py(25):     try:
genericpath.py(26):         os.stat(path)
genericpath.py(27):     except os.error:
genericpath.py(28):         return False
gettext.py(466):         if os.path.exists(mofile_lp): 
 --- modulename: genericpath, funcname: exists
genericpath.py(25):     try:
genericpath.py(26):         os.stat(path)
genericpath.py(27):     except os.error:
genericpath.py(28):         return False
gettext.py(448):     for lang in nelangs:
gettext.py(449):         if lang == 'C':
gettext.py(450):             break
gettext.py(472):     return result
gettext.py(484):     if not mofiles:
gettext.py(485):         if fallback:
gettext.py(487):         raise IOError(ENOENT, 'No translation file found for domain', domain)
gettext.py(549):     except IOError:
gettext.py(550):         return message
optparse.py(421):                  "float" : (float, _("floating-point")),
 --- modulename: gettext, funcname: gettext
gettext.py(584):     return dgettext(_current_domain, message)
 --- modulename: gettext, funcname: dgettext
gettext.py(546):     try:
gettext.py(547):         t = translation(domain, _localedirs.get(domain, None),
gettext.py(548):                         codeset=_localecodesets.get(domain))
 --- modulename: gettext, funcname: translation
gettext.py(481):     if class_ is None:
gettext.py(482):         class_ = GNUTranslations
gettext.py(483):     mofiles = find(domain, localedir, languages, all=1)
 --- modulename: gettext, funcname: find
gettext.py(426):     if localedir is None:
gettext.py(427):         localedir = _default_localedir
gettext.py(428):     if languages is None:
gettext.py(429):         languages = []
gettext.py(430):         for envar in ('LANGUAGE', 'LC_ALL', 'LC_MESSAGES', 'LANG'):
gettext.py(431):             val = os.environ.get(envar)
 --- modulename: UserDict, funcname: get
UserDict.py(92):         if key not in self:
 --- modulename: UserDict, funcname: __contains__
UserDict.py(104):         return key in self.data
UserDict.py(94):         return self[key]
 --- modulename: UserDict, funcname: __getitem__
UserDict.py(36):         if key in self.data:
UserDict.py(37):             return self.data[key]
gettext.py(432):             if val:
gettext.py(430):         for envar in ('LANGUAGE', 'LC_ALL', 'LC_MESSAGES', 'LANG'):
gettext.py(431):             val = os.environ.get(envar)
 --- modulename: UserDict, funcname: get
UserDict.py(92):         if key not in self:
 --- modulename: UserDict, funcname: __contains__
UserDict.py(104):         return key in self.data
UserDict.py(93):             return failobj
gettext.py(432):             if val:
gettext.py(430):         for envar in ('LANGUAGE', 'LC_ALL', 'LC_MESSAGES', 'LANG'):
gettext.py(431):             val = os.environ.get(envar)
 --- modulename: UserDict, funcname: get
UserDict.py(92):         if key not in self:
 --- modulename: UserDict, funcname: __contains__
UserDict.py(104):         return key in self.data
UserDict.py(93):             return failobj
gettext.py(432):             if val:
gettext.py(430):         for envar in ('LANGUAGE', 'LC_ALL', 'LC_MESSAGES', 'LANG'):
gettext.py(431):             val = os.environ.get(envar)
 --- modulename: UserDict, funcname: get
UserDict.py(92):         if key not in self:
 --- modulename: UserDict, funcname: __contains__
UserDict.py(104):         return key in self.data
UserDict.py(94):         return self[key]
 --- modulename: UserDict, funcname: __getitem__
UserDict.py(36):         if key in self.data:
UserDict.py(37):             return self.data[key]
gettext.py(432):             if val:
gettext.py(433):                 languages = val.split(':')
gettext.py(434):                 break
gettext.py(435):         if 'C' not in languages:
gettext.py(436):             languages.append('C')
gettext.py(438):     nelangs = []
gettext.py(439):     for lang in languages:
gettext.py(440):         for nelang in _expand_lang(lang):
 --- modulename: gettext, funcname: _expand_lang
gettext.py(133):     from locale import normalize
gettext.py(134):     locale = normalize(locale)
 --- modulename: locale, funcname: normalize
locale.py(380):     if isinstance(localename, _unicode):
locale.py(382):     code = localename.translate(_ascii_lower_map)
locale.py(383):     if ':' in code:
locale.py(386):     if '@' in code:
locale.py(389):         modifier = ''
locale.py(390):     if '.' in code:
locale.py(391):         langname, encoding = code.split('.')[:2]
locale.py(397):     lang_enc = langname
locale.py(398):     if encoding:
locale.py(399):         norm_encoding = encoding.replace('-', '')
locale.py(400):         norm_encoding = norm_encoding.replace('_', '')
locale.py(401):         lang_enc += '.' + norm_encoding
locale.py(402):     lookup_name = lang_enc
locale.py(403):     if modifier:
locale.py(405):     code = locale_alias.get(lookup_name, None)
locale.py(406):     if code is not None:
locale.py(410):     if modifier:
locale.py(421):     if encoding:
locale.py(423):         lookup_name = langname
locale.py(424):         if modifier:
locale.py(426):         code = locale_alias.get(lookup_name, None)
locale.py(427):         if code is not None:
locale.py(429):             if '@' not in code:
locale.py(430):                 return _replace_encoding(code, encoding)
 --- modulename: locale, funcname: _replace_encoding
locale.py(348):     if '.' in code:
locale.py(349):         langname = code[:code.index('.')]
locale.py(353):     norm_encoding = encodings.normalize_encoding(encoding)
 --- modulename: __init__, funcname: normalize_encoding
__init__.py(64):     if hasattr(__builtin__, "unicode") and isinstance(encoding, unicode):
__init__.py(69):     return '_'.join(encoding.translate(_norm_encoding_map).split())
locale.py(355):     norm_encoding = encodings.aliases.aliases.get(norm_encoding,
locale.py(356):                                                   norm_encoding)
locale.py(358):     encoding = locale_encoding_alias.get(norm_encoding,
locale.py(359):                                          norm_encoding)
locale.py(361):     return langname + '.' + encoding
gettext.py(135):     COMPONENT_CODESET   = 1 << 0
gettext.py(136):     COMPONENT_TERRITORY = 1 << 1
gettext.py(137):     COMPONENT_MODIFIER  = 1 << 2
gettext.py(139):     mask = 0
gettext.py(140):     pos = locale.find('@')
gettext.py(141):     if pos >= 0:
gettext.py(146):         modifier = ''
gettext.py(147):     pos = locale.find('.')
gettext.py(148):     if pos >= 0:
gettext.py(149):         codeset = locale[pos:]
gettext.py(150):         locale = locale[:pos]
gettext.py(151):         mask |= COMPONENT_CODESET
gettext.py(154):     pos = locale.find('_')
gettext.py(155):     if pos >= 0:
gettext.py(156):         territory = locale[pos:]
gettext.py(157):         locale = locale[:pos]
gettext.py(158):         mask |= COMPONENT_TERRITORY
gettext.py(161):     language = locale
gettext.py(162):     ret = []
gettext.py(163):     for i in range(mask+1):
gettext.py(164):         if not (i & ~mask):  # if all components for this combo exist ...
gettext.py(165):             val = language
gettext.py(166):             if i & COMPONENT_TERRITORY: val += territory
gettext.py(167):             if i & COMPONENT_CODESET:   val += codeset
gettext.py(168):             if i & COMPONENT_MODIFIER:  val += modifier
gettext.py(169):             ret.append(val)
gettext.py(163):     for i in range(mask+1):
gettext.py(164):         if not (i & ~mask):  # if all components for this combo exist ...
gettext.py(165):             val = language
gettext.py(166):             if i & COMPONENT_TERRITORY: val += territory
gettext.py(167):             if i & COMPONENT_CODESET:   val += codeset
gettext.py(168):             if i & COMPONENT_MODIFIER:  val += modifier
gettext.py(169):             ret.append(val)
gettext.py(163):     for i in range(mask+1):
gettext.py(164):         if not (i & ~mask):  # if all components for this combo exist ...
gettext.py(165):             val = language
gettext.py(166):             if i & COMPONENT_TERRITORY: val += territory
gettext.py(167):             if i & COMPONENT_CODESET:   val += codeset
gettext.py(168):             if i & COMPONENT_MODIFIER:  val += modifier
gettext.py(169):             ret.append(val)
gettext.py(163):     for i in range(mask+1):
gettext.py(164):         if not (i & ~mask):  # if all components for this combo exist ...
gettext.py(165):             val = language
gettext.py(166):             if i & COMPONENT_TERRITORY: val += territory
gettext.py(167):             if i & COMPONENT_CODESET:   val += codeset
gettext.py(168):             if i & COMPONENT_MODIFIER:  val += modifier
gettext.py(169):             ret.append(val)
gettext.py(163):     for i in range(mask+1):
gettext.py(170):     ret.reverse()
gettext.py(171):     return ret
gettext.py(441):             if nelang not in nelangs:
gettext.py(442):                 nelangs.append(nelang)
gettext.py(440):         for nelang in _expand_lang(lang):
gettext.py(441):             if nelang not in nelangs:
gettext.py(442):                 nelangs.append(nelang)
gettext.py(440):         for nelang in _expand_lang(lang):
gettext.py(441):             if nelang not in nelangs:
gettext.py(442):                 nelangs.append(nelang)
gettext.py(440):         for nelang in _expand_lang(lang):
gettext.py(441):             if nelang not in nelangs:
gettext.py(442):                 nelangs.append(nelang)
gettext.py(440):         for nelang in _expand_lang(lang):
gettext.py(439):     for lang in languages:
gettext.py(440):         for nelang in _expand_lang(lang):
 --- modulename: gettext, funcname: _expand_lang
gettext.py(133):     from locale import normalize
gettext.py(134):     locale = normalize(locale)
 --- modulename: locale, funcname: normalize
locale.py(380):     if isinstance(localename, _unicode):
locale.py(382):     code = localename.translate(_ascii_lower_map)
locale.py(383):     if ':' in code:
locale.py(386):     if '@' in code:
locale.py(389):         modifier = ''
locale.py(390):     if '.' in code:
locale.py(393):         langname = code
locale.py(394):         encoding = ''
locale.py(397):     lang_enc = langname
locale.py(398):     if encoding:
locale.py(402):     lookup_name = lang_enc
locale.py(403):     if modifier:
locale.py(405):     code = locale_alias.get(lookup_name, None)
locale.py(406):     if code is not None:
locale.py(407):         return code
gettext.py(135):     COMPONENT_CODESET   = 1 << 0
gettext.py(136):     COMPONENT_TERRITORY = 1 << 1
gettext.py(137):     COMPONENT_MODIFIER  = 1 << 2
gettext.py(139):     mask = 0
gettext.py(140):     pos = locale.find('@')
gettext.py(141):     if pos >= 0:
gettext.py(146):         modifier = ''
gettext.py(147):     pos = locale.find('.')
gettext.py(148):     if pos >= 0:
gettext.py(153):         codeset = ''
gettext.py(154):     pos = locale.find('_')
gettext.py(155):     if pos >= 0:
gettext.py(160):         territory = ''
gettext.py(161):     language = locale
gettext.py(162):     ret = []
gettext.py(163):     for i in range(mask+1):
gettext.py(164):         if not (i & ~mask):  # if all components for this combo exist ...
gettext.py(165):             val = language
gettext.py(166):             if i & COMPONENT_TERRITORY: val += territory
gettext.py(167):             if i & COMPONENT_CODESET:   val += codeset
gettext.py(168):             if i & COMPONENT_MODIFIER:  val += modifier
gettext.py(169):             ret.append(val)
gettext.py(163):     for i in range(mask+1):
gettext.py(170):     ret.reverse()
gettext.py(171):     return ret
gettext.py(441):             if nelang not in nelangs:
gettext.py(442):                 nelangs.append(nelang)
gettext.py(440):         for nelang in _expand_lang(lang):
gettext.py(439):     for lang in languages:
gettext.py(444):     if all:
gettext.py(445):         result = []
gettext.py(448):     for lang in nelangs:
gettext.py(449):         if lang == 'C':
gettext.py(451):         mofile = os.path.join(localedir, lang, 'LC_MESSAGES', '%s.mo' % domain)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
gettext.py(452):         mofile_lp = os.path.join("/usr/share/locale-langpack", lang,
gettext.py(453):                                'LC_MESSAGES', '%s.mo' % domain)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
gettext.py(459):         if os.path.exists(mofile):
 --- modulename: genericpath, funcname: exists
genericpath.py(25):     try:
genericpath.py(26):         os.stat(path)
genericpath.py(27):     except os.error:
genericpath.py(28):         return False
gettext.py(466):         if os.path.exists(mofile_lp): 
 --- modulename: genericpath, funcname: exists
genericpath.py(25):     try:
genericpath.py(26):         os.stat(path)
genericpath.py(27):     except os.error:
genericpath.py(28):         return False
gettext.py(448):     for lang in nelangs:
gettext.py(449):         if lang == 'C':
gettext.py(451):         mofile = os.path.join(localedir, lang, 'LC_MESSAGES', '%s.mo' % domain)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
gettext.py(452):         mofile_lp = os.path.join("/usr/share/locale-langpack", lang,
gettext.py(453):                                'LC_MESSAGES', '%s.mo' % domain)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
gettext.py(459):         if os.path.exists(mofile):
 --- modulename: genericpath, funcname: exists
genericpath.py(25):     try:
genericpath.py(26):         os.stat(path)
genericpath.py(27):     except os.error:
genericpath.py(28):         return False
gettext.py(466):         if os.path.exists(mofile_lp): 
 --- modulename: genericpath, funcname: exists
genericpath.py(25):     try:
genericpath.py(26):         os.stat(path)
genericpath.py(27):     except os.error:
genericpath.py(28):         return False
gettext.py(448):     for lang in nelangs:
gettext.py(449):         if lang == 'C':
gettext.py(451):         mofile = os.path.join(localedir, lang, 'LC_MESSAGES', '%s.mo' % domain)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
gettext.py(452):         mofile_lp = os.path.join("/usr/share/locale-langpack", lang,
gettext.py(453):                                'LC_MESSAGES', '%s.mo' % domain)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
gettext.py(459):         if os.path.exists(mofile):
 --- modulename: genericpath, funcname: exists
genericpath.py(25):     try:
genericpath.py(26):         os.stat(path)
genericpath.py(27):     except os.error:
genericpath.py(28):         return False
gettext.py(466):         if os.path.exists(mofile_lp): 
 --- modulename: genericpath, funcname: exists
genericpath.py(25):     try:
genericpath.py(26):         os.stat(path)
genericpath.py(27):     except os.error:
genericpath.py(28):         return False
gettext.py(448):     for lang in nelangs:
gettext.py(449):         if lang == 'C':
gettext.py(451):         mofile = os.path.join(localedir, lang, 'LC_MESSAGES', '%s.mo' % domain)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
gettext.py(452):         mofile_lp = os.path.join("/usr/share/locale-langpack", lang,
gettext.py(453):                                'LC_MESSAGES', '%s.mo' % domain)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
gettext.py(459):         if os.path.exists(mofile):
 --- modulename: genericpath, funcname: exists
genericpath.py(25):     try:
genericpath.py(26):         os.stat(path)
genericpath.py(27):     except os.error:
genericpath.py(28):         return False
gettext.py(466):         if os.path.exists(mofile_lp): 
 --- modulename: genericpath, funcname: exists
genericpath.py(25):     try:
genericpath.py(26):         os.stat(path)
genericpath.py(27):     except os.error:
genericpath.py(28):         return False
gettext.py(448):     for lang in nelangs:
gettext.py(449):         if lang == 'C':
gettext.py(450):             break
gettext.py(472):     return result
gettext.py(484):     if not mofiles:
gettext.py(485):         if fallback:
gettext.py(487):         raise IOError(ENOENT, 'No translation file found for domain', domain)
gettext.py(549):     except IOError:
gettext.py(550):         return message
optparse.py(422):                  "complex" : (complex, _("complex")) }
 --- modulename: gettext, funcname: gettext
gettext.py(584):     return dgettext(_current_domain, message)
 --- modulename: gettext, funcname: dgettext
gettext.py(546):     try:
gettext.py(547):         t = translation(domain, _localedirs.get(domain, None),
gettext.py(548):                         codeset=_localecodesets.get(domain))
 --- modulename: gettext, funcname: translation
gettext.py(481):     if class_ is None:
gettext.py(482):         class_ = GNUTranslations
gettext.py(483):     mofiles = find(domain, localedir, languages, all=1)
 --- modulename: gettext, funcname: find
gettext.py(426):     if localedir is None:
gettext.py(427):         localedir = _default_localedir
gettext.py(428):     if languages is None:
gettext.py(429):         languages = []
gettext.py(430):         for envar in ('LANGUAGE', 'LC_ALL', 'LC_MESSAGES', 'LANG'):
gettext.py(431):             val = os.environ.get(envar)
 --- modulename: UserDict, funcname: get
UserDict.py(92):         if key not in self:
 --- modulename: UserDict, funcname: __contains__
UserDict.py(104):         return key in self.data
UserDict.py(94):         return self[key]
 --- modulename: UserDict, funcname: __getitem__
UserDict.py(36):         if key in self.data:
UserDict.py(37):             return self.data[key]
gettext.py(432):             if val:
gettext.py(430):         for envar in ('LANGUAGE', 'LC_ALL', 'LC_MESSAGES', 'LANG'):
gettext.py(431):             val = os.environ.get(envar)
 --- modulename: UserDict, funcname: get
UserDict.py(92):         if key not in self:
 --- modulename: UserDict, funcname: __contains__
UserDict.py(104):         return key in self.data
UserDict.py(93):             return failobj
gettext.py(432):             if val:
gettext.py(430):         for envar in ('LANGUAGE', 'LC_ALL', 'LC_MESSAGES', 'LANG'):
gettext.py(431):             val = os.environ.get(envar)
 --- modulename: UserDict, funcname: get
UserDict.py(92):         if key not in self:
 --- modulename: UserDict, funcname: __contains__
UserDict.py(104):         return key in self.data
UserDict.py(93):             return failobj
gettext.py(432):             if val:
gettext.py(430):         for envar in ('LANGUAGE', 'LC_ALL', 'LC_MESSAGES', 'LANG'):
gettext.py(431):             val = os.environ.get(envar)
 --- modulename: UserDict, funcname: get
UserDict.py(92):         if key not in self:
 --- modulename: UserDict, funcname: __contains__
UserDict.py(104):         return key in self.data
UserDict.py(94):         return self[key]
 --- modulename: UserDict, funcname: __getitem__
UserDict.py(36):         if key in self.data:
UserDict.py(37):             return self.data[key]
gettext.py(432):             if val:
gettext.py(433):                 languages = val.split(':')
gettext.py(434):                 break
gettext.py(435):         if 'C' not in languages:
gettext.py(436):             languages.append('C')
gettext.py(438):     nelangs = []
gettext.py(439):     for lang in languages:
gettext.py(440):         for nelang in _expand_lang(lang):
 --- modulename: gettext, funcname: _expand_lang
gettext.py(133):     from locale import normalize
gettext.py(134):     locale = normalize(locale)
 --- modulename: locale, funcname: normalize
locale.py(380):     if isinstance(localename, _unicode):
locale.py(382):     code = localename.translate(_ascii_lower_map)
locale.py(383):     if ':' in code:
locale.py(386):     if '@' in code:
locale.py(389):         modifier = ''
locale.py(390):     if '.' in code:
locale.py(391):         langname, encoding = code.split('.')[:2]
locale.py(397):     lang_enc = langname
locale.py(398):     if encoding:
locale.py(399):         norm_encoding = encoding.replace('-', '')
locale.py(400):         norm_encoding = norm_encoding.replace('_', '')
locale.py(401):         lang_enc += '.' + norm_encoding
locale.py(402):     lookup_name = lang_enc
locale.py(403):     if modifier:
locale.py(405):     code = locale_alias.get(lookup_name, None)
locale.py(406):     if code is not None:
locale.py(410):     if modifier:
locale.py(421):     if encoding:
locale.py(423):         lookup_name = langname
locale.py(424):         if modifier:
locale.py(426):         code = locale_alias.get(lookup_name, None)
locale.py(427):         if code is not None:
locale.py(429):             if '@' not in code:
locale.py(430):                 return _replace_encoding(code, encoding)
 --- modulename: locale, funcname: _replace_encoding
locale.py(348):     if '.' in code:
locale.py(349):         langname = code[:code.index('.')]
locale.py(353):     norm_encoding = encodings.normalize_encoding(encoding)
 --- modulename: __init__, funcname: normalize_encoding
__init__.py(64):     if hasattr(__builtin__, "unicode") and isinstance(encoding, unicode):
__init__.py(69):     return '_'.join(encoding.translate(_norm_encoding_map).split())
locale.py(355):     norm_encoding = encodings.aliases.aliases.get(norm_encoding,
locale.py(356):                                                   norm_encoding)
locale.py(358):     encoding = locale_encoding_alias.get(norm_encoding,
locale.py(359):                                          norm_encoding)
locale.py(361):     return langname + '.' + encoding
gettext.py(135):     COMPONENT_CODESET   = 1 << 0
gettext.py(136):     COMPONENT_TERRITORY = 1 << 1
gettext.py(137):     COMPONENT_MODIFIER  = 1 << 2
gettext.py(139):     mask = 0
gettext.py(140):     pos = locale.find('@')
gettext.py(141):     if pos >= 0:
gettext.py(146):         modifier = ''
gettext.py(147):     pos = locale.find('.')
gettext.py(148):     if pos >= 0:
gettext.py(149):         codeset = locale[pos:]
gettext.py(150):         locale = locale[:pos]
gettext.py(151):         mask |= COMPONENT_CODESET
gettext.py(154):     pos = locale.find('_')
gettext.py(155):     if pos >= 0:
gettext.py(156):         territory = locale[pos:]
gettext.py(157):         locale = locale[:pos]
gettext.py(158):         mask |= COMPONENT_TERRITORY
gettext.py(161):     language = locale
gettext.py(162):     ret = []
gettext.py(163):     for i in range(mask+1):
gettext.py(164):         if not (i & ~mask):  # if all components for this combo exist ...
gettext.py(165):             val = language
gettext.py(166):             if i & COMPONENT_TERRITORY: val += territory
gettext.py(167):             if i & COMPONENT_CODESET:   val += codeset
gettext.py(168):             if i & COMPONENT_MODIFIER:  val += modifier
gettext.py(169):             ret.append(val)
gettext.py(163):     for i in range(mask+1):
gettext.py(164):         if not (i & ~mask):  # if all components for this combo exist ...
gettext.py(165):             val = language
gettext.py(166):             if i & COMPONENT_TERRITORY: val += territory
gettext.py(167):             if i & COMPONENT_CODESET:   val += codeset
gettext.py(168):             if i & COMPONENT_MODIFIER:  val += modifier
gettext.py(169):             ret.append(val)
gettext.py(163):     for i in range(mask+1):
gettext.py(164):         if not (i & ~mask):  # if all components for this combo exist ...
gettext.py(165):             val = language
gettext.py(166):             if i & COMPONENT_TERRITORY: val += territory
gettext.py(167):             if i & COMPONENT_CODESET:   val += codeset
gettext.py(168):             if i & COMPONENT_MODIFIER:  val += modifier
gettext.py(169):             ret.append(val)
gettext.py(163):     for i in range(mask+1):
gettext.py(164):         if not (i & ~mask):  # if all components for this combo exist ...
gettext.py(165):             val = language
gettext.py(166):             if i & COMPONENT_TERRITORY: val += territory
gettext.py(167):             if i & COMPONENT_CODESET:   val += codeset
gettext.py(168):             if i & COMPONENT_MODIFIER:  val += modifier
gettext.py(169):             ret.append(val)
gettext.py(163):     for i in range(mask+1):
gettext.py(170):     ret.reverse()
gettext.py(171):     return ret
gettext.py(441):             if nelang not in nelangs:
gettext.py(442):                 nelangs.append(nelang)
gettext.py(440):         for nelang in _expand_lang(lang):
gettext.py(441):             if nelang not in nelangs:
gettext.py(442):                 nelangs.append(nelang)
gettext.py(440):         for nelang in _expand_lang(lang):
gettext.py(441):             if nelang not in nelangs:
gettext.py(442):                 nelangs.append(nelang)
gettext.py(440):         for nelang in _expand_lang(lang):
gettext.py(441):             if nelang not in nelangs:
gettext.py(442):                 nelangs.append(nelang)
gettext.py(440):         for nelang in _expand_lang(lang):
gettext.py(439):     for lang in languages:
gettext.py(440):         for nelang in _expand_lang(lang):
 --- modulename: gettext, funcname: _expand_lang
gettext.py(133):     from locale import normalize
gettext.py(134):     locale = normalize(locale)
 --- modulename: locale, funcname: normalize
locale.py(380):     if isinstance(localename, _unicode):
locale.py(382):     code = localename.translate(_ascii_lower_map)
locale.py(383):     if ':' in code:
locale.py(386):     if '@' in code:
locale.py(389):         modifier = ''
locale.py(390):     if '.' in code:
locale.py(393):         langname = code
locale.py(394):         encoding = ''
locale.py(397):     lang_enc = langname
locale.py(398):     if encoding:
locale.py(402):     lookup_name = lang_enc
locale.py(403):     if modifier:
locale.py(405):     code = locale_alias.get(lookup_name, None)
locale.py(406):     if code is not None:
locale.py(407):         return code
gettext.py(135):     COMPONENT_CODESET   = 1 << 0
gettext.py(136):     COMPONENT_TERRITORY = 1 << 1
gettext.py(137):     COMPONENT_MODIFIER  = 1 << 2
gettext.py(139):     mask = 0
gettext.py(140):     pos = locale.find('@')
gettext.py(141):     if pos >= 0:
gettext.py(146):         modifier = ''
gettext.py(147):     pos = locale.find('.')
gettext.py(148):     if pos >= 0:
gettext.py(153):         codeset = ''
gettext.py(154):     pos = locale.find('_')
gettext.py(155):     if pos >= 0:
gettext.py(160):         territory = ''
gettext.py(161):     language = locale
gettext.py(162):     ret = []
gettext.py(163):     for i in range(mask+1):
gettext.py(164):         if not (i & ~mask):  # if all components for this combo exist ...
gettext.py(165):             val = language
gettext.py(166):             if i & COMPONENT_TERRITORY: val += territory
gettext.py(167):             if i & COMPONENT_CODESET:   val += codeset
gettext.py(168):             if i & COMPONENT_MODIFIER:  val += modifier
gettext.py(169):             ret.append(val)
gettext.py(163):     for i in range(mask+1):
gettext.py(170):     ret.reverse()
gettext.py(171):     return ret
gettext.py(441):             if nelang not in nelangs:
gettext.py(442):                 nelangs.append(nelang)
gettext.py(440):         for nelang in _expand_lang(lang):
gettext.py(439):     for lang in languages:
gettext.py(444):     if all:
gettext.py(445):         result = []
gettext.py(448):     for lang in nelangs:
gettext.py(449):         if lang == 'C':
gettext.py(451):         mofile = os.path.join(localedir, lang, 'LC_MESSAGES', '%s.mo' % domain)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
gettext.py(452):         mofile_lp = os.path.join("/usr/share/locale-langpack", lang,
gettext.py(453):                                'LC_MESSAGES', '%s.mo' % domain)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
gettext.py(459):         if os.path.exists(mofile):
 --- modulename: genericpath, funcname: exists
genericpath.py(25):     try:
genericpath.py(26):         os.stat(path)
genericpath.py(27):     except os.error:
genericpath.py(28):         return False
gettext.py(466):         if os.path.exists(mofile_lp): 
 --- modulename: genericpath, funcname: exists
genericpath.py(25):     try:
genericpath.py(26):         os.stat(path)
genericpath.py(27):     except os.error:
genericpath.py(28):         return False
gettext.py(448):     for lang in nelangs:
gettext.py(449):         if lang == 'C':
gettext.py(451):         mofile = os.path.join(localedir, lang, 'LC_MESSAGES', '%s.mo' % domain)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
gettext.py(452):         mofile_lp = os.path.join("/usr/share/locale-langpack", lang,
gettext.py(453):                                'LC_MESSAGES', '%s.mo' % domain)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
gettext.py(459):         if os.path.exists(mofile):
 --- modulename: genericpath, funcname: exists
genericpath.py(25):     try:
genericpath.py(26):         os.stat(path)
genericpath.py(27):     except os.error:
genericpath.py(28):         return False
gettext.py(466):         if os.path.exists(mofile_lp): 
 --- modulename: genericpath, funcname: exists
genericpath.py(25):     try:
genericpath.py(26):         os.stat(path)
genericpath.py(27):     except os.error:
genericpath.py(28):         return False
gettext.py(448):     for lang in nelangs:
gettext.py(449):         if lang == 'C':
gettext.py(451):         mofile = os.path.join(localedir, lang, 'LC_MESSAGES', '%s.mo' % domain)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
gettext.py(452):         mofile_lp = os.path.join("/usr/share/locale-langpack", lang,
gettext.py(453):                                'LC_MESSAGES', '%s.mo' % domain)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
gettext.py(459):         if os.path.exists(mofile):
 --- modulename: genericpath, funcname: exists
genericpath.py(25):     try:
genericpath.py(26):         os.stat(path)
genericpath.py(27):     except os.error:
genericpath.py(28):         return False
gettext.py(466):         if os.path.exists(mofile_lp): 
 --- modulename: genericpath, funcname: exists
genericpath.py(25):     try:
genericpath.py(26):         os.stat(path)
genericpath.py(27):     except os.error:
genericpath.py(28):         return False
gettext.py(448):     for lang in nelangs:
gettext.py(449):         if lang == 'C':
gettext.py(451):         mofile = os.path.join(localedir, lang, 'LC_MESSAGES', '%s.mo' % domain)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
gettext.py(452):         mofile_lp = os.path.join("/usr/share/locale-langpack", lang,
gettext.py(453):                                'LC_MESSAGES', '%s.mo' % domain)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
gettext.py(459):         if os.path.exists(mofile):
 --- modulename: genericpath, funcname: exists
genericpath.py(25):     try:
genericpath.py(26):         os.stat(path)
genericpath.py(27):     except os.error:
genericpath.py(28):         return False
gettext.py(466):         if os.path.exists(mofile_lp): 
 --- modulename: genericpath, funcname: exists
genericpath.py(25):     try:
genericpath.py(26):         os.stat(path)
genericpath.py(27):     except os.error:
genericpath.py(28):         return False
gettext.py(448):     for lang in nelangs:
gettext.py(449):         if lang == 'C':
gettext.py(450):             break
gettext.py(472):     return result
gettext.py(484):     if not mofiles:
gettext.py(485):         if fallback:
gettext.py(487):         raise IOError(ENOENT, 'No translation file found for domain', domain)
gettext.py(549):     except IOError:
gettext.py(550):         return message
optparse.py(424): def check_builtin(option, opt, value):
optparse.py(432): def check_choice(option, opt, value):
optparse.py(443): NO_DEFAULT = ("NO", "DEFAULT")
optparse.py(446): class Option:
 --- modulename: optparse, funcname: Option
optparse.py(446): class Option:
optparse.py(464):     """
optparse.py(468):     ATTRS = ['action',
optparse.py(469):              'type',
optparse.py(470):              'dest',
optparse.py(471):              'default',
optparse.py(472):              'nargs',
optparse.py(473):              'const',
optparse.py(474):              'choices',
optparse.py(475):              'callback',
optparse.py(476):              'callback_args',
optparse.py(477):              'callback_kwargs',
optparse.py(478):              'help',
optparse.py(479):              'metavar']
optparse.py(492):                "version")
optparse.py(503):                      "count")
optparse.py(509):                      "callback")
optparse.py(514):                             "append")
optparse.py(518):                      "append_const")
optparse.py(522):     TYPES = ("string", "int", "long", "float", "complex", "choice")
optparse.py(540):     TYPE_CHECKER = { "int"    : check_builtin,
optparse.py(541):                      "long"   : check_builtin,
optparse.py(542):                      "float"  : check_builtin,
optparse.py(543):                      "complex": check_builtin,
optparse.py(544):                      "choice" : check_choice,
optparse.py(556):     CHECK_METHODS = None
optparse.py(561):     def __init__(self, *opts, **attrs):
optparse.py(580):     def _check_opt_strings(self, opts):
optparse.py(589):     def _set_opt_strings(self, opts):
optparse.py(610):     def _set_attrs(self, attrs):
optparse.py(630):     def _check_action(self):
optparse.py(636):     def _check_type(self):
optparse.py(666):     def _check_choice(self):
optparse.py(679):     def _check_dest(self):
optparse.py(694):     def _check_const(self):
optparse.py(700):     def _check_nargs(self):
optparse.py(709):     def _check_callback(self):
optparse.py(737):     CHECK_METHODS = [_check_action,
optparse.py(738):                      _check_type,
optparse.py(739):                      _check_choice,
optparse.py(740):                      _check_dest,
optparse.py(741):                      _check_const,
optparse.py(742):                      _check_nargs,
optparse.py(743):                      _check_callback]
optparse.py(748):     def __str__(self):
optparse.py(751):     __repr__ = _repr
optparse.py(753):     def takes_value(self):
optparse.py(756):     def get_opt_string(self):
optparse.py(765):     def check_value(self, opt, value):
optparse.py(772):     def convert_value(self, opt, value):
optparse.py(779):     def process(self, opt, value, values, parser):
optparse.py(791):     def take_action(self, action, dest, opt, value, values, parser):
optparse.py(824): SUPPRESS_HELP = "SUPPRESS"+"HELP"
optparse.py(825): SUPPRESS_USAGE = "SUPPRESS"+"USAGE"
optparse.py(827): try:
optparse.py(828):     basestring
optparse.py(833):     def isbasestring(x):
optparse.py(836): class Values:
 --- modulename: optparse, funcname: Values
optparse.py(836): class Values:
optparse.py(838):     def __init__(self, defaults=None):
optparse.py(843):     def __str__(self):
optparse.py(846):     __repr__ = _repr
optparse.py(848):     def __cmp__(self, other):
optparse.py(856):     def _update_careful(self, dict):
optparse.py(869):     def _update_loose(self, dict):
optparse.py(877):     def _update(self, dict, mode):
optparse.py(885):     def read_module(self, modname, mode="careful"):
optparse.py(890):     def read_file(self, filename, mode="careful"):
optparse.py(895):     def ensure_value(self, attr, value):
optparse.py(901): class OptionContainer:
 --- modulename: optparse, funcname: OptionContainer
optparse.py(901): class OptionContainer:
optparse.py(931):     """
optparse.py(933):     def __init__(self, option_class, conflict_handler, description):
optparse.py(944):     def _create_option_mappings(self):
optparse.py(953):     def _share_option_mappings(self, parser):
optparse.py(960):     def set_conflict_handler(self, handler):
optparse.py(965):     def set_description(self, description):
optparse.py(968):     def get_description(self):
optparse.py(972):     def destroy(self):
optparse.py(981):     def _check_conflict(self, option):
optparse.py(1008):     def add_option(self, *args, **kwargs):
optparse.py(1038):     def add_options(self, option_list):
optparse.py(1044):     def get_option(self, opt_str):
optparse.py(1048):     def has_option(self, opt_str):
optparse.py(1052):     def remove_option(self, opt_str):
optparse.py(1068):     def format_option_help(self, formatter):
optparse.py(1077):     def format_description(self, formatter):
optparse.py(1080):     def format_help(self, formatter):
optparse.py(1089): class OptionGroup (OptionContainer):
 --- modulename: optparse, funcname: OptionGroup
optparse.py(1089): class OptionGroup (OptionContainer):
optparse.py(1091):     def __init__(self, parser, title, description=None):
optparse.py(1097):     def _create_option_list(self):
optparse.py(1101):     def set_title(self, title):
optparse.py(1104):     def destroy(self):
optparse.py(1111):     def format_help(self, formatter):
optparse.py(1119): class OptionParser (OptionContainer):
 --- modulename: optparse, funcname: OptionParser
optparse.py(1119): class OptionParser (OptionContainer):
optparse.py(1187):     """
optparse.py(1189):     standard_option_list = []
optparse.py(1192):                  usage=None,
optparse.py(1193):                  option_list=None,
optparse.py(1194):                  option_class=Option,
optparse.py(1195):                  version=None,
optparse.py(1196):                  conflict_handler="error",
optparse.py(1197):                  description=None,
optparse.py(1198):                  formatter=None,
optparse.py(1199):                  add_help_option=True,
optparse.py(1200):                  prog=None,
optparse.py(1201):                  epilog=None):
optparse.py(1225):     def destroy(self):
optparse.py(1243):     def _create_option_list(self):
optparse.py(1248):     def _add_help_option(self):
optparse.py(1253):     def _add_version_option(self):
optparse.py(1258):     def _populate_option_list(self, option_list, add_help=True):
optparse.py(1268):     def _init_parsing_state(self):
optparse.py(1277):     def set_usage(self, usage):
optparse.py(1288):     def enable_interspersed_args(self):
optparse.py(1296):     def disable_interspersed_args(self):
optparse.py(1304):     def set_process_default_values(self, process):
optparse.py(1307):     def set_default(self, dest, value):
optparse.py(1310):     def set_defaults(self, **kwargs):
optparse.py(1313):     def _get_all_options(self):
optparse.py(1319):     def get_default_values(self):
optparse.py(1336):     def add_option_group(self, *args, **kwargs):
optparse.py(1352):     def get_option_group(self, opt_str):
optparse.py(1362):     def _get_args(self, args):
optparse.py(1368):     def parse_args(self, args=None, values=None):
optparse.py(1407):     def check_values(self, values, args):
optparse.py(1420):     def _process_args(self, largs, rargs, values):
optparse.py(1471):     def _match_long_opt(self, opt):
optparse.py(1480):     def _process_long_opt(self, rargs, values):
optparse.py(1517):     def _process_short_opts(self, rargs, values):
optparse.py(1559):     def get_prog_name(self):
optparse.py(1565):     def expand_prog_name(self, s):
optparse.py(1568):     def get_description(self):
optparse.py(1571):     def exit(self, status=0, msg=None):
optparse.py(1576):     def error(self, msg):
optparse.py(1586):     def get_usage(self):
optparse.py(1593):     def print_usage(self, file=None):
optparse.py(1605):     def get_version(self):
optparse.py(1611):     def print_version(self, file=None):
optparse.py(1622):     def format_option_help(self, formatter=None):
optparse.py(1639):     def format_epilog(self, formatter):
optparse.py(1642):     def format_help(self, formatter=None):
optparse.py(1655):     def _get_encoding(self, file):
optparse.py(1661):     def print_help(self, file=None):
optparse.py(1675): def _match_abbrev(s, wordmap):
optparse.py(1704): make_option = Option
data.py(9): import os
data.py(10): import os.path
data.py(11): import random
data.py(12): import re
data.py(13): import socket
 --- modulename: socket, funcname: <module>
socket.py(45): """
socket.py(47): import _socket
socket.py(48): from _socket import *
socket.py(49): from functools import partial
socket.py(50): from types import MethodType
socket.py(52): try:
socket.py(53):     import _ssl
socket.py(58):     def ssl(sock, keyfile=None, certfile=None):
socket.py(67):     from _ssl import SSLError as sslerror
socket.py(68):     from _ssl import \
socket.py(80):     try:
socket.py(81):         from _ssl import RAND_egd
socket.py(86): import os, sys, warnings
socket.py(88): try:
socket.py(89):     from cStringIO import StringIO
socket.py(93): try:
socket.py(94):     import errno
socket.py(97): EBADF = getattr(errno, 'EBADF', 9)
socket.py(98): EINTR = getattr(errno, 'EINTR', 4)
socket.py(100): __all__ = ["getfqdn", "create_connection"]
socket.py(101): __all__.extend(os._get_exports_list(_socket))
 --- modulename: os, funcname: _get_exports_list
os.py(36):     try:
os.py(37):         return list(module.__all__)
os.py(38):     except AttributeError:
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
os.py(39):         return [n for n in dir(module) if n[0] != '_']
socket.py(104): _realsocket = socket
socket.py(107): if sys.platform.lower().startswith("win"):
socket.py(128): def getfqdn(name=''):
socket.py(155):     'bind', 'connect', 'connect_ex', 'fileno', 'listen',
socket.py(156):     'getpeername', 'getsockname', 'getsockopt', 'setsockopt',
socket.py(157):     'sendall', 'setblocking',
socket.py(158):     'settimeout', 'gettimeout', 'shutdown')
socket.py(160): if os.name == "nt":
socket.py(163): if sys.platform == "riscos":
socket.py(168): _delegate_methods = ("recv", "recvfrom", "recv_into", "recvfrom_into",
socket.py(169):                      "send", "sendto")
socket.py(171): class _closedsocket(object):
 --- modulename: socket, funcname: _closedsocket
socket.py(171): class _closedsocket(object):
socket.py(172):     __slots__ = []
socket.py(173):     def _dummy(*args):
socket.py(176):     send = recv = recv_into = sendto = recvfrom = recvfrom_into = _dummy
socket.py(177):     __getattr__ = _dummy
socket.py(183): class _socketobject(object):
 --- modulename: socket, funcname: _socketobject
socket.py(183): class _socketobject(object):
socket.py(185):     __doc__ = _realsocket.__doc__
socket.py(187):     __slots__ = ["_sock", "__weakref__"] + list(_delegate_methods)
socket.py(189):     def __init__(self, family=AF_INET, type=SOCK_STREAM, proto=0, _sock=None):
socket.py(196):     def close(self, _closedsocket=_closedsocket,
socket.py(197):               _delegate_methods=_delegate_methods, setattr=setattr):
socket.py(203):     close.__doc__ = _realsocket.close.__doc__
socket.py(205):     def accept(self):
socket.py(208):     accept.__doc__ = _realsocket.accept.__doc__
socket.py(210):     def dup(self):
socket.py(216):     def makefile(self, mode='r', bufsize=-1):
socket.py(223):     family = property(lambda self: self._sock.family, doc="the socket family")
socket.py(224):     type = property(lambda self: self._sock.type, doc="the socket type")
socket.py(225):     proto = property(lambda self: self._sock.proto, doc="the socket protocol")
socket.py(227): def meth(name,self,*args):
socket.py(230): for _m in _socketmethods:
socket.py(231):     p = partial(meth,_m)
socket.py(232):     p.__name__ = _m
socket.py(233):     p.__doc__ = getattr(_realsocket,_m).__doc__
socket.py(234):     m = MethodType(p,None,_socketobject)
socket.py(235):     setattr(_socketobject,_m,m)
socket.py(230): for _m in _socketmethods:
socket.py(231):     p = partial(meth,_m)
socket.py(232):     p.__name__ = _m
socket.py(233):     p.__doc__ = getattr(_realsocket,_m).__doc__
socket.py(234):     m = MethodType(p,None,_socketobject)
socket.py(235):     setattr(_socketobject,_m,m)
socket.py(230): for _m in _socketmethods:
socket.py(231):     p = partial(meth,_m)
socket.py(232):     p.__name__ = _m
socket.py(233):     p.__doc__ = getattr(_realsocket,_m).__doc__
socket.py(234):     m = MethodType(p,None,_socketobject)
socket.py(235):     setattr(_socketobject,_m,m)
socket.py(230): for _m in _socketmethods:
socket.py(231):     p = partial(meth,_m)
socket.py(232):     p.__name__ = _m
socket.py(233):     p.__doc__ = getattr(_realsocket,_m).__doc__
socket.py(234):     m = MethodType(p,None,_socketobject)
socket.py(235):     setattr(_socketobject,_m,m)
socket.py(230): for _m in _socketmethods:
socket.py(231):     p = partial(meth,_m)
socket.py(232):     p.__name__ = _m
socket.py(233):     p.__doc__ = getattr(_realsocket,_m).__doc__
socket.py(234):     m = MethodType(p,None,_socketobject)
socket.py(235):     setattr(_socketobject,_m,m)
socket.py(230): for _m in _socketmethods:
socket.py(231):     p = partial(meth,_m)
socket.py(232):     p.__name__ = _m
socket.py(233):     p.__doc__ = getattr(_realsocket,_m).__doc__
socket.py(234):     m = MethodType(p,None,_socketobject)
socket.py(235):     setattr(_socketobject,_m,m)
socket.py(230): for _m in _socketmethods:
socket.py(231):     p = partial(meth,_m)
socket.py(232):     p.__name__ = _m
socket.py(233):     p.__doc__ = getattr(_realsocket,_m).__doc__
socket.py(234):     m = MethodType(p,None,_socketobject)
socket.py(235):     setattr(_socketobject,_m,m)
socket.py(230): for _m in _socketmethods:
socket.py(231):     p = partial(meth,_m)
socket.py(232):     p.__name__ = _m
socket.py(233):     p.__doc__ = getattr(_realsocket,_m).__doc__
socket.py(234):     m = MethodType(p,None,_socketobject)
socket.py(235):     setattr(_socketobject,_m,m)
socket.py(230): for _m in _socketmethods:
socket.py(231):     p = partial(meth,_m)
socket.py(232):     p.__name__ = _m
socket.py(233):     p.__doc__ = getattr(_realsocket,_m).__doc__
socket.py(234):     m = MethodType(p,None,_socketobject)
socket.py(235):     setattr(_socketobject,_m,m)
socket.py(230): for _m in _socketmethods:
socket.py(231):     p = partial(meth,_m)
socket.py(232):     p.__name__ = _m
socket.py(233):     p.__doc__ = getattr(_realsocket,_m).__doc__
socket.py(234):     m = MethodType(p,None,_socketobject)
socket.py(235):     setattr(_socketobject,_m,m)
socket.py(230): for _m in _socketmethods:
socket.py(231):     p = partial(meth,_m)
socket.py(232):     p.__name__ = _m
socket.py(233):     p.__doc__ = getattr(_realsocket,_m).__doc__
socket.py(234):     m = MethodType(p,None,_socketobject)
socket.py(235):     setattr(_socketobject,_m,m)
socket.py(230): for _m in _socketmethods:
socket.py(231):     p = partial(meth,_m)
socket.py(232):     p.__name__ = _m
socket.py(233):     p.__doc__ = getattr(_realsocket,_m).__doc__
socket.py(234):     m = MethodType(p,None,_socketobject)
socket.py(235):     setattr(_socketobject,_m,m)
socket.py(230): for _m in _socketmethods:
socket.py(231):     p = partial(meth,_m)
socket.py(232):     p.__name__ = _m
socket.py(233):     p.__doc__ = getattr(_realsocket,_m).__doc__
socket.py(234):     m = MethodType(p,None,_socketobject)
socket.py(235):     setattr(_socketobject,_m,m)
socket.py(230): for _m in _socketmethods:
socket.py(231):     p = partial(meth,_m)
socket.py(232):     p.__name__ = _m
socket.py(233):     p.__doc__ = getattr(_realsocket,_m).__doc__
socket.py(234):     m = MethodType(p,None,_socketobject)
socket.py(235):     setattr(_socketobject,_m,m)
socket.py(230): for _m in _socketmethods:
socket.py(237): socket = SocketType = _socketobject
socket.py(239): class _fileobject(object):
 --- modulename: socket, funcname: _fileobject
socket.py(239): class _fileobject(object):
socket.py(240):     """Faux file object attached to a socket object."""
socket.py(242):     default_bufsize = 8192
socket.py(243):     name = "<socket>"
socket.py(245):     __slots__ = ["mode", "bufsize", "softspace",
socket.py(247):                  "_sock", "_rbufsize", "_wbufsize", "_rbuf", "_wbuf", "_wbuf_len",
socket.py(248):                  "_close"]
socket.py(250):     def __init__(self, sock, mode='rb', bufsize=-1, close=False):
socket.py(276):     def _getclosed(self):
socket.py(278):     closed = property(_getclosed, doc="True if the file is closed")
socket.py(280):     def close(self):
socket.py(289):     def __del__(self):
socket.py(296):     def flush(self):
socket.py(316):     def fileno(self):
socket.py(319):     def write(self, data):
socket.py(330):     def writelines(self, list):
socket.py(340):     def read(self, size=-1):
socket.py(410):     def readline(self, size=-1):
socket.py(515):     def readlines(self, sizehint=0):
socket.py(530):     def __iter__(self):
socket.py(533):     def next(self):
socket.py(539): _GLOBAL_DEFAULT_TIMEOUT = object()
socket.py(541): def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
socket.py(542):                       source_address=None):
data.py(15): from coverage import env
data.py(16): from coverage.backward import iitems, string_class
data.py(17): from coverage.debug import _TEST_NAME_FILE
 --- modulename: debug, funcname: <module>
debug.py(4): """Control of and utilities for debugging."""
debug.py(6): import inspect
debug.py(7): import os
debug.py(8): import sys
debug.py(10): from coverage.misc import isolate_module
debug.py(12): os = isolate_module(os)
 --- modulename: misc, funcname: isolate_module
misc.py(28):     if mod not in ISOLATED_MODULES:
misc.py(36):     return ISOLATED_MODULES[mod]
debug.py(18): FORCED_DEBUG = []
debug.py(21): _TEST_NAME_FILE = ""    # "/tmp/covtest.txt"
debug.py(24): class DebugControl(object):
 --- modulename: debug, funcname: DebugControl
debug.py(24): class DebugControl(object):
debug.py(25):     """Control and output for debugging."""
debug.py(27):     def __init__(self, options, output):
debug.py(32):     def __repr__(self):
debug.py(35):     def should(self, option):
debug.py(39):     def write(self, msg):
debug.py(48):     def write_formatted_info(self, header, info):
debug.py(55): def info_header(label):
debug.py(60): def info_formatter(info):
debug.py(83): def short_stack():                                          # pragma: debugging
debug.py(100): def dump_stack_frames(out=None):                            # pragma: debugging
data.py(18): from coverage.files import PathAliases
data.py(19): from coverage.misc import CoverageException, file_be_gone, isolate_module
data.py(21): os = isolate_module(os)
 --- modulename: misc, funcname: isolate_module
misc.py(28):     if mod not in ISOLATED_MODULES:
misc.py(36):     return ISOLATED_MODULES[mod]
data.py(24): class CoverageData(object):
 --- modulename: data, funcname: CoverageData
data.py(24): class CoverageData(object):
data.py(87):     """
data.py(114):     def __init__(self, debug=None):
data.py(146):     def __repr__(self):
data.py(159):     def has_arcs(self):
data.py(170):     def lines(self, filename):
data.py(188):     def arcs(self, filename):
data.py(210):     def file_tracer(self, filename):
data.py(225):     def run_infos(self):
data.py(235):     def measured_files(self):
data.py(239):     def line_counts(self, fullpath=False):
data.py(258):     def __nonzero__(self):
data.py(261):     __bool__ = __nonzero__
data.py(263):     def read_fileobj(self, file_obj):
data.py(285):     def read_file(self, filename):
data.py(299):     _GO_AWAY = "!coverage.py: This is a private format, don't read it directly!"
data.py(301):     @classmethod
data.py(306):     @classmethod
data.py(314):     @classmethod
data.py(324):     def add_lines(self, line_data):
data.py(350):     def add_arcs(self, arc_data):
data.py(376):     def add_file_tracers(self, file_tracers):
data.py(402):     def add_run_info(self, **kwargs):
data.py(417):     def touch_file(self, filename):
data.py(432):     def write_fileobj(self, file_obj):
data.py(454):     def write_file(self, filename):
data.py(461):     def erase(self):
data.py(469):     def update(self, other_data, aliases=None):
data.py(533):     def _validate(self):
data.py(538):     def _validate_invariants(self):
data.py(576):     def add_to_hash(self, filename, hasher):
data.py(594):     def _has_lines(self):
data.py(598):     def _has_arcs(self):
data.py(603): class CoverageDataFiles(object):
 --- modulename: data, funcname: CoverageDataFiles
data.py(603): class CoverageDataFiles(object):
data.py(604):     """Manage the use of coverage data files."""
data.py(606):     def __init__(self, basename=None, warn=None):
data.py(618):     def erase(self, parallel=False):
data.py(633):     def read(self, data):
data.py(638):     def write(self, data, suffix=None):
data.py(667):     def combine_parallel_data(self, data, aliases=None, data_paths=None):
data.py(718): def canonicalize_json_data(data):
data.py(726): def pretty_data(data):
data.py(741): def debug_main(args):
data.py(764): if __name__ == '__main__':
control.py(20): from coverage.debug import DebugControl
control.py(21): from coverage.files import TreeMatcher, FnmatchMatcher
control.py(22): from coverage.files import PathAliases, find_python_files, prep_patterns
control.py(23): from coverage.files import ModuleMatcher, abs_file
control.py(24): from coverage.html import HtmlReporter
 --- modulename: html, funcname: <module>
html.py(4): """HTML reporting for coverage.py."""
html.py(6): import datetime
html.py(7): import json
html.py(8): import os
html.py(9): import re
html.py(10): import shutil
 --- modulename: shutil, funcname: <module>
shutil.py(5): """
shutil.py(7): import os
shutil.py(8): import sys
shutil.py(9): import stat
shutil.py(10): from os.path import abspath
shutil.py(11): import fnmatch
shutil.py(12): import collections
shutil.py(13): import errno
shutil.py(15): try:
shutil.py(16):     from pwd import getpwnam
shutil.py(20): try:
shutil.py(21):     from grp import getgrnam
shutil.py(25): __all__ = ["copyfileobj", "copyfile", "copymode", "copystat", "copy", "copy2",
shutil.py(26):            "copytree", "move", "rmtree", "Error", "SpecialFileError",
shutil.py(27):            "ExecError", "make_archive", "get_archive_formats",
shutil.py(28):            "register_archive_format", "unregister_archive_format",
shutil.py(29):            "ignore_patterns"]
shutil.py(31): class Error(EnvironmentError):
 --- modulename: shutil, funcname: Error
shutil.py(31): class Error(EnvironmentError):
shutil.py(32):     pass
shutil.py(34): class SpecialFileError(EnvironmentError):
 --- modulename: shutil, funcname: SpecialFileError
shutil.py(34): class SpecialFileError(EnvironmentError):
shutil.py(36):     not supported on a special file (e.g. a named pipe)"""
shutil.py(38): class ExecError(EnvironmentError):
 --- modulename: shutil, funcname: ExecError
shutil.py(38): class ExecError(EnvironmentError):
shutil.py(39):     """Raised when a command could not be executed"""
shutil.py(41): try:
shutil.py(42):     WindowsError
shutil.py(43): except NameError:
shutil.py(44):     WindowsError = None
shutil.py(46): def copyfileobj(fsrc, fdst, length=16*1024):
shutil.py(54): def _samefile(src, dst):
shutil.py(66): def copyfile(src, dst):
shutil.py(86): def copymode(src, dst):
shutil.py(93): def copystat(src, dst):
shutil.py(111): def copy(src, dst):
shutil.py(122): def copy2(src, dst):
shutil.py(133): def ignore_patterns(*patterns):
shutil.py(145): def copytree(src, dst, symlinks=False, ignore=None):
shutil.py(210): def rmtree(path, ignore_errors=False, onerror=None):
shutil.py(259): def _basename(path):
shutil.py(265): def move(src, dst):
shutil.py(305): def _destinsrc(src, dst):
shutil.py(314): def _get_gid(name):
shutil.py(326): def _get_uid(name):
shutil.py(338): def _make_tarball(base_name, base_dir, compress="gzip", verbose=0, dry_run=0,
shutil.py(339):                   owner=None, group=None, logger=None):
shutil.py(399): def _call_external_zip(base_dir, zip_filename, verbose=False, dry_run=False):
shutil.py(417): def _make_zipfile(base_name, base_dir, verbose=0, dry_run=0, logger=None):
shutil.py(471): _ARCHIVE_FORMATS = {
shutil.py(472):     'gztar': (_make_tarball, [('compress', 'gzip')], "gzip'ed tar-file"),
shutil.py(473):     'bztar': (_make_tarball, [('compress', 'bzip2')], "bzip2'ed tar-file"),
shutil.py(474):     'tar':   (_make_tarball, [('compress', None)], "uncompressed tar file"),
shutil.py(475):     'zip':   (_make_zipfile, [],"ZIP file")
shutil.py(478): def get_archive_formats():
shutil.py(488): def register_archive_format(name, function, extra_args=None, description=''):
shutil.py(509): def unregister_archive_format(name):
shutil.py(512): def make_archive(base_name, format, root_dir=None, base_dir=None, verbose=0,
shutil.py(513):                  dry_run=0, owner=None, group=None, logger=None):
html.py(12): import coverage
html.py(13): from coverage import env
html.py(14): from coverage.backward import iitems
html.py(15): from coverage.files import flat_rootname
html.py(16): from coverage.misc import CoverageException, Hasher, isolate_module
html.py(17): from coverage.report import Reporter
html.py(18): from coverage.results import Numbers
 --- modulename: results, funcname: <module>
results.py(4): """Results of coverage measurement."""
results.py(6): import collections
results.py(8): from coverage.backward import iitems
results.py(9): from coverage.misc import format_lines
results.py(12): class Analysis(object):
 --- modulename: results, funcname: Analysis
results.py(12): class Analysis(object):
results.py(13):     """The results of analyzing a FileReporter."""
results.py(15):     def __init__(self, data, file_reporter):
results.py(53):     def missing_formatted(self):
results.py(61):     def has_arcs(self):
results.py(65):     def arc_possibilities(self):
results.py(69):     def arcs_executed(self):
results.py(75):     def arcs_missing(self):
results.py(86):     def arcs_missing_formatted(self):
results.py(104):     def arcs_unpredicted(self):
results.py(121):     def branch_lines(self):
results.py(125):     def total_branches(self):
results.py(129):     def missing_branch_arcs(self):
results.py(143):     def branch_stats(self):
results.py(162): class Numbers(object):
 --- modulename: results, funcname: Numbers
results.py(162): class Numbers(object):
results.py(168):     """
results.py(171):     _precision = 0
results.py(172):     _near0 = 1.0              # These will change when _precision is changed.
results.py(173):     _near100 = 99.0
results.py(175):     def __init__(self, n_files=0, n_statements=0, n_excluded=0, n_missing=0,
results.py(176):                     n_branches=0, n_partial_branches=0, n_missing_branches=0
results.py(186):     def init_args(self):
results.py(193):     @classmethod
results.py(201):     @property
results.py(206):     @property
results.py(211):     @property
results.py(221):     @property
results.py(239):     @classmethod
results.py(247):     @property
results.py(254):     def __add__(self, other):
results.py(269):     def __radd__(self, other):
html.py(19): from coverage.templite import Templite
 --- modulename: templite, funcname: <module>
templite.py(9): """
templite.py(13): import re
templite.py(15): from coverage import env
templite.py(18): class TempliteSyntaxError(ValueError):
 --- modulename: templite, funcname: TempliteSyntaxError
templite.py(18): class TempliteSyntaxError(ValueError):
templite.py(19):     """Raised when a template has a syntax error."""
templite.py(20):     pass
templite.py(23): class TempliteValueError(ValueError):
 --- modulename: templite, funcname: TempliteValueError
templite.py(23): class TempliteValueError(ValueError):
templite.py(24):     """Raised when an expression won't evaluate in a template."""
templite.py(25):     pass
templite.py(28): class CodeBuilder(object):
 --- modulename: templite, funcname: CodeBuilder
templite.py(28): class CodeBuilder(object):
templite.py(29):     """Build source code conveniently."""
templite.py(31):     def __init__(self, indent=0):
templite.py(35):     def __str__(self):
templite.py(38):     def add_line(self, line):
templite.py(46):     def add_section(self):
templite.py(52):     INDENT_STEP = 4      # PEP8 says so!
templite.py(54):     def indent(self):
templite.py(58):     def dedent(self):
templite.py(62):     def get_globals(self):
templite.py(74): class Templite(object):
 --- modulename: templite, funcname: Templite
templite.py(74): class Templite(object):
templite.py(109):     """
templite.py(110):     def __init__(self, text, *contexts):
templite.py(216):     def _expr_code(self, expr):
templite.py(234):     def _syntax_error(self, msg, thing):
templite.py(238):     def _variable(self, name, vars_set):
templite.py(250):     def render(self, context=None):
templite.py(262):     def _do_dots(self, value, *dots):
html.py(21): os = isolate_module(os)
 --- modulename: misc, funcname: isolate_module
misc.py(28):     if mod not in ISOLATED_MODULES:
misc.py(36):     return ISOLATED_MODULES[mod]
html.py(27):     "/usr/share/javascript",
html.py(30):     os.path.join(os.path.dirname(__file__), "htmlfiles"),
 --- modulename: posixpath, funcname: dirname
posixpath.py(122):     i = p.rfind('/') + 1
posixpath.py(123):     head = p[:i]
posixpath.py(124):     if head and head != '/'*len(head):
posixpath.py(125):         head = head.rstrip('/')
posixpath.py(126):     return head
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
html.py(34): def data_filename(fname, pkgdir=""):
html.py(62): def data(fname):
html.py(68): class HtmlReporter(Reporter):
 --- modulename: html, funcname: HtmlReporter
html.py(68): class HtmlReporter(Reporter):
html.py(69):     """HTML reporting."""
html.py(74):         ("style.css", ""),
html.py(75):         ("jquery.min.js", "jquery"),
html.py(76):         ("jquery.debounce.min.js", "jquery-debounce"),
html.py(77):         ("jquery.hotkeys.js", "jquery-hotkeys"),
html.py(78):         ("jquery.isonscreen.js", "jquery-isonscreen"),
html.py(79):         ("jquery.tablesorter.min.js", "jquery-tablesorter"),
html.py(80):         ("coverage_html.js", ""),
html.py(81):         ("keybd_closed.png", ""),
html.py(82):         ("keybd_open.png", ""),
html.py(85):     def __init__(self, cov, config):
html.py(111):     def report(self, morfs):
html.py(146):     def make_local_static_report_files(self):
html.py(162):     def write_html(self, fname, html):
html.py(167):     def file_hash(self, source, fr):
html.py(174):     def html_file(self, fr, analysis):
html.py(282):     def index_file(self):
html.py(302): class HtmlStatus(object):
 --- modulename: html, funcname: HtmlStatus
html.py(302): class HtmlStatus(object):
html.py(303):     """The status information we keep to support incremental reporting."""
html.py(305):     STATUS_FILE = "status.json"
html.py(306):     STATUS_FORMAT = 1
html.py(336):     def __init__(self):
html.py(339):     def reset(self):
html.py(344):     def read(self, directory):
html.py(369):     def write(self, directory):
html.py(393):     def settings_hash(self):
html.py(397):     def set_settings_hash(self, settings):
html.py(401):     def file_hash(self, fname):
html.py(405):     def set_file_hash(self, fname, val):
html.py(409):     def index_info(self, fname):
html.py(413):     def set_index_info(self, fname, info):
html.py(420): def escape(t):
html.py(435): def spaceless(html):
html.py(446): def pair(ratio):
control.py(25): from coverage.misc import CoverageException, bool_or_none, join_regex
control.py(26): from coverage.misc import file_be_gone, isolate_module
control.py(27): from coverage.monkey import patch_multiprocessing
 --- modulename: monkey, funcname: <module>
monkey.py(4): """Monkey-patching to make coverage.py work right in some cases."""
monkey.py(6): import multiprocessing
 --- modulename: __init__, funcname: <module>
__init__.py(44): __version__ = '0.70a1'
__init__.py(47):     'Process', 'current_process', 'active_children', 'freeze_support',
__init__.py(48):     'Manager', 'Pipe', 'cpu_count', 'log_to_stderr', 'get_logger',
__init__.py(49):     'allow_connection_pickling', 'BufferTooShort', 'TimeoutError',
__init__.py(50):     'Lock', 'RLock', 'Semaphore', 'BoundedSemaphore', 'Condition',
__init__.py(51):     'Event', 'Queue', 'JoinableQueue', 'Pool', 'Value', 'Array',
__init__.py(52):     'RawValue', 'RawArray', 'SUBDEBUG', 'SUBWARNING',
__init__.py(55): __author__ = 'R. Oudkerk (r.m.oudkerk@gmail.com)'
__init__.py(61): import os
__init__.py(62): import sys
__init__.py(64): from multiprocessing.process import Process, current_process, active_children
 --- modulename: process, funcname: <module>
process.py(35): __all__ = ['Process', 'current_process', 'active_children']
process.py(41): import os
process.py(42): import sys
process.py(43): import signal
process.py(44): import itertools
process.py(50): try:
process.py(51):     ORIGINAL_DIR = os.path.abspath(os.getcwd())
 --- modulename: posixpath, funcname: abspath
posixpath.py(360):     if not isabs(path):
 --- modulename: posixpath, funcname: isabs
posixpath.py(54):     return s.startswith('/')
posixpath.py(366):     return normpath(path)
 --- modulename: posixpath, funcname: normpath
posixpath.py(332):     slash, dot = (u'/', u'.') if isinstance(path, _unicode) else ('/', '.')
posixpath.py(333):     if path == '':
posixpath.py(335):     initial_slashes = path.startswith('/')
posixpath.py(338):     if (initial_slashes and
posixpath.py(339):         path.startswith('//') and not path.startswith('///')):
posixpath.py(341):     comps = path.split('/')
posixpath.py(342):     new_comps = []
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(345):             continue
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(351):     comps = new_comps
posixpath.py(352):     path = slash.join(comps)
posixpath.py(353):     if initial_slashes:
posixpath.py(354):         path = slash*initial_slashes + path
posixpath.py(355):     return path or dot
process.py(59): def current_process():
process.py(65): def active_children():
process.py(76): def _cleanup():
process.py(86): class Process(object):
 --- modulename: process, funcname: Process
process.py(86): class Process(object):
process.py(91):     '''
process.py(92):     _Popen = None
process.py(94):     def __init__(self, group=None, target=None, name=None, args=(), kwargs={}):
process.py(109):     def run(self):
process.py(116):     def start(self):
process.py(133):     def terminate(self):
process.py(139):     def join(self, timeout=None):
process.py(149):     def is_alive(self):
process.py(161):     @property
process.py(165):     @name.setter
process.py(170):     @property
process.py(177):     @daemon.setter
process.py(185):     @property
process.py(189):     @authkey.setter
process.py(196):     @property
process.py(205):     @property
process.py(215):     pid = ident
process.py(217):     def __repr__(self):
process.py(241):     def _bootstrap(self):
process.py(285): class AuthenticationString(bytes):
 --- modulename: process, funcname: AuthenticationString
process.py(285): class AuthenticationString(bytes):
process.py(286):     def __reduce__(self):
process.py(299): class _MainProcess(Process):
 --- modulename: process, funcname: _MainProcess
process.py(299): class _MainProcess(Process):
process.py(301):     def __init__(self):
process.py(312): _current_process = _MainProcess()
 --- modulename: process, funcname: __init__
process.py(302):         self._identity = ()
process.py(303):         self._daemonic = False
process.py(304):         self._name = 'MainProcess'
process.py(305):         self._parent_pid = None
process.py(306):         self._popen = None
process.py(307):         self._counter = itertools.count(1)
process.py(308):         self._children = set()
process.py(309):         self._authkey = AuthenticationString(os.urandom(32))
process.py(310):         self._tempdir = None
process.py(313): del _MainProcess
process.py(319): _exitcode_to_name = {}
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(323):         _exitcode_to_name[-signum] = name
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(323):         _exitcode_to_name[-signum] = name
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(323):         _exitcode_to_name[-signum] = name
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(323):         _exitcode_to_name[-signum] = name
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(323):         _exitcode_to_name[-signum] = name
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(323):         _exitcode_to_name[-signum] = name
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(323):         _exitcode_to_name[-signum] = name
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(323):         _exitcode_to_name[-signum] = name
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(323):         _exitcode_to_name[-signum] = name
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(323):         _exitcode_to_name[-signum] = name
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(323):         _exitcode_to_name[-signum] = name
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(323):         _exitcode_to_name[-signum] = name
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(323):         _exitcode_to_name[-signum] = name
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(323):         _exitcode_to_name[-signum] = name
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(323):         _exitcode_to_name[-signum] = name
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(323):         _exitcode_to_name[-signum] = name
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(323):         _exitcode_to_name[-signum] = name
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(323):         _exitcode_to_name[-signum] = name
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(323):         _exitcode_to_name[-signum] = name
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(323):         _exitcode_to_name[-signum] = name
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(323):         _exitcode_to_name[-signum] = name
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(323):         _exitcode_to_name[-signum] = name
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(323):         _exitcode_to_name[-signum] = name
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(323):         _exitcode_to_name[-signum] = name
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(323):         _exitcode_to_name[-signum] = name
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(323):         _exitcode_to_name[-signum] = name
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(323):         _exitcode_to_name[-signum] = name
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(323):         _exitcode_to_name[-signum] = name
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(323):         _exitcode_to_name[-signum] = name
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(323):         _exitcode_to_name[-signum] = name
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(323):         _exitcode_to_name[-signum] = name
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(323):         _exitcode_to_name[-signum] = name
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(323):         _exitcode_to_name[-signum] = name
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(323):         _exitcode_to_name[-signum] = name
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(323):         _exitcode_to_name[-signum] = name
process.py(321): for name, signum in signal.__dict__.items():
process.py(322):     if name[:3]=='SIG' and '_' not in name:
process.py(321): for name, signum in signal.__dict__.items():
__init__.py(65): from multiprocessing.util import SUBDEBUG, SUBWARNING
 --- modulename: util, funcname: <module>
util.py(35): import os
util.py(36): import itertools
util.py(37): import weakref
util.py(38): import atexit
util.py(39): import threading        # we want threading to install it's
util.py(41): from subprocess import _args_from_interpreter_flags
 --- modulename: subprocess, funcname: <module>
subprocess.py(387): """
subprocess.py(389): import sys
subprocess.py(390): mswindows = (sys.platform == "win32")
subprocess.py(392): import os
subprocess.py(393): import types
subprocess.py(394): import traceback
subprocess.py(395): import gc
subprocess.py(396): import signal
subprocess.py(397): import errno
subprocess.py(400): class CalledProcessError(Exception):
 --- modulename: subprocess, funcname: CalledProcessError
subprocess.py(400): class CalledProcessError(Exception):
subprocess.py(405):     """
subprocess.py(406):     def __init__(self, returncode, cmd, output=None):
subprocess.py(410):     def __str__(self):
subprocess.py(414): if mswindows:
subprocess.py(427):     import select
subprocess.py(428):     _has_poll = hasattr(select, 'poll')
subprocess.py(429):     import fcntl
subprocess.py(430):     import pickle
 --- modulename: pickle, funcname: <module>
pickle.py(25): """
pickle.py(27): __version__ = "$Revision: 72223 $"       # Code version
pickle.py(29): from types import *
pickle.py(30): from copy_reg import dispatch_table
pickle.py(31): from copy_reg import _extension_registry, _inverted_registry, _extension_cache
pickle.py(32): import marshal
pickle.py(33): import sys
pickle.py(34): import struct
pickle.py(35): import re
pickle.py(37): __all__ = ["PickleError", "PicklingError", "UnpicklingError", "Pickler",
pickle.py(38):            "Unpickler", "dump", "dumps", "load", "loads"]
pickle.py(41): format_version = "2.0"                  # File format version we write
pickle.py(42): compatible_formats = ["1.0",            # Original protocol 0
pickle.py(43):                       "1.1",            # Protocol 0 with INST added
pickle.py(44):                       "1.2",            # Original protocol 1
pickle.py(45):                       "1.3",            # Protocol 1 with BINFLOAT added
pickle.py(46):                       "2.0",            # Protocol 2
pickle.py(51): HIGHEST_PROTOCOL = 2
pickle.py(56): mloads = marshal.loads
pickle.py(58): class PickleError(Exception):
 --- modulename: pickle, funcname: PickleError
pickle.py(58): class PickleError(Exception):
pickle.py(59):     """A common base class for the other pickling exceptions."""
pickle.py(60):     pass
pickle.py(62): class PicklingError(PickleError):
 --- modulename: pickle, funcname: PicklingError
pickle.py(62): class PicklingError(PickleError):
pickle.py(66):     """
pickle.py(67):     pass
pickle.py(69): class UnpicklingError(PickleError):
 --- modulename: pickle, funcname: UnpicklingError
pickle.py(69): class UnpicklingError(PickleError):
pickle.py(77):     """
pickle.py(78):     pass
pickle.py(82): class _Stop(Exception):
 --- modulename: pickle, funcname: _Stop
pickle.py(82): class _Stop(Exception):
pickle.py(83):     def __init__(self, value):
pickle.py(87): try:
pickle.py(88):     from org.python.core import PyStringMap
pickle.py(89): except ImportError:
pickle.py(90):     PyStringMap = None
pickle.py(93): try:
pickle.py(94):     UnicodeType
pickle.py(102): MARK            = '('   # push special markobject on stack
pickle.py(103): STOP            = '.'   # every pickle ends with STOP
pickle.py(104): POP             = '0'   # discard topmost stack item
pickle.py(105): POP_MARK        = '1'   # discard stack top through topmost markobject
pickle.py(106): DUP             = '2'   # duplicate top stack item
pickle.py(107): FLOAT           = 'F'   # push float object; decimal string argument
pickle.py(108): INT             = 'I'   # push integer or bool; decimal string argument
pickle.py(109): BININT          = 'J'   # push four-byte signed int
pickle.py(110): BININT1         = 'K'   # push 1-byte unsigned int
pickle.py(111): LONG            = 'L'   # push long; decimal string argument
pickle.py(112): BININT2         = 'M'   # push 2-byte unsigned int
pickle.py(113): NONE            = 'N'   # push None
pickle.py(114): PERSID          = 'P'   # push persistent object; id is taken from string arg
pickle.py(115): BINPERSID       = 'Q'   #  "       "         "  ;  "  "   "     "  stack
pickle.py(116): REDUCE          = 'R'   # apply callable to argtuple, both on stack
pickle.py(117): STRING          = 'S'   # push string; NL-terminated string argument
pickle.py(118): BINSTRING       = 'T'   # push string; counted binary string argument
pickle.py(119): SHORT_BINSTRING = 'U'   #  "     "   ;    "      "       "      " < 256 bytes
pickle.py(120): UNICODE         = 'V'   # push Unicode string; raw-unicode-escaped'd argument
pickle.py(121): BINUNICODE      = 'X'   #   "     "       "  ; counted UTF-8 string argument
pickle.py(122): APPEND          = 'a'   # append stack top to list below it
pickle.py(123): BUILD           = 'b'   # call __setstate__ or __dict__.update()
pickle.py(124): GLOBAL          = 'c'   # push self.find_class(modname, name); 2 string args
pickle.py(125): DICT            = 'd'   # build a dict from stack items
pickle.py(126): EMPTY_DICT      = '}'   # push empty dict
pickle.py(127): APPENDS         = 'e'   # extend list on stack by topmost stack slice
pickle.py(128): GET             = 'g'   # push item from memo on stack; index is string arg
pickle.py(129): BINGET          = 'h'   #   "    "    "    "   "   "  ;   "    " 1-byte arg
pickle.py(130): INST            = 'i'   # build & push class instance
pickle.py(131): LONG_BINGET     = 'j'   # push item from memo on stack; index is 4-byte arg
pickle.py(132): LIST            = 'l'   # build list from topmost stack items
pickle.py(133): EMPTY_LIST      = ']'   # push empty list
pickle.py(134): OBJ             = 'o'   # build & push class instance
pickle.py(135): PUT             = 'p'   # store stack top in memo; index is string arg
pickle.py(136): BINPUT          = 'q'   #   "     "    "   "   " ;   "    " 1-byte arg
pickle.py(137): LONG_BINPUT     = 'r'   #   "     "    "   "   " ;   "    " 4-byte arg
pickle.py(138): SETITEM         = 's'   # add key+value pair to dict
pickle.py(139): TUPLE           = 't'   # build tuple from topmost stack items
pickle.py(140): EMPTY_TUPLE     = ')'   # push empty tuple
pickle.py(141): SETITEMS        = 'u'   # modify dict by adding topmost key+value pairs
pickle.py(142): BINFLOAT        = 'G'   # push float; arg is 8-byte float encoding
pickle.py(144): TRUE            = 'I01\n'  # not an opcode; see INT docs in pickletools.py
pickle.py(145): FALSE           = 'I00\n'  # not an opcode; see INT docs in pickletools.py
pickle.py(149): PROTO           = '\x80'  # identify pickle protocol
pickle.py(150): NEWOBJ          = '\x81'  # build object by applying cls.__new__ to argtuple
pickle.py(151): EXT1            = '\x82'  # push object from extension registry; 1-byte index
pickle.py(152): EXT2            = '\x83'  # ditto, but 2-byte index
pickle.py(153): EXT4            = '\x84'  # ditto, but 4-byte index
pickle.py(154): TUPLE1          = '\x85'  # build 1-tuple from stack top
pickle.py(155): TUPLE2          = '\x86'  # build 2-tuple from two topmost stack items
pickle.py(156): TUPLE3          = '\x87'  # build 3-tuple from three topmost stack items
pickle.py(157): NEWTRUE         = '\x88'  # push True
pickle.py(158): NEWFALSE        = '\x89'  # push False
pickle.py(159): LONG1           = '\x8a'  # push long from < 256 bytes
pickle.py(160): LONG4           = '\x8b'  # push really big long
pickle.py(162): _tuplesize2code = [EMPTY_TUPLE, TUPLE1, TUPLE2, TUPLE3]
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(240):         except KeyError:
re.py(241):             pass
re.py(242):     if isinstance(pattern, _pattern_type):
re.py(246):     if not sre_compile.isstring(pattern):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
re.py(248):     try:
re.py(249):         p = sre_compile.compile(pattern, flags)
 --- modulename: sre_compile, funcname: compile
sre_compile.py(570):     if isstring(p):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
sre_compile.py(571):         pattern = p
sre_compile.py(572):         p = sre_parse.parse(p, flags)
 --- modulename: sre_parse, funcname: parse
sre_parse.py(709):     source = Tokenizer(str)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(190):         self.string = string
sre_parse.py(191):         self.index = 0
sre_parse.py(192):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(711):     if pattern is None:
sre_parse.py(712):         pattern = Pattern()
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(68):         self.flags = 0
sre_parse.py(69):         self.open = []
sre_parse.py(70):         self.groups = 1
sre_parse.py(71):         self.groupdict = {}
sre_parse.py(72):         self.lookbehind = 0
sre_parse.py(713):     pattern.flags = flags
sre_parse.py(714):     pattern.str = str
sre_parse.py(716):     p = _parse_sub(source, pattern, 0)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(453):                     this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(454):                     if this == "]":
sre_parse.py(460):                     elif this:
sre_parse.py(461):                         if this[0] == "\\":
sre_parse.py(464):                             code2 = LITERAL, ord(this)
sre_parse.py(465):                         if code1[0] != LITERAL or code2[0] != LITERAL:
sre_parse.py(467):                         lo = code1[1]
sre_parse.py(468):                         hi = code2[1]
sre_parse.py(469):                         if hi < lo:
sre_parse.py(471):                         setappend((RANGE, (lo, hi)))
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(453):                     this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(454):                     if this == "]":
sre_parse.py(460):                     elif this:
sre_parse.py(461):                         if this[0] == "\\":
sre_parse.py(464):                             code2 = LITERAL, ord(this)
sre_parse.py(465):                         if code1[0] != LITERAL or code2[0] != LITERAL:
sre_parse.py(467):                         lo = code1[1]
sre_parse.py(468):                         hi = code2[1]
sre_parse.py(469):                         if hi < lo:
sre_parse.py(471):                         setappend((RANGE, (lo, hi)))
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(210):             return 1
sre_parse.py(453):                     this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(454):                     if this == "]":
sre_parse.py(460):                     elif this:
sre_parse.py(461):                         if this[0] == "\\":
sre_parse.py(464):                             code2 = LITERAL, ord(this)
sre_parse.py(465):                         if code1[0] != LITERAL or code2[0] != LITERAL:
sre_parse.py(467):                         lo = code1[1]
sre_parse.py(468):                         hi = code2[1]
sre_parse.py(469):                         if hi < lo:
sre_parse.py(471):                         setappend((RANGE, (lo, hi)))
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(495):             elif this == "+":
sre_parse.py(496):                 min, max = 1, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(694):         elif this == "$":
sre_parse.py(695):             subpattern.append((AT, AT_END))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(415):             break # end of pattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(328):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(718):     tail = source.get()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(719):     if tail == ")":
sre_parse.py(721):     elif tail:
sre_parse.py(724):     if flags & SRE_FLAG_DEBUG:
sre_parse.py(727):     if not (flags & SRE_FLAG_VERBOSE) and p.pattern.flags & SRE_FLAG_VERBOSE:
sre_parse.py(732):     return p
sre_compile.py(576):     code = _code(p, flags)
 --- modulename: sre_compile, funcname: _code
sre_compile.py(554):     flags = p.pattern.flags | flags
sre_compile.py(555):     code = []
sre_compile.py(558):     _compile_info(code, p, flags)
 --- modulename: sre_compile, funcname: _compile_info
sre_compile.py(437):     lo, hi = pattern.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(183):             elif op == SUCCESS:
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_compile.py(438):     if lo == 0:
sre_compile.py(441):     prefix = []
sre_compile.py(442):     prefixappend = prefix.append
sre_compile.py(443):     prefix_skip = 0
sre_compile.py(444):     charset = [] # not used
sre_compile.py(445):     charsetappend = charset.append
sre_compile.py(446):     if not (flags & SRE_FLAG_IGNORECASE):
sre_compile.py(448):         for op, av in pattern.data:
sre_compile.py(449):             if op is LITERAL:
sre_compile.py(453):             elif op is SUBPATTERN and len(av[1]) == 1:
sre_compile.py(460):                 break
sre_compile.py(462):         if not prefix and pattern.data:
sre_compile.py(463):             op, av = pattern.data[0]
sre_compile.py(464):             if op is SUBPATTERN and av[1]:
sre_compile.py(481):             elif op is BRANCH:
sre_compile.py(494):             elif op is IN:
sre_compile.py(495):                 charset = av
sre_compile.py(501):     emit = code.append
sre_compile.py(502):     emit(OPCODES[INFO])
sre_compile.py(503):     skip = len(code); emit(0)
sre_compile.py(505):     mask = 0
sre_compile.py(506):     if prefix:
sre_compile.py(510):     elif charset:
sre_compile.py(511):         mask = mask + SRE_INFO_CHARSET
sre_compile.py(512):     emit(mask)
sre_compile.py(514):     if lo < MAXCODE:
sre_compile.py(515):         emit(lo)
sre_compile.py(519):     if hi < MAXCODE:
sre_compile.py(522):         emit(0)
sre_compile.py(524):     if prefix:
sre_compile.py(535):     elif charset:
sre_compile.py(536):         _compile_charset(charset, flags, code)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(274):                     r = range(av[0], av[1]+1)
sre_compile.py(275):                     if fixup:
sre_compile.py(277):                     if fixup and fixes:
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(333):                 out.append((RANGE, (p, q - 1)))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(239):             emit(av[0])
sre_compile.py(240):             emit(av[1])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(537):     code[skip] = len(code) - skip
sre_compile.py(561):     _compile(code, p.data, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(274):                     r = range(av[0], av[1]+1)
sre_compile.py(275):                     if fixup:
sre_compile.py(277):                     if fixup and fixes:
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(333):                 out.append((RANGE, (p, q - 1)))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(239):             emit(av[0])
sre_compile.py(240):             emit(av[1])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(274):                     r = range(av[0], av[1]+1)
sre_compile.py(275):                     if fixup:
sre_compile.py(277):                     if fixup and fixes:
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(274):                     r = range(av[0], av[1]+1)
sre_compile.py(275):                     if fixup:
sre_compile.py(277):                     if fixup and fixes:
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(285):                             charmap[i] = 1
sre_compile.py(284):                         for i in r:
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(320):             runs = None
sre_compile.py(321):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(342):     if len(charmap) == 256:
sre_compile.py(343):         data = _mk_bitmap(charmap)
 --- modulename: sre_compile, funcname: _mk_bitmap
sre_compile.py(412):     s = bytes(bits).translate(_BITS_TRANS)[::-1]
sre_compile.py(413):     return [_int(s[i - _CODEBITS: i], 2)
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(414):             for i in range(len(s), 0, -_CODEBITS)]
sre_compile.py(344):         out.append((CHARSET, data))
sre_compile.py(345):         out += tail
sre_compile.py(346):         return out
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(242):             code.extend(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(155):         elif op in SUCCESS_CODES:
sre_compile.py(157):         elif op in ASSERT_CODES:
sre_compile.py(170):         elif op is CALL:
sre_compile.py(176):         elif op is AT:
sre_compile.py(177):             emit(OPCODES[op])
sre_compile.py(178):             if flags & SRE_FLAG_MULTILINE:
sre_compile.py(180):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(182):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(184):             emit(ATCODES[av])
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(563):     code.append(OPCODES[SUCCESS])
sre_compile.py(565):     return code
sre_compile.py(581):     if p.pattern.groups > 100:
sre_compile.py(587):     groupindex = p.pattern.groupdict
sre_compile.py(588):     indexgroup = [None] * p.pattern.groups
sre_compile.py(589):     for k, i in groupindex.items():
sre_compile.py(592):     return _sre.compile(
sre_compile.py(593):         pattern, flags | p.pattern.flags, code,
sre_compile.py(594):         p.pattern.groups-1,
sre_compile.py(595):         groupindex, indexgroup
re.py(252):     if not bypass_cache:
re.py(253):         if len(_cache) >= _MAXCACHE:
re.py(255):         if p.flags & LOCALE:
re.py(260):             loc = None
re.py(261):         _cache[cachekey] = p, loc
re.py(262):     return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
 --- modulename: re, funcname: match
re.py(141):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(238):             if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
re.py(239):                 return p
pickle.py(165): __all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
pickle.py(166): del x
pickle.py(171): class Pickler:
 --- modulename: pickle, funcname: Pickler
pickle.py(171): class Pickler:
pickle.py(173):     def __init__(self, file, protocol=None):
pickle.py(209):     def clear_memo(self):
pickle.py(220):     def dump(self, obj):
pickle.py(227):     def memoize(self, obj):
pickle.py(250):     def put(self, i, pack=struct.pack):
pickle.py(260):     def get(self, i, pack=struct.pack):
pickle.py(269):     def save(self, obj):
pickle.py(333):     def persistent_id(self, obj):
pickle.py(337):     def save_pers(self, pid):
pickle.py(345):     def save_reduce(self, func, args, state=None,
pickle.py(346):                     listitems=None, dictitems=None, obj=None):
pickle.py(430):     dispatch = {}
pickle.py(432):     def save_none(self, obj):
pickle.py(434):     dispatch[NoneType] = save_none
pickle.py(436):     def save_bool(self, obj):
pickle.py(441):     dispatch[bool] = save_bool
pickle.py(443):     def save_int(self, obj, pack=struct.pack):
pickle.py(465):     dispatch[IntType] = save_int
pickle.py(467):     def save_long(self, obj, pack=struct.pack):
pickle.py(477):     dispatch[LongType] = save_long
pickle.py(479):     def save_float(self, obj, pack=struct.pack):
pickle.py(484):     dispatch[FloatType] = save_float
pickle.py(486):     def save_string(self, obj, pack=struct.pack):
pickle.py(496):     dispatch[StringType] = save_string
pickle.py(498):     def save_unicode(self, obj, pack=struct.pack):
pickle.py(508):     dispatch[UnicodeType] = save_unicode
pickle.py(510):     if StringType is UnicodeType:
pickle.py(538):     def save_tuple(self, obj):
pickle.py(589):     dispatch[TupleType] = save_tuple
pickle.py(594):     def save_empty_tuple(self, obj):
pickle.py(597):     def save_list(self, obj):
pickle.py(608):     dispatch[ListType] = save_list
pickle.py(612):     _BATCHSIZE = 1000
pickle.py(614):     def _batch_appends(self, items):
pickle.py(646):     def save_dict(self, obj):
pickle.py(657):     dispatch[DictionaryType] = save_dict
pickle.py(658):     if not PyStringMap is None:
pickle.py(661):     def _batch_setitems(self, items):
pickle.py(696):     def save_inst(self, obj):
pickle.py(734):     dispatch[InstanceType] = save_inst
pickle.py(736):     def save_global(self, obj, name=None, pack=struct.pack):
pickle.py(776):     dispatch[ClassType] = save_global
pickle.py(777):     dispatch[FunctionType] = save_global
pickle.py(778):     dispatch[BuiltinFunctionType] = save_global
pickle.py(779):     dispatch[TypeType] = save_global
pickle.py(783): def _keep_alive(x, memo):
pickle.py(803): classmap = {} # called classmap for backwards compatibility
pickle.py(805): def whichmodule(func, funcname):
pickle.py(833): class Unpickler:
 --- modulename: pickle, funcname: Unpickler
pickle.py(833): class Unpickler:
pickle.py(835):     def __init__(self, file):
pickle.py(851):     def load(self):
pickle.py(876):     def marker(self):
pickle.py(883):     dispatch = {}
pickle.py(885):     def load_eof(self):
pickle.py(887):     dispatch[''] = load_eof
pickle.py(889):     def load_proto(self):
pickle.py(893):     dispatch[PROTO] = load_proto
pickle.py(895):     def load_persid(self):
pickle.py(898):     dispatch[PERSID] = load_persid
pickle.py(900):     def load_binpersid(self):
pickle.py(903):     dispatch[BINPERSID] = load_binpersid
pickle.py(905):     def load_none(self):
pickle.py(907):     dispatch[NONE] = load_none
pickle.py(909):     def load_false(self):
pickle.py(911):     dispatch[NEWFALSE] = load_false
pickle.py(913):     def load_true(self):
pickle.py(915):     dispatch[NEWTRUE] = load_true
pickle.py(917):     def load_int(self):
pickle.py(929):     dispatch[INT] = load_int
pickle.py(931):     def load_binint(self):
pickle.py(933):     dispatch[BININT] = load_binint
pickle.py(935):     def load_binint1(self):
pickle.py(937):     dispatch[BININT1] = load_binint1
pickle.py(939):     def load_binint2(self):
pickle.py(941):     dispatch[BININT2] = load_binint2
pickle.py(943):     def load_long(self):
pickle.py(945):     dispatch[LONG] = load_long
pickle.py(947):     def load_long1(self):
pickle.py(951):     dispatch[LONG1] = load_long1
pickle.py(953):     def load_long4(self):
pickle.py(957):     dispatch[LONG4] = load_long4
pickle.py(959):     def load_float(self):
pickle.py(961):     dispatch[FLOAT] = load_float
pickle.py(963):     def load_binfloat(self, unpack=struct.unpack):
pickle.py(965):     dispatch[BINFLOAT] = load_binfloat
pickle.py(967):     def load_string(self):
pickle.py(978):     dispatch[STRING] = load_string
pickle.py(980):     def load_binstring(self):
pickle.py(983):     dispatch[BINSTRING] = load_binstring
pickle.py(985):     def load_unicode(self):
pickle.py(987):     dispatch[UNICODE] = load_unicode
pickle.py(989):     def load_binunicode(self):
pickle.py(992):     dispatch[BINUNICODE] = load_binunicode
pickle.py(994):     def load_short_binstring(self):
pickle.py(997):     dispatch[SHORT_BINSTRING] = load_short_binstring
pickle.py(999):     def load_tuple(self):
pickle.py(1002):     dispatch[TUPLE] = load_tuple
pickle.py(1004):     def load_empty_tuple(self):
pickle.py(1006):     dispatch[EMPTY_TUPLE] = load_empty_tuple
pickle.py(1008):     def load_tuple1(self):
pickle.py(1010):     dispatch[TUPLE1] = load_tuple1
pickle.py(1012):     def load_tuple2(self):
pickle.py(1014):     dispatch[TUPLE2] = load_tuple2
pickle.py(1016):     def load_tuple3(self):
pickle.py(1018):     dispatch[TUPLE3] = load_tuple3
pickle.py(1020):     def load_empty_list(self):
pickle.py(1022):     dispatch[EMPTY_LIST] = load_empty_list
pickle.py(1024):     def load_empty_dictionary(self):
pickle.py(1026):     dispatch[EMPTY_DICT] = load_empty_dictionary
pickle.py(1028):     def load_list(self):
pickle.py(1031):     dispatch[LIST] = load_list
pickle.py(1033):     def load_dict(self):
pickle.py(1042):     dispatch[DICT] = load_dict
pickle.py(1049):     def _instantiate(self, klass, k):
pickle.py(1072):     def load_inst(self):
pickle.py(1077):     dispatch[INST] = load_inst
pickle.py(1079):     def load_obj(self):
pickle.py(1084):     dispatch[OBJ] = load_obj
pickle.py(1086):     def load_newobj(self):
pickle.py(1091):     dispatch[NEWOBJ] = load_newobj
pickle.py(1093):     def load_global(self):
pickle.py(1098):     dispatch[GLOBAL] = load_global
pickle.py(1100):     def load_ext1(self):
pickle.py(1103):     dispatch[EXT1] = load_ext1
pickle.py(1105):     def load_ext2(self):
pickle.py(1108):     dispatch[EXT2] = load_ext2
pickle.py(1110):     def load_ext4(self):
pickle.py(1113):     dispatch[EXT4] = load_ext4
pickle.py(1115):     def get_extension(self, code):
pickle.py(1128):     def find_class(self, module, name):
pickle.py(1135):     def load_reduce(self):
pickle.py(1141):     dispatch[REDUCE] = load_reduce
pickle.py(1143):     def load_pop(self):
pickle.py(1145):     dispatch[POP] = load_pop
pickle.py(1147):     def load_pop_mark(self):
pickle.py(1150):     dispatch[POP_MARK] = load_pop_mark
pickle.py(1152):     def load_dup(self):
pickle.py(1154):     dispatch[DUP] = load_dup
pickle.py(1156):     def load_get(self):
pickle.py(1158):     dispatch[GET] = load_get
pickle.py(1160):     def load_binget(self):
pickle.py(1163):     dispatch[BINGET] = load_binget
pickle.py(1165):     def load_long_binget(self):
pickle.py(1168):     dispatch[LONG_BINGET] = load_long_binget
pickle.py(1170):     def load_put(self):
pickle.py(1172):     dispatch[PUT] = load_put
pickle.py(1174):     def load_binput(self):
pickle.py(1177):     dispatch[BINPUT] = load_binput
pickle.py(1179):     def load_long_binput(self):
pickle.py(1182):     dispatch[LONG_BINPUT] = load_long_binput
pickle.py(1184):     def load_append(self):
pickle.py(1189):     dispatch[APPEND] = load_append
pickle.py(1191):     def load_appends(self):
pickle.py(1197):     dispatch[APPENDS] = load_appends
pickle.py(1199):     def load_setitem(self):
pickle.py(1205):     dispatch[SETITEM] = load_setitem
pickle.py(1207):     def load_setitems(self):
pickle.py(1215):     dispatch[SETITEMS] = load_setitems
pickle.py(1217):     def load_build(self):
pickle.py(1254):     dispatch[BUILD] = load_build
pickle.py(1256):     def load_mark(self):
pickle.py(1258):     dispatch[MARK] = load_mark
pickle.py(1260):     def load_stop(self):
pickle.py(1263):     dispatch[STOP] = load_stop
pickle.py(1267): class _EmptyClass:
 --- modulename: pickle, funcname: _EmptyClass
pickle.py(1267): class _EmptyClass:
pickle.py(1268):     pass
pickle.py(1272): import binascii as _binascii
pickle.py(1274): def encode_long(x):
pickle.py(1340): def decode_long(data):
pickle.py(1370): try:
pickle.py(1371):     from cStringIO import StringIO
pickle.py(1375): def dump(obj, file, protocol=None):
pickle.py(1378): def dumps(obj, protocol=None):
pickle.py(1383): def load(file):
pickle.py(1386): def loads(str):
pickle.py(1392): def _test():
pickle.py(1396): if __name__ == "__main__":
subprocess.py(435):     _PIPE_BUF = getattr(select, 'PIPE_BUF', 512)
subprocess.py(438): __all__ = ["Popen", "PIPE", "STDOUT", "call", "check_call",
subprocess.py(439):            "check_output", "CalledProcessError"]
subprocess.py(441): if mswindows:
subprocess.py(451): try:
subprocess.py(452):     MAXFD = os.sysconf("SC_OPEN_MAX")
subprocess.py(456): _active = []
subprocess.py(458): def _cleanup():
subprocess.py(469): PIPE = -1
subprocess.py(470): STDOUT = -2
subprocess.py(473): def _eintr_retry_call(func, *args):
subprocess.py(487): def _args_from_interpreter_flags():
subprocess.py(514): def call(*popenargs, **kwargs):
subprocess.py(525): def check_call(*popenargs, **kwargs):
subprocess.py(544): def check_output(*popenargs, **kwargs):
subprocess.py(577): def list2cmdline(seq):
subprocess.py(647): class Popen(object):
 --- modulename: subprocess, funcname: Popen
subprocess.py(647): class Popen(object):
subprocess.py(648):     _child_created = False  # Set here since __del__ checks it
subprocess.py(650):     def __init__(self, args, bufsize=0, executable=None,
subprocess.py(651):                  stdin=None, stdout=None, stderr=None,
subprocess.py(652):                  preexec_fn=None, close_fds=False, shell=False,
subprocess.py(653):                  cwd=None, env=None, universal_newlines=False,
subprocess.py(654):                  startupinfo=None, creationflags=0):
subprocess.py(748):     def _translate_newlines(self, data):
subprocess.py(754):     def __del__(self, _maxint=sys.maxint):
subprocess.py(768):     def communicate(self, input=None):
subprocess.py(802):     def poll(self):
subprocess.py(806):     if mswindows:
subprocess.py(1107):         def _get_handles(self, stdin, stdout, stderr):
subprocess.py(1156):         def _set_cloexec_flag(self, fd, cloexec=True):
subprocess.py(1169):         def pipe_cloexec(self):
subprocess.py(1181):         def _close_fds(self, but):
subprocess.py(1195):         def _execute_child(self, args, executable, preexec_fn, close_fds,
subprocess.py(1338):         def _handle_exitstatus(self, sts, _WIFSIGNALED=os.WIFSIGNALED,
subprocess.py(1339):                 _WTERMSIG=os.WTERMSIG, _WIFEXITED=os.WIFEXITED,
subprocess.py(1340):                 _WEXITSTATUS=os.WEXITSTATUS):
subprocess.py(1352):         def _internal_poll(self, _deadstate=None, _waitpid=os.waitpid,
subprocess.py(1353):                 _WNOHANG=os.WNOHANG, _os_error=os.error, _ECHILD=errno.ECHILD):
subprocess.py(1379):         def wait(self):
subprocess.py(1400):         def _communicate(self, input):
subprocess.py(1433):         def _communicate_with_poll(self, input):
subprocess.py(1494):         def _communicate_with_select(self, input):
subprocess.py(1551):         def send_signal(self, sig):
subprocess.py(1556):         def terminate(self):
subprocess.py(1561):         def kill(self):
subprocess.py(1567): def _demo_posix():
subprocess.py(1608): def _demo_windows():
subprocess.py(1625): if __name__ == "__main__":
util.py(43): from multiprocessing.process import current_process, active_children
util.py(46):     'sub_debug', 'debug', 'info', 'sub_warning', 'get_logger',
util.py(47):     'log_to_stderr', 'get_temp_dir', 'register_after_fork',
util.py(48):     'is_exiting', 'Finalize', 'ForkAwareThreadLock', 'ForkAwareLocal',
util.py(49):     'SUBDEBUG', 'SUBWARNING',
util.py(56): NOTSET = 0
util.py(57): SUBDEBUG = 5
util.py(58): DEBUG = 10
util.py(59): INFO = 20
util.py(60): SUBWARNING = 25
util.py(62): LOGGER_NAME = 'multiprocessing'
util.py(63): DEFAULT_LOGGING_FORMAT = '[%(levelname)s/%(processName)s] %(message)s'
util.py(65): _logger = None
util.py(66): _log_to_stderr = False
util.py(68): def sub_debug(msg, *args):
util.py(72): def debug(msg, *args):
util.py(76): def info(msg, *args):
util.py(80): def sub_warning(msg, *args):
util.py(84): def get_logger():
util.py(113): def log_to_stderr(level=None):
util.py(135): def get_temp_dir():
util.py(149): _afterfork_registry = weakref.WeakValueDictionary()
 --- modulename: weakref, funcname: __init__
weakref.py(48):         if not args:
weakref.py(51):         self = args[0]
weakref.py(52):         args = args[1:]
weakref.py(53):         if len(args) > 1:
weakref.py(55):         def remove(wr, selfref=ref(self)):
weakref.py(62):         self._remove = remove
weakref.py(64):         self._pending_removals = []
weakref.py(65):         self._iterating = set()
weakref.py(66):         UserDict.UserDict.__init__(self, *args, **kw)
 --- modulename: UserDict, funcname: __init__
UserDict.py(5):         if not args:
UserDict.py(8):         self = args[0]
UserDict.py(9):         args = args[1:]
UserDict.py(10):         if len(args) > 1:
UserDict.py(12):         if args:
UserDict.py(14):         elif 'dict' in kwargs:
UserDict.py(21):             dict = None
UserDict.py(22):         self.data = {}
UserDict.py(23):         if dict is not None:
UserDict.py(25):         if len(kwargs):
util.py(150): _afterfork_counter = itertools.count()
util.py(152): def _run_after_forkers():
util.py(161): def register_after_fork(obj, func):
util.py(168): _finalizer_registry = {}
util.py(169): _finalizer_counter = itertools.count()
util.py(172): class Finalize(object):
 --- modulename: util, funcname: Finalize
util.py(172): class Finalize(object):
util.py(175):     '''
util.py(176):     def __init__(self, obj, callback, args=(), kwargs=None, exitpriority=None):
util.py(192):     def __call__(self, wr=None):
util.py(212):     def cancel(self):
util.py(224):     def still_active(self):
util.py(230):     def __repr__(self):
util.py(250): def _run_finalizers(minpriority=None):
util.py(286): def is_exiting():
util.py(292): _exiting = False
util.py(294): def _exit_function(info=info, debug=debug, _run_finalizers=_run_finalizers,
util.py(295):                    active_children=active_children,
util.py(296):                    current_process=current_process):
util.py(330): atexit.register(_exit_function)
 --- modulename: atexit, funcname: register
atexit.py(46):     _exithandlers.append((func, targs, kargs))
atexit.py(47):     return func
util.py(336): class ForkAwareThreadLock(object):
 --- modulename: util, funcname: ForkAwareThreadLock
util.py(336): class ForkAwareThreadLock(object):
util.py(337):     def __init__(self):
util.py(341):     def _reset(self):
util.py(346): class ForkAwareLocal(threading.local):
 --- modulename: util, funcname: ForkAwareLocal
util.py(346): class ForkAwareLocal(threading.local):
util.py(347):     def __init__(self):
util.py(349):     def __reduce__(self):
__init__.py(71): class ProcessError(Exception):
 --- modulename: __init__, funcname: ProcessError
__init__.py(71): class ProcessError(Exception):
__init__.py(72):     pass
__init__.py(74): class BufferTooShort(ProcessError):
 --- modulename: __init__, funcname: BufferTooShort
__init__.py(74): class BufferTooShort(ProcessError):
__init__.py(75):     pass
__init__.py(77): class TimeoutError(ProcessError):
 --- modulename: __init__, funcname: TimeoutError
__init__.py(77): class TimeoutError(ProcessError):
__init__.py(78):     pass
__init__.py(80): class AuthenticationError(ProcessError):
 --- modulename: __init__, funcname: AuthenticationError
__init__.py(80): class AuthenticationError(ProcessError):
__init__.py(81):     pass
__init__.py(84): import _multiprocessing
__init__.py(90): def Manager():
__init__.py(102): def Pipe(duplex=True):
__init__.py(109): def cpu_count():
__init__.py(138): def freeze_support():
__init__.py(147): def get_logger():
__init__.py(154): def log_to_stderr(level=None):
__init__.py(161): def allow_connection_pickling():
__init__.py(171): def Lock():
__init__.py(178): def RLock():
__init__.py(185): def Condition(lock=None):
__init__.py(192): def Semaphore(value=1):
__init__.py(199): def BoundedSemaphore(value=1):
__init__.py(206): def Event():
__init__.py(213): def Queue(maxsize=0):
__init__.py(220): def JoinableQueue(maxsize=0):
__init__.py(227): def Pool(processes=None, initializer=None, initargs=(), maxtasksperchild=None):
__init__.py(234): def RawValue(typecode_or_type, *args):
__init__.py(241): def RawArray(typecode_or_type, size_or_initializer):
__init__.py(248): def Value(typecode_or_type, *args, **kwds):
__init__.py(255): def Array(typecode_or_type, size_or_initializer, **kwds):
__init__.py(266): if sys.platform == 'win32':
monkey.py(7): import multiprocessing.process
monkey.py(8): import sys
monkey.py(12): PATCHED_MARKER = "_coverage$patched"
monkey.py(15): def patch_multiprocessing():
control.py(28): from coverage.plugin import FileReporter
 --- modulename: plugin, funcname: <module>
plugin.py(4): """Plugin interfaces for coverage.py"""
plugin.py(6): from coverage import files
plugin.py(7): from coverage.misc import contract, _needs_to_implement
plugin.py(10): class CoveragePlugin(object):
 --- modulename: plugin, funcname: CoveragePlugin
plugin.py(10): class CoveragePlugin(object):
plugin.py(42):     """
plugin.py(44):     def file_tracer(self, filename):        # pylint: disable=unused-argument
plugin.py(81):     def file_reporter(self, filename):      # pylint: disable=unused-argument
plugin.py(92):     def sys_info(self):
plugin.py(104): class FileTracer(object):
 --- modulename: plugin, funcname: FileTracer
plugin.py(104): class FileTracer(object):
plugin.py(116):     """
plugin.py(118):     def source_filename(self):
plugin.py(133):     def has_dynamic_source_filename(self):
plugin.py(151):     def dynamic_source_filename(self, filename, frame):     # pylint: disable=unused-argument
plugin.py(166):     def line_number_range(self, frame):
plugin.py(184): class FileReporter(object):
 --- modulename: plugin, funcname: FileReporter
plugin.py(184): class FileReporter(object):
plugin.py(195):     """
plugin.py(197):     def __init__(self, filename):
plugin.py(207):     def __repr__(self):
plugin.py(210):     def relative_filename(self):
plugin.py(221):     @contract(returns='unicode')
 --- modulename: misc, funcname: contract
misc.py(61):         return lambda func: func
 --- modulename: misc, funcname: <lambda>
misc.py(61):         return lambda func: func
plugin.py(235):     def lines(self):
plugin.py(246):     def excluded_lines(self):
plugin.py(259):     def translate_lines(self, lines):
plugin.py(279):     def arcs(self):
plugin.py(293):     def no_branch_lines(self):
plugin.py(306):     def translate_arcs(self, arcs):
plugin.py(319):     def exit_counts(self):
plugin.py(332):     def source_token_lines(self):
plugin.py(365):     def __eq__(self, other):
plugin.py(368):     def __ne__(self, other):
plugin.py(371):     def __lt__(self, other):
plugin.py(374):     def __le__(self, other):
plugin.py(377):     def __gt__(self, other):
plugin.py(380):     def __ge__(self, other):
control.py(29): from coverage.plugin_support import Plugins
 --- modulename: plugin_support, funcname: <module>
plugin_support.py(4): """Support for plugins."""
plugin_support.py(6): import os
plugin_support.py(7): import os.path
plugin_support.py(8): import sys
plugin_support.py(10): from coverage.misc import CoverageException, isolate_module
plugin_support.py(11): from coverage.plugin import CoveragePlugin, FileTracer, FileReporter
plugin_support.py(13): os = isolate_module(os)
 --- modulename: misc, funcname: isolate_module
misc.py(28):     if mod not in ISOLATED_MODULES:
misc.py(36):     return ISOLATED_MODULES[mod]
plugin_support.py(16): class Plugins(object):
 --- modulename: plugin_support, funcname: Plugins
plugin_support.py(16): class Plugins(object):
plugin_support.py(17):     """The currently loaded collection of coverage.py plugins."""
plugin_support.py(19):     def __init__(self):
plugin_support.py(27):     @classmethod
plugin_support.py(28):     def load_plugins(cls, modules, config, debug=None):
plugin_support.py(54):     def add_file_tracer(self, plugin):
plugin_support.py(63):     def add_noop(self, plugin):
plugin_support.py(71):     def _add_plugin(self, plugin, specialized):
plugin_support.py(92):     def __nonzero__(self):
plugin_support.py(95):     __bool__ = __nonzero__
plugin_support.py(97):     def __iter__(self):
plugin_support.py(100):     def get(self, plugin_name):
plugin_support.py(105): class LabelledDebug(object):
 --- modulename: plugin_support, funcname: LabelledDebug
plugin_support.py(105): class LabelledDebug(object):
plugin_support.py(106):     """A Debug writer, but with labels for prepending to the messages."""
plugin_support.py(108):     def __init__(self, label, debug, prev_labels=()):
plugin_support.py(112):     def add_label(self, label):
plugin_support.py(116):     def message_prefix(self):
plugin_support.py(121):     def write(self, message):
plugin_support.py(126): class DebugPluginWrapper(CoveragePlugin):
 --- modulename: plugin_support, funcname: DebugPluginWrapper
plugin_support.py(126): class DebugPluginWrapper(CoveragePlugin):
plugin_support.py(127):     """Wrap a plugin, and use debug to report on what it's doing."""
plugin_support.py(129):     def __init__(self, plugin, debug):
plugin_support.py(134):     def file_tracer(self, filename):
plugin_support.py(142):     def file_reporter(self, filename):
plugin_support.py(150):     def sys_info(self):
plugin_support.py(154): class DebugFileTracerWrapper(FileTracer):
 --- modulename: plugin_support, funcname: DebugFileTracerWrapper
plugin_support.py(154): class DebugFileTracerWrapper(FileTracer):
plugin_support.py(155):     """A debugging `FileTracer`."""
plugin_support.py(157):     def __init__(self, tracer, debug):
plugin_support.py(161):     def _show_frame(self, frame):
plugin_support.py(168):     def source_filename(self):
plugin_support.py(173):     def has_dynamic_source_filename(self):
plugin_support.py(178):     def dynamic_source_filename(self, filename, frame):
plugin_support.py(185):     def line_number_range(self, frame):
plugin_support.py(191): class DebugFileReporterWrapper(FileReporter):
 --- modulename: plugin_support, funcname: DebugFileReporterWrapper
plugin_support.py(191): class DebugFileReporterWrapper(FileReporter):
plugin_support.py(192):     """A debugging `FileReporter`."""
plugin_support.py(194):     def __init__(self, filename, reporter, debug):
plugin_support.py(199):     def relative_filename(self):
plugin_support.py(204):     def lines(self):
plugin_support.py(209):     def excluded_lines(self):
plugin_support.py(214):     def translate_lines(self, lines):
plugin_support.py(219):     def translate_arcs(self, arcs):
plugin_support.py(224):     def no_branch_lines(self):
plugin_support.py(229):     def exit_counts(self):
plugin_support.py(234):     def arcs(self):
plugin_support.py(239):     def source(self):
plugin_support.py(244):     def source_token_lines(self):
control.py(30): from coverage.python import PythonFileReporter
 --- modulename: python, funcname: <module>
python.py(4): """Python source expertise for coverage.py"""
python.py(6): import os.path
python.py(7): import zipimport
python.py(9): from coverage import env, files
python.py(10): from coverage.misc import contract, expensive, NoSource, join_regex, isolate_module
python.py(11): from coverage.parser import PythonParser
 --- modulename: parser, funcname: <module>
parser.py(4): """Code parsing for coverage.py."""
parser.py(6): import collections
parser.py(7): import dis
parser.py(8): import re
parser.py(9): import token
parser.py(10): import tokenize
parser.py(12): from coverage.backward import range    # pylint: disable=redefined-builtin
parser.py(13): from coverage.backward import bytes_to_ints
parser.py(14): from coverage.bytecode import ByteCodes, CodeObjects
 --- modulename: bytecode, funcname: <module>
bytecode.py(4): """Bytecode manipulation for coverage.py"""
bytecode.py(6): import opcode
bytecode.py(7): import types
bytecode.py(9): from coverage.backward import byte_to_int
bytecode.py(12): class ByteCode(object):
 --- modulename: bytecode, funcname: ByteCode
bytecode.py(12): class ByteCode(object):
bytecode.py(13):     """A single bytecode."""
bytecode.py(14):     def __init__(self):
bytecode.py(31): class ByteCodes(object):
 --- modulename: bytecode, funcname: ByteCodes
bytecode.py(31): class ByteCodes(object):
bytecode.py(39):     """
bytecode.py(40):     def __init__(self, code):
bytecode.py(43):     def __getitem__(self, i):
bytecode.py(46):     def __iter__(self):
bytecode.py(74): class CodeObjects(object):
 --- modulename: bytecode, funcname: CodeObjects
bytecode.py(74): class CodeObjects(object):
bytecode.py(75):     """Iterate over all the code objects in `code`."""
bytecode.py(76):     def __init__(self, code):
bytecode.py(79):     def __iter__(self):
parser.py(15): from coverage.misc import contract, nice_pair, expensive, join_regex
parser.py(16): from coverage.misc import CoverageException, NoSource, NotPython
parser.py(17): from coverage.phystokens import compile_unicode, generate_tokens
 --- modulename: phystokens, funcname: <module>
phystokens.py(4): """Better tokenizing for coverage.py."""
phystokens.py(6): import codecs
phystokens.py(7): import keyword
phystokens.py(8): import re
phystokens.py(9): import sys
phystokens.py(10): import token
phystokens.py(11): import tokenize
phystokens.py(13): from coverage import env
phystokens.py(14): from coverage.backward import iternext
phystokens.py(15): from coverage.misc import contract
phystokens.py(18): def phys_tokens(toks):
phystokens.py(74): @contract(source='unicode')
 --- modulename: misc, funcname: contract
misc.py(61):         return lambda func: func
 --- modulename: misc, funcname: <lambda>
misc.py(61):         return lambda func: func
phystokens.py(128): class CachedTokenizer(object):
 --- modulename: phystokens, funcname: CachedTokenizer
phystokens.py(128): class CachedTokenizer(object):
phystokens.py(138):     """
phystokens.py(139):     def __init__(self):
phystokens.py(143):     @contract(text='unicode')
 --- modulename: misc, funcname: contract
misc.py(61):         return lambda func: func
 --- modulename: misc, funcname: <lambda>
misc.py(61):         return lambda func: func
phystokens.py(153): generate_tokens = CachedTokenizer().generate_tokens
 --- modulename: phystokens, funcname: __init__
phystokens.py(140):         self.last_text = None
phystokens.py(141):         self.last_tokens = None
phystokens.py(156): COOKIE_RE = re.compile(r"^[ \t]*#.*coding[:=][ \t]*([-\w.]+)", flags=re.MULTILINE)
 --- modulename: re, funcname: compile
re.py(194):     return _compile(pattern, flags)
 --- modulename: re, funcname: _compile
re.py(232):     pattern, flags = key
re.py(233):     bypass_cache = flags & DEBUG
re.py(234):     if not bypass_cache:
re.py(235):         cachekey = (type(key[0]),) + key
re.py(236):         try:
re.py(237):             p, loc = _cache[cachekey]
re.py(240):         except KeyError:
re.py(241):             pass
re.py(242):     if isinstance(pattern, _pattern_type):
re.py(246):     if not sre_compile.isstring(pattern):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
re.py(248):     try:
re.py(249):         p = sre_compile.compile(pattern, flags)
 --- modulename: sre_compile, funcname: compile
sre_compile.py(570):     if isstring(p):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(547):     for tp in STRING_TYPES:
sre_compile.py(548):         if isinstance(obj, tp):
sre_compile.py(549):             return 1
sre_compile.py(571):         pattern = p
sre_compile.py(572):         p = sre_parse.parse(p, flags)
 --- modulename: sre_parse, funcname: parse
sre_parse.py(709):     source = Tokenizer(str)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(190):         self.string = string
sre_parse.py(191):         self.index = 0
sre_parse.py(192):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(711):     if pattern is None:
sre_parse.py(712):         pattern = Pattern()
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(68):         self.flags = 0
sre_parse.py(69):         self.open = []
sre_parse.py(70):         self.groups = 1
sre_parse.py(71):         self.groupdict = {}
sre_parse.py(72):         self.lookbehind = 0
sre_parse.py(713):     pattern.flags = flags
sre_parse.py(714):     pattern.str = str
sre_parse.py(716):     p = _parse_sub(source, pattern, 0)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(691):         elif this == "^":
sre_parse.py(692):             subpatternappend((AT, AT_BEGINNING))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(240):         return code
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(493):                 min, max = 0, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(542):             subpatternappend((ANY, None))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(493):                 min, max = 0, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(429):             subpatternappend((LITERAL, ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(240):         return code
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(493):                 min, max = 0, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(541):         elif this == ".":
sre_parse.py(544):         elif this == "(":
sre_parse.py(545):             group = 1
sre_parse.py(546):             name = None
sre_parse.py(547):             condgroup = None
sre_parse.py(548):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(666):             if group:
sre_parse.py(668):                 if group == 2:
sre_parse.py(672):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(75):         gid = self.groups
sre_parse.py(76):         self.groups = gid + 1
sre_parse.py(77):         if name is not None:
sre_parse.py(83):         self.open.append(gid)
sre_parse.py(84):         return gid
sre_parse.py(673):                 if condgroup:
sre_parse.py(676):                     p = _parse_sub(source, state)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(320):     items = []
sre_parse.py(321):     itemsappend = items.append
sre_parse.py(322):     sourcematch = source.match
sre_parse.py(323):     while 1:
sre_parse.py(324):         itemsappend(_parse(source, state))
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(397):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(95):             data = []
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(400):     subpatternappend = subpattern.append
sre_parse.py(401):     sourceget = source.get
sre_parse.py(402):     sourcematch = source.match
sre_parse.py(403):     _len = len
sre_parse.py(404):     PATTERNENDERS = _PATTERNENDERS
sre_parse.py(405):     ASSERTCHARS = _ASSERTCHARS
sre_parse.py(406):     LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS
sre_parse.py(407):     REPEATCODES = _REPEATCODES
sre_parse.py(409):     while 1:
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(433):             set = []
sre_parse.py(434):             setappend = set.append
sre_parse.py(437):             if sourcematch("^"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(440):             start = set[:]
sre_parse.py(441):             while 1:
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(199):             try:
sre_parse.py(200):                 c = self.string[self.index + 1]
sre_parse.py(203):             char = char + c
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(446):                     code1 = _class_escape(source, this)
 --- modulename: sre_parse, funcname: _class_escape
sre_parse.py(238):     code = ESCAPES.get(escape)
sre_parse.py(239):     if code:
sre_parse.py(241):     code = CATEGORIES.get(escape)
sre_parse.py(242):     if code and code[0] == IN:
sre_parse.py(243):         return code
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(476):                         code1 = code1[1][0]
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(445):                 elif this and this[0] == "\\":
sre_parse.py(447):                 elif this:
sre_parse.py(448):                     code1 = LITERAL, ord(this)
sre_parse.py(451):                 if sourcematch("-"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(475):                     if code1[0] is IN:
sre_parse.py(477):                     setappend(code1)
sre_parse.py(442):                 this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(443):                 if this == "]" and set != start:
sre_parse.py(444):                     break
sre_parse.py(480):             if _len(set)==1 and set[0][0] is LITERAL:
sre_parse.py(482):             elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:
sre_parse.py(486):                 subpatternappend((IN, set))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(197):         char = self.string[self.index]
sre_parse.py(198):         if char[0] == "\\":
sre_parse.py(204):         self.index = self.index + len(char)
sre_parse.py(205):         self.next = char
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(417):         if state.flags & SRE_FLAG_VERBOSE:
sre_parse.py(428):         if this and this[0] not in SPECIAL_CHARS:
sre_parse.py(431):         elif this == "[":
sre_parse.py(488):         elif this and this[0] in REPEAT_CHARS:
sre_parse.py(490):             if this == "?":
sre_parse.py(492):             elif this == "*":
sre_parse.py(495):             elif this == "+":
sre_parse.py(496):                 min, max = 1, MAXREPEAT
sre_parse.py(528):             if subpattern:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
sre_parse.py(529):                 item = subpattern[-1:]
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(143):             return SubPattern(self.pattern, self.data[index])
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(93):         self.pattern = pattern
sre_parse.py(94):         if data is None:
sre_parse.py(96):         self.data = data
sre_parse.py(97):         self.width = None
sre_parse.py(532):             if not item or (_len(item) == 1 and item[0][0] == AT):
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(138):         return len(self.data)
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(534):             if item[0][0] in REPEATCODES:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_parse.py(536):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(539):                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
 --- modulename: sre_parse, funcname: __setitem__
sre_parse.py(146):         self.data[index] = code
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(412):             break # end of subpattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(329):         if not source.next or sourcematch(")", 0):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(210):             return 1
sre_parse.py(330):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(677):                 if not sourcematch(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(208):             if skip:
sre_parse.py(209):                 self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(210):             return 1
sre_parse.py(679):                 if group is not None:
sre_parse.py(680):                     state.closegroup(group)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(86):         self.open.remove(gid)
sre_parse.py(681):                 subpatternappend((SUBPATTERN, (group, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(150):         self.data.append(code)
sre_parse.py(411):         if source.next in PATTERNENDERS:
sre_parse.py(413):         this = sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(414):         if this is None:
sre_parse.py(415):             break # end of pattern
sre_parse.py(704):     return subpattern
sre_parse.py(325):         if sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(207):         if char == self.next:
sre_parse.py(211):         return 0
sre_parse.py(327):         if not nested:
sre_parse.py(328):             break
sre_parse.py(334):     if len(items) == 1:
sre_parse.py(335):         return items[0]
sre_parse.py(718):     tail = source.get()
 --- modulename: sre_parse, funcname: get
sre_parse.py(213):         this = self.next
sre_parse.py(214):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(194):         if self.index >= len(self.string):
sre_parse.py(195):             self.next = None
sre_parse.py(196):             return
sre_parse.py(215):         return this
sre_parse.py(719):     if tail == ")":
sre_parse.py(721):     elif tail:
sre_parse.py(724):     if flags & SRE_FLAG_DEBUG:
sre_parse.py(727):     if not (flags & SRE_FLAG_VERBOSE) and p.pattern.flags & SRE_FLAG_VERBOSE:
sre_parse.py(732):     return p
sre_compile.py(576):     code = _code(p, flags)
 --- modulename: sre_compile, funcname: _code
sre_compile.py(554):     flags = p.pattern.flags | flags
sre_compile.py(555):     code = []
sre_compile.py(558):     _compile_info(code, p, flags)
 --- modulename: sre_compile, funcname: _compile_info
sre_compile.py(437):     lo, hi = pattern.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(183):             elif op == SUCCESS:
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(173):                 i, j = av[1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(177):                 i, j = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(155):         lo = hi = 0
sre_parse.py(156):         UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)
sre_parse.py(157):         REPEATCODES = (MIN_REPEAT, MAX_REPEAT)
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(159):             if op is BRANCH:
sre_parse.py(168):             elif op is CALL:
sre_parse.py(172):             elif op is SUBPATTERN:
sre_parse.py(176):             elif op in REPEATCODES:
sre_parse.py(180):             elif op in UNITCODES:
sre_parse.py(181):                 lo = lo + 1
sre_parse.py(182):                 hi = hi + 1
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(178):                 lo = lo + i * av[0]
sre_parse.py(179):                 hi = hi + j * av[1]
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_parse.py(174):                 lo = lo + i
sre_parse.py(175):                 hi = hi + j
sre_parse.py(158):         for op, av in self.data:
sre_parse.py(185):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(186):         return self.width
sre_compile.py(438):     if lo == 0:
sre_compile.py(441):     prefix = []
sre_compile.py(442):     prefixappend = prefix.append
sre_compile.py(443):     prefix_skip = 0
sre_compile.py(444):     charset = [] # not used
sre_compile.py(445):     charsetappend = charset.append
sre_compile.py(446):     if not (flags & SRE_FLAG_IGNORECASE):
sre_compile.py(448):         for op, av in pattern.data:
sre_compile.py(449):             if op is LITERAL:
sre_compile.py(453):             elif op is SUBPATTERN and len(av[1]) == 1:
sre_compile.py(460):                 break
sre_compile.py(462):         if not prefix and pattern.data:
sre_compile.py(463):             op, av = pattern.data[0]
sre_compile.py(464):             if op is SUBPATTERN and av[1]:
sre_compile.py(481):             elif op is BRANCH:
sre_compile.py(494):             elif op is IN:
sre_compile.py(501):     emit = code.append
sre_compile.py(502):     emit(OPCODES[INFO])
sre_compile.py(503):     skip = len(code); emit(0)
sre_compile.py(505):     mask = 0
sre_compile.py(506):     if prefix:
sre_compile.py(510):     elif charset:
sre_compile.py(512):     emit(mask)
sre_compile.py(514):     if lo < MAXCODE:
sre_compile.py(515):         emit(lo)
sre_compile.py(519):     if hi < MAXCODE:
sre_compile.py(522):         emit(0)
sre_compile.py(524):     if prefix:
sre_compile.py(535):     elif charset:
sre_compile.py(537):     code[skip] = len(code) - skip
sre_compile.py(561):     _compile(code, p.data, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(155):         elif op in SUCCESS_CODES:
sre_compile.py(157):         elif op in ASSERT_CODES:
sre_compile.py(170):         elif op is CALL:
sre_compile.py(176):         elif op is AT:
sre_compile.py(177):             emit(OPCODES[op])
sre_compile.py(178):             if flags & SRE_FLAG_MULTILINE:
sre_compile.py(179):                 av = AT_MULTILINE.get(av, av)
sre_compile.py(180):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(182):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(184):             emit(ATCODES[av])
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(110):             if flags & SRE_FLAG_DOTALL:
sre_compile.py(113):                 emit(OPCODES[ANY])
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(80):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(96):                 emit(OPCODES[op])
sre_compile.py(97):                 emit(av)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(331):                 out.append((LITERAL, p))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(339):         return charset
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(237):             emit(av)
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(146):         elif op is SUBPATTERN:
sre_compile.py(147):             if av[0]:
sre_compile.py(148):                 emit(OPCODES[MARK])
sre_compile.py(149):                 emit((av[0]-1)*2)
sre_compile.py(151):             _compile(code, av[1], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(109):         elif op is ANY:
sre_compile.py(114):         elif op in REPEATING_CODES:
sre_compile.py(115):             if flags & SRE_FLAG_TEMPLATE:
sre_compile.py(124):             elif _simple(av) and op is not REPEAT:
 --- modulename: sre_compile, funcname: _simple
sre_compile.py(430):     lo, hi = av[2].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(153):         if self.width:
sre_parse.py(154):             return self.width
sre_compile.py(431):     return lo == hi == 1 and av[2][0][0] != SUBPATTERN
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(125):                 if op is MAX_REPEAT:
sre_compile.py(126):                     emit(OPCODES[REPEAT_ONE])
sre_compile.py(129):                 skip = _len(code); emit(0)
sre_compile.py(130):                 emit(av[0])
sre_compile.py(131):                 emit(av[1])
sre_compile.py(132):                 _compile(code, av[2], flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(66):     emit = code.append
sre_compile.py(67):     _len = len
sre_compile.py(68):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(69):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(70):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(71):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(72):     if (flags & SRE_FLAG_IGNORECASE and
sre_compile.py(77):         fixes = None
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(79):         if op in LITERAL_CODES:
sre_compile.py(98):         elif op is IN:
sre_compile.py(99):             if flags & SRE_FLAG_IGNORECASE:
sre_compile.py(104):                 emit(OPCODES[op])
sre_compile.py(105):                 fixup = None
sre_compile.py(106):             skip = _len(code); emit(0)
sre_compile.py(107):             _compile_charset(av, flags, code, fixup, fixes)
 --- modulename: sre_compile, funcname: _compile_charset
sre_compile.py(230):     emit = code.append
sre_compile.py(231):     for op, av in _optimize_charset(charset, fixup, fixes,
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
 --- modulename: sre_compile, funcname: _optimize_charset
sre_compile.py(258):     out = []
sre_compile.py(259):     tail = []
sre_compile.py(260):     charmap = bytearray(256)
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(273):                 elif op is RANGE:
sre_compile.py(286):                 elif op is NEGATE:
sre_compile.py(289):                     tail.append((op, av))
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(262):         while True:
sre_compile.py(263):             try:
sre_compile.py(264):                 if op is LITERAL:
sre_compile.py(265):                     if fixup:
sre_compile.py(272):                         charmap[av] = 1
sre_compile.py(310):             break
sre_compile.py(261):     for op, av in charset:
sre_compile.py(313):     runs = []
sre_compile.py(314):     q = 0
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(319):         if len(runs) >= 2:
sre_compile.py(322):         q = charmap.find(b'\0', p)
sre_compile.py(323):         if q < 0:
sre_compile.py(326):         runs.append((p, q))
sre_compile.py(315):     while True:
sre_compile.py(316):         p = charmap.find(b'\1', q)
sre_compile.py(317):         if p < 0:
sre_compile.py(318):             break
sre_compile.py(327):     if runs is not None:
sre_compile.py(329):         for p, q in runs:
sre_compile.py(330):             if q - p == 1:
sre_compile.py(333):                 out.append((RANGE, (p, q - 1)))
sre_compile.py(329):         for p, q in runs:
sre_compile.py(334):         out += tail
sre_compile.py(336):         if fixup or len(out) < len(charset):
sre_compile.py(337):             return out
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(239):             emit(av[0])
sre_compile.py(240):             emit(av[1])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(233):         emit(OPCODES[op])
sre_compile.py(234):         if op is NEGATE:
sre_compile.py(236):         elif op is LITERAL:
sre_compile.py(238):         elif op is RANGE:
sre_compile.py(241):         elif op is CHARSET:
sre_compile.py(243):         elif op is BIGCHARSET:
sre_compile.py(245):         elif op is CATEGORY:
sre_compile.py(246):             if flags & SRE_FLAG_LOCALE:
sre_compile.py(248):             elif flags & SRE_FLAG_UNICODE:
sre_compile.py(251):                 emit(CHCODES[av])
sre_compile.py(232):                                     flags & SRE_FLAG_UNICODE):
sre_compile.py(254):     emit(OPCODES[FAILURE])
sre_compile.py(108):             code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(133):                 emit(OPCODES[SUCCESS])
sre_compile.py(134):                 code[skip] = _len(code) - skip
sre_compile.py(78):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(142):         if isinstance(index, slice):
sre_parse.py(144):         return self.data[index]
sre_compile.py(152):             if av[0]:
sre_compile.py(153):                 emit(OPCODES[MARK])
sre_compile.py(154):                 emit((av[0]-1)*2+1)
sre_compile.py(78):     for op, av in pattern:
sre_compile.py(563):     code.append(OPCODES[SUCCESS])
sre_compile.py(565):     return code
sre_compile.py(581):     if p.pattern.groups > 100:
sre_compile.py(587):     groupindex = p.pattern.groupdict
sre_compile.py(588):     indexgroup = [None] * p.pattern.groups
sre_compile.py(589):     for k, i in groupindex.items():
sre_compile.py(592):     return _sre.compile(
sre_compile.py(593):         pattern, flags | p.pattern.flags, code,
sre_compile.py(594):         p.pattern.groups-1,
sre_compile.py(595):         groupindex, indexgroup
re.py(252):     if not bypass_cache:
re.py(253):         if len(_cache) >= _MAXCACHE:
re.py(255):         if p.flags & LOCALE:
re.py(260):             loc = None
re.py(261):         _cache[cachekey] = p, loc
re.py(262):     return p
phystokens.py(158): @contract(source='bytes')
 --- modulename: misc, funcname: contract
misc.py(61):         return lambda func: func
 --- modulename: misc, funcname: <lambda>
misc.py(61):         return lambda func: func
phystokens.py(253): @contract(source='bytes')
 --- modulename: misc, funcname: contract
misc.py(61):         return lambda func: func
 --- modulename: misc, funcname: <lambda>
misc.py(61):         return lambda func: func
phystokens.py(266): if env.PY3:
phystokens.py(269):     source_encoding = _source_encoding_py2
phystokens.py(272): @contract(source='unicode')
 --- modulename: misc, funcname: contract
misc.py(61):         return lambda func: func
 --- modulename: misc, funcname: <lambda>
misc.py(61):         return lambda func: func
phystokens.py(291): @contract(source='unicode', returns='unicode')
 --- modulename: misc, funcname: contract
misc.py(61):         return lambda func: func
 --- modulename: misc, funcname: <lambda>
misc.py(61):         return lambda func: func
parser.py(20): class PythonParser(object):
 --- modulename: parser, funcname: PythonParser
parser.py(20): class PythonParser(object):
parser.py(21):     """Parse code to find executable lines, excluded lines, etc."""
parser.py(23):     @contract(text='unicode|None')
 --- modulename: misc, funcname: contract
misc.py(61):         return lambda func: func
parser.py(24):     def __init__(self, text=None, filename=None, exclude=None):
 --- modulename: misc, funcname: <lambda>
misc.py(61):         return lambda func: func
parser.py(69):     @property
parser.py(76):     def lines_matching(self, *regexes):
parser.py(91):     def _raw_parse(self):
parser.py(167):     def first_line(self, line):
parser.py(175):     def first_lines(self, lines):
parser.py(184):     def translate_lines(self, lines):
parser.py(188):     def translate_arcs(self, arcs):
parser.py(195):     @expensive
 --- modulename: misc, funcname: expensive
misc.py(118):     if env.TESTING:
misc.py(129):         return fn
parser.py(229):     def arcs(self):
parser.py(245):     def exit_counts(self):
parser.py(276): def _opcode(name):
parser.py(281): def _opcode_set(*names):
parser.py(292): OPS_CODE_END = _opcode_set('RETURN_VALUE')
 --- modulename: parser, funcname: _opcode_set
parser.py(283):     s = set()
parser.py(284):     for name in names:
parser.py(285):         try:
parser.py(286):             s.add(_opcode(name))
 --- modulename: parser, funcname: _opcode
parser.py(278):     return dis.opmap[name]
parser.py(284):     for name in names:
parser.py(289):     return s
parser.py(295): OPS_CHUNK_END = _opcode_set(
parser.py(296):     'JUMP_ABSOLUTE', 'JUMP_FORWARD', 'RETURN_VALUE', 'RAISE_VARARGS',
parser.py(297):     'BREAK_LOOP', 'CONTINUE_LOOP',
 --- modulename: parser, funcname: _opcode_set
parser.py(283):     s = set()
parser.py(284):     for name in names:
parser.py(285):         try:
parser.py(286):             s.add(_opcode(name))
 --- modulename: parser, funcname: _opcode
parser.py(278):     return dis.opmap[name]
parser.py(284):     for name in names:
parser.py(285):         try:
parser.py(286):             s.add(_opcode(name))
 --- modulename: parser, funcname: _opcode
parser.py(278):     return dis.opmap[name]
parser.py(284):     for name in names:
parser.py(285):         try:
parser.py(286):             s.add(_opcode(name))
 --- modulename: parser, funcname: _opcode
parser.py(278):     return dis.opmap[name]
parser.py(284):     for name in names:
parser.py(285):         try:
parser.py(286):             s.add(_opcode(name))
 --- modulename: parser, funcname: _opcode
parser.py(278):     return dis.opmap[name]
parser.py(284):     for name in names:
parser.py(285):         try:
parser.py(286):             s.add(_opcode(name))
 --- modulename: parser, funcname: _opcode
parser.py(278):     return dis.opmap[name]
parser.py(284):     for name in names:
parser.py(285):         try:
parser.py(286):             s.add(_opcode(name))
 --- modulename: parser, funcname: _opcode
parser.py(278):     return dis.opmap[name]
parser.py(284):     for name in names:
parser.py(289):     return s
parser.py(303): OPS_CHUNK_BEGIN = _opcode_set('JUMP_ABSOLUTE', 'JUMP_FORWARD')
 --- modulename: parser, funcname: _opcode_set
parser.py(283):     s = set()
parser.py(284):     for name in names:
parser.py(285):         try:
parser.py(286):             s.add(_opcode(name))
 --- modulename: parser, funcname: _opcode
parser.py(278):     return dis.opmap[name]
parser.py(284):     for name in names:
parser.py(285):         try:
parser.py(286):             s.add(_opcode(name))
 --- modulename: parser, funcname: _opcode
parser.py(278):     return dis.opmap[name]
parser.py(284):     for name in names:
parser.py(289):     return s
parser.py(306): OPS_PUSH_BLOCK = _opcode_set(
parser.py(307):     'SETUP_LOOP', 'SETUP_EXCEPT', 'SETUP_FINALLY', 'SETUP_WITH'
 --- modulename: parser, funcname: _opcode_set
parser.py(283):     s = set()
parser.py(284):     for name in names:
parser.py(285):         try:
parser.py(286):             s.add(_opcode(name))
 --- modulename: parser, funcname: _opcode
parser.py(278):     return dis.opmap[name]
parser.py(284):     for name in names:
parser.py(285):         try:
parser.py(286):             s.add(_opcode(name))
 --- modulename: parser, funcname: _opcode
parser.py(278):     return dis.opmap[name]
parser.py(284):     for name in names:
parser.py(285):         try:
parser.py(286):             s.add(_opcode(name))
 --- modulename: parser, funcname: _opcode
parser.py(278):     return dis.opmap[name]
parser.py(284):     for name in names:
parser.py(285):         try:
parser.py(286):             s.add(_opcode(name))
 --- modulename: parser, funcname: _opcode
parser.py(278):     return dis.opmap[name]
parser.py(284):     for name in names:
parser.py(289):     return s
parser.py(311): OPS_EXCEPT_BLOCKS = _opcode_set('SETUP_EXCEPT', 'SETUP_FINALLY')
 --- modulename: parser, funcname: _opcode_set
parser.py(283):     s = set()
parser.py(284):     for name in names:
parser.py(285):         try:
parser.py(286):             s.add(_opcode(name))
 --- modulename: parser, funcname: _opcode
parser.py(278):     return dis.opmap[name]
parser.py(284):     for name in names:
parser.py(285):         try:
parser.py(286):             s.add(_opcode(name))
 --- modulename: parser, funcname: _opcode
parser.py(278):     return dis.opmap[name]
parser.py(284):     for name in names:
parser.py(289):     return s
parser.py(314): OPS_POP_BLOCK = _opcode_set('POP_BLOCK')
 --- modulename: parser, funcname: _opcode_set
parser.py(283):     s = set()
parser.py(284):     for name in names:
parser.py(285):         try:
parser.py(286):             s.add(_opcode(name))
 --- modulename: parser, funcname: _opcode
parser.py(278):     return dis.opmap[name]
parser.py(284):     for name in names:
parser.py(289):     return s
parser.py(317): OPS_NO_JUMP = OPS_PUSH_BLOCK
parser.py(320): OP_BREAK_LOOP = _opcode('BREAK_LOOP')
 --- modulename: parser, funcname: _opcode
parser.py(278):     return dis.opmap[name]
parser.py(321): OP_END_FINALLY = _opcode('END_FINALLY')
 --- modulename: parser, funcname: _opcode
parser.py(278):     return dis.opmap[name]
parser.py(322): OP_COMPARE_OP = _opcode('COMPARE_OP')
 --- modulename: parser, funcname: _opcode
parser.py(278):     return dis.opmap[name]
parser.py(323): COMPARE_EXCEPTION = 10  # just have to get this constant from the code.
parser.py(324): OP_LOAD_CONST = _opcode('LOAD_CONST')
 --- modulename: parser, funcname: _opcode
parser.py(278):     return dis.opmap[name]
parser.py(325): OP_RETURN_VALUE = _opcode('RETURN_VALUE')
 --- modulename: parser, funcname: _opcode
parser.py(278):     return dis.opmap[name]
parser.py(328): class ByteParser(object):
 --- modulename: parser, funcname: ByteParser
parser.py(328): class ByteParser(object):
parser.py(329):     """Parse byte codes to understand the structure of code."""
parser.py(331):     @contract(text='unicode')
 --- modulename: misc, funcname: contract
misc.py(61):         return lambda func: func
parser.py(332):     def __init__(self, text, code=None, filename=None):
 --- modulename: misc, funcname: <lambda>
misc.py(61):         return lambda func: func
parser.py(355):     def child_parsers(self):
parser.py(364):     def _bytes_lines(self):
parser.py(391):     def _find_statements(self):
parser.py(403):     def _block_stack_repr(self, block_stack):               # pragma: debugging
parser.py(410):     def _split_into_chunks(self):
parser.py(546):     def validate_chunks(self, chunks):                      # pragma: debugging
parser.py(553):     def _arcs(self):
parser.py(604):     def _all_chunks(self):
parser.py(616):     def _all_arcs(self):
parser.py(629): class Chunk(object):
 --- modulename: parser, funcname: Chunk
parser.py(629): class Chunk(object):
parser.py(654):     """
parser.py(655):     def __init__(self, byte, line, first):
parser.py(663):     def __repr__(self):
python.py(12): from coverage.phystokens import source_token_lines, source_encoding
python.py(13): from coverage.plugin import FileReporter
python.py(15): os = isolate_module(os)
 --- modulename: misc, funcname: isolate_module
misc.py(28):     if mod not in ISOLATED_MODULES:
misc.py(36):     return ISOLATED_MODULES[mod]
python.py(18): @contract(returns='bytes')
 --- modulename: misc, funcname: contract
misc.py(61):         return lambda func: func
 --- modulename: misc, funcname: <lambda>
misc.py(61):         return lambda func: func
python.py(29): @contract(returns='unicode')
 --- modulename: misc, funcname: contract
misc.py(61):         return lambda func: func
 --- modulename: misc, funcname: <lambda>
misc.py(61):         return lambda func: func
python.py(62): @contract(returns='bytes|None')
 --- modulename: misc, funcname: contract
misc.py(61):         return lambda func: func
 --- modulename: misc, funcname: <lambda>
misc.py(61):         return lambda func: func
python.py(87): class PythonFileReporter(FileReporter):
 --- modulename: python, funcname: PythonFileReporter
python.py(87): class PythonFileReporter(FileReporter):
python.py(88):     """Report support for a Python file."""
python.py(90):     def __init__(self, morf, coverage=None):
python.py(121):     @contract(returns='unicode')
 --- modulename: misc, funcname: contract
misc.py(61):         return lambda func: func
 --- modulename: misc, funcname: <lambda>
misc.py(61):         return lambda func: func
python.py(125):     @property
python.py(135):     @expensive
 --- modulename: misc, funcname: expensive
misc.py(118):     if env.TESTING:
misc.py(129):         return fn
python.py(142):     @expensive
 --- modulename: misc, funcname: expensive
misc.py(118):     if env.TESTING:
misc.py(129):         return fn
python.py(149):     def translate_lines(self, lines):
python.py(152):     def translate_arcs(self, arcs):
python.py(155):     @expensive
 --- modulename: misc, funcname: expensive
misc.py(118):     if env.TESTING:
misc.py(129):         return fn
python.py(163):     @expensive
 --- modulename: misc, funcname: expensive
misc.py(118):     if env.TESTING:
misc.py(129):         return fn
python.py(167):     @expensive
 --- modulename: misc, funcname: expensive
misc.py(118):     if env.TESTING:
misc.py(129):         return fn
python.py(171):     @contract(returns='unicode')
 --- modulename: misc, funcname: contract
misc.py(61):         return lambda func: func
 --- modulename: misc, funcname: <lambda>
misc.py(61):         return lambda func: func
python.py(177):     def should_be_python(self):
python.py(197):     def source_token_lines(self):
control.py(31): from coverage.results import Analysis, Numbers
control.py(32): from coverage.summary import SummaryReporter
 --- modulename: summary, funcname: <module>
summary.py(4): """Summary reporting"""
summary.py(6): import sys
summary.py(8): from coverage import env
summary.py(9): from coverage.report import Reporter
summary.py(10): from coverage.results import Numbers
summary.py(11): from coverage.misc import NotPython, CoverageException, output_encoding
summary.py(14): class SummaryReporter(Reporter):
 --- modulename: summary, funcname: SummaryReporter
summary.py(14): class SummaryReporter(Reporter):
summary.py(15):     """A reporter for writing the summary report."""
summary.py(17):     def __init__(self, coverage, config):
summary.py(21):     def report(self, morfs, outfile=None):
control.py(33): from coverage.xmlreport import XmlReporter
 --- modulename: xmlreport, funcname: <module>
xmlreport.py(4): """XML reporting for coverage.py"""
xmlreport.py(6): import os
xmlreport.py(7): import os.path
xmlreport.py(8): import sys
xmlreport.py(9): import time
xmlreport.py(10): import xml.dom.minidom
 --- modulename: __init__, funcname: <module>
__init__.py(17): """
__init__.py(20): __all__ = ["dom", "parsers", "sax", "etree"]
__init__.py(22): _MINIMUM_XMLPLUS_VERSION = (0, 8, 4)
__init__.py(25): try:
__init__.py(26):     import _xmlplus
__init__.py(27): except ImportError:
__init__.py(28):     pass
 --- modulename: __init__, funcname: <module>
__init__.py(15): """
__init__.py(18): class Node:
 --- modulename: __init__, funcname: Node
__init__.py(18): class Node:
__init__.py(19):     """Class giving the NodeType constants."""
__init__.py(28):     ELEMENT_NODE                = 1
__init__.py(29):     ATTRIBUTE_NODE              = 2
__init__.py(30):     TEXT_NODE                   = 3
__init__.py(31):     CDATA_SECTION_NODE          = 4
__init__.py(32):     ENTITY_REFERENCE_NODE       = 5
__init__.py(33):     ENTITY_NODE                 = 6
__init__.py(34):     PROCESSING_INSTRUCTION_NODE = 7
__init__.py(35):     COMMENT_NODE                = 8
__init__.py(36):     DOCUMENT_NODE               = 9
__init__.py(37):     DOCUMENT_TYPE_NODE          = 10
__init__.py(38):     DOCUMENT_FRAGMENT_NODE      = 11
__init__.py(39):     NOTATION_NODE               = 12
__init__.py(43): INDEX_SIZE_ERR                 = 1
__init__.py(44): DOMSTRING_SIZE_ERR             = 2
__init__.py(45): HIERARCHY_REQUEST_ERR          = 3
__init__.py(46): WRONG_DOCUMENT_ERR             = 4
__init__.py(47): INVALID_CHARACTER_ERR          = 5
__init__.py(48): NO_DATA_ALLOWED_ERR            = 6
__init__.py(49): NO_MODIFICATION_ALLOWED_ERR    = 7
__init__.py(50): NOT_FOUND_ERR                  = 8
__init__.py(51): NOT_SUPPORTED_ERR              = 9
__init__.py(52): INUSE_ATTRIBUTE_ERR            = 10
__init__.py(53): INVALID_STATE_ERR              = 11
__init__.py(54): SYNTAX_ERR                     = 12
__init__.py(55): INVALID_MODIFICATION_ERR       = 13
__init__.py(56): NAMESPACE_ERR                  = 14
__init__.py(57): INVALID_ACCESS_ERR             = 15
__init__.py(58): VALIDATION_ERR                 = 16
__init__.py(61): class DOMException(Exception):
 --- modulename: __init__, funcname: DOMException
__init__.py(61): class DOMException(Exception):
__init__.py(63):     Exceptions with specific codes are specializations of this class."""
__init__.py(65):     def __init__(self, *args, **kw):
__init__.py(71):     def _get_code(self):
__init__.py(75): class IndexSizeErr(DOMException):
 --- modulename: __init__, funcname: IndexSizeErr
__init__.py(75): class IndexSizeErr(DOMException):
__init__.py(76):     code = INDEX_SIZE_ERR
__init__.py(78): class DomstringSizeErr(DOMException):
 --- modulename: __init__, funcname: DomstringSizeErr
__init__.py(78): class DomstringSizeErr(DOMException):
__init__.py(79):     code = DOMSTRING_SIZE_ERR
__init__.py(81): class HierarchyRequestErr(DOMException):
 --- modulename: __init__, funcname: HierarchyRequestErr
__init__.py(81): class HierarchyRequestErr(DOMException):
__init__.py(82):     code = HIERARCHY_REQUEST_ERR
__init__.py(84): class WrongDocumentErr(DOMException):
 --- modulename: __init__, funcname: WrongDocumentErr
__init__.py(84): class WrongDocumentErr(DOMException):
__init__.py(85):     code = WRONG_DOCUMENT_ERR
__init__.py(87): class InvalidCharacterErr(DOMException):
 --- modulename: __init__, funcname: InvalidCharacterErr
__init__.py(87): class InvalidCharacterErr(DOMException):
__init__.py(88):     code = INVALID_CHARACTER_ERR
__init__.py(90): class NoDataAllowedErr(DOMException):
 --- modulename: __init__, funcname: NoDataAllowedErr
__init__.py(90): class NoDataAllowedErr(DOMException):
__init__.py(91):     code = NO_DATA_ALLOWED_ERR
__init__.py(93): class NoModificationAllowedErr(DOMException):
 --- modulename: __init__, funcname: NoModificationAllowedErr
__init__.py(93): class NoModificationAllowedErr(DOMException):
__init__.py(94):     code = NO_MODIFICATION_ALLOWED_ERR
__init__.py(96): class NotFoundErr(DOMException):
 --- modulename: __init__, funcname: NotFoundErr
__init__.py(96): class NotFoundErr(DOMException):
__init__.py(97):     code = NOT_FOUND_ERR
__init__.py(99): class NotSupportedErr(DOMException):
 --- modulename: __init__, funcname: NotSupportedErr
__init__.py(99): class NotSupportedErr(DOMException):
__init__.py(100):     code = NOT_SUPPORTED_ERR
__init__.py(102): class InuseAttributeErr(DOMException):
 --- modulename: __init__, funcname: InuseAttributeErr
__init__.py(102): class InuseAttributeErr(DOMException):
__init__.py(103):     code = INUSE_ATTRIBUTE_ERR
__init__.py(105): class InvalidStateErr(DOMException):
 --- modulename: __init__, funcname: InvalidStateErr
__init__.py(105): class InvalidStateErr(DOMException):
__init__.py(106):     code = INVALID_STATE_ERR
__init__.py(108): class SyntaxErr(DOMException):
 --- modulename: __init__, funcname: SyntaxErr
__init__.py(108): class SyntaxErr(DOMException):
__init__.py(109):     code = SYNTAX_ERR
__init__.py(111): class InvalidModificationErr(DOMException):
 --- modulename: __init__, funcname: InvalidModificationErr
__init__.py(111): class InvalidModificationErr(DOMException):
__init__.py(112):     code = INVALID_MODIFICATION_ERR
__init__.py(114): class NamespaceErr(DOMException):
 --- modulename: __init__, funcname: NamespaceErr
__init__.py(114): class NamespaceErr(DOMException):
__init__.py(115):     code = NAMESPACE_ERR
__init__.py(117): class InvalidAccessErr(DOMException):
 --- modulename: __init__, funcname: InvalidAccessErr
__init__.py(117): class InvalidAccessErr(DOMException):
__init__.py(118):     code = INVALID_ACCESS_ERR
__init__.py(120): class ValidationErr(DOMException):
 --- modulename: __init__, funcname: ValidationErr
__init__.py(120): class ValidationErr(DOMException):
__init__.py(121):     code = VALIDATION_ERR
__init__.py(123): class UserDataHandler:
 --- modulename: __init__, funcname: UserDataHandler
__init__.py(123): class UserDataHandler:
__init__.py(124):     """Class giving the operation constants for UserDataHandler.handle()."""
__init__.py(128):     NODE_CLONED   = 1
__init__.py(129):     NODE_IMPORTED = 2
__init__.py(130):     NODE_DELETED  = 3
__init__.py(131):     NODE_RENAMED  = 4
__init__.py(133): XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace"
__init__.py(134): XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/"
__init__.py(135): XHTML_NAMESPACE = "http://www.w3.org/1999/xhtml"
__init__.py(136): EMPTY_NAMESPACE = None
__init__.py(137): EMPTY_PREFIX = None
__init__.py(139): from domreg import getDOMImplementation,registerDOMImplementation
 --- modulename: domreg, funcname: <module>
domreg.py(3): registerDOMImplementation should be imported from xml.dom."""
domreg.py(5): from xml.dom.minicompat import *  # isinstance, StringTypes
 --- modulename: minicompat, funcname: <module>
minicompat.py(1): """Python version compatibility support for minidom."""
minicompat.py(39): __all__ = ["NodeList", "EmptyNodeList", "StringTypes", "defproperty"]
minicompat.py(41): import xml.dom
minicompat.py(43): try:
minicompat.py(44):     unicode
minicompat.py(48):     StringTypes = type(''), type(unicode(''))
minicompat.py(51): class NodeList(list):
 --- modulename: minicompat, funcname: NodeList
minicompat.py(51): class NodeList(list):
minicompat.py(52):     __slots__ = ()
minicompat.py(54):     def item(self, index):
minicompat.py(58):     def _get_length(self):
minicompat.py(61):     def _set_length(self, value):
minicompat.py(65):     length = property(_get_length, _set_length,
minicompat.py(66):                       doc="The number of nodes in the NodeList.")
minicompat.py(68):     def __getstate__(self):
minicompat.py(71):     def __setstate__(self, state):
minicompat.py(75): class EmptyNodeList(tuple):
 --- modulename: minicompat, funcname: EmptyNodeList
minicompat.py(75): class EmptyNodeList(tuple):
minicompat.py(76):     __slots__ = ()
minicompat.py(78):     def __add__(self, other):
minicompat.py(83):     def __radd__(self, other):
minicompat.py(88):     def item(self, index):
minicompat.py(91):     def _get_length(self):
minicompat.py(94):     def _set_length(self, value):
minicompat.py(98):     length = property(_get_length, _set_length,
minicompat.py(99):                       doc="The number of nodes in the NodeList.")
minicompat.py(102): def defproperty(klass, name, doc):
domreg.py(11): well_known_implementations = {
domreg.py(12):     'minidom':'xml.dom.minidom',
domreg.py(13):     '4DOM': 'xml.dom.DOMImplementation',
domreg.py(19): registered = {}
domreg.py(21): def registerDOMImplementation(name, factory):
domreg.py(32): def _good_enough(dom, features):
domreg.py(39): def getDOMImplementation(name = None, features = ()):
domreg.py(82): def _parse_feature_string(s):
 --- modulename: minidom, funcname: <module>
minidom.py(16): """
minidom.py(18): import xml.dom
minidom.py(20): from xml.dom import EMPTY_NAMESPACE, EMPTY_PREFIX, XMLNS_NAMESPACE, domreg
minidom.py(21): from xml.dom.minicompat import *
minidom.py(22): from xml.dom.xmlbuilder import DOMImplementationLS, DocumentLS
 --- modulename: xmlbuilder, funcname: <module>
xmlbuilder.py(1): """Implementation of the DOM Level 3 'LS-Load' feature."""
xmlbuilder.py(3): import copy
xmlbuilder.py(4): import xml.dom
xmlbuilder.py(6): from xml.dom.NodeFilter import NodeFilter
 --- modulename: NodeFilter, funcname: <module>
NodeFilter.py(4): class NodeFilter:
 --- modulename: NodeFilter, funcname: NodeFilter
NodeFilter.py(4): class NodeFilter:
NodeFilter.py(7):     """
NodeFilter.py(8):     FILTER_ACCEPT = 1
NodeFilter.py(9):     FILTER_REJECT = 2
NodeFilter.py(10):     FILTER_SKIP   = 3
NodeFilter.py(12):     SHOW_ALL                    = 0xFFFFFFFFL
NodeFilter.py(13):     SHOW_ELEMENT                = 0x00000001
NodeFilter.py(14):     SHOW_ATTRIBUTE              = 0x00000002
NodeFilter.py(15):     SHOW_TEXT                   = 0x00000004
NodeFilter.py(16):     SHOW_CDATA_SECTION          = 0x00000008
NodeFilter.py(17):     SHOW_ENTITY_REFERENCE       = 0x00000010
NodeFilter.py(18):     SHOW_ENTITY                 = 0x00000020
NodeFilter.py(19):     SHOW_PROCESSING_INSTRUCTION = 0x00000040
NodeFilter.py(20):     SHOW_COMMENT                = 0x00000080
NodeFilter.py(21):     SHOW_DOCUMENT               = 0x00000100
NodeFilter.py(22):     SHOW_DOCUMENT_TYPE          = 0x00000200
NodeFilter.py(23):     SHOW_DOCUMENT_FRAGMENT      = 0x00000400
NodeFilter.py(24):     SHOW_NOTATION               = 0x00000800
NodeFilter.py(26):     def acceptNode(self, node):
xmlbuilder.py(9): __all__ = ["DOMBuilder", "DOMEntityResolver", "DOMInputSource"]
xmlbuilder.py(12): class Options:
 --- modulename: xmlbuilder, funcname: Options
xmlbuilder.py(12): class Options:
xmlbuilder.py(17):     """
xmlbuilder.py(22):     namespaces = 1
xmlbuilder.py(23):     namespace_declarations = True
xmlbuilder.py(24):     validation = False
xmlbuilder.py(25):     external_parameter_entities = True
xmlbuilder.py(26):     external_general_entities = True
xmlbuilder.py(27):     external_dtd_subset = True
xmlbuilder.py(28):     validate_if_schema = False
xmlbuilder.py(29):     validate = False
xmlbuilder.py(30):     datatype_normalization = False
xmlbuilder.py(31):     create_entity_ref_nodes = True
xmlbuilder.py(32):     entities = True
xmlbuilder.py(33):     whitespace_in_element_content = True
xmlbuilder.py(34):     cdata_sections = True
xmlbuilder.py(35):     comments = True
xmlbuilder.py(36):     charset_overrides_xml_encoding = True
xmlbuilder.py(37):     infoset = False
xmlbuilder.py(38):     supported_mediatypes_only = False
xmlbuilder.py(40):     errorHandler = None
xmlbuilder.py(41):     filter = None
xmlbuilder.py(44): class DOMBuilder:
 --- modulename: xmlbuilder, funcname: DOMBuilder
xmlbuilder.py(44): class DOMBuilder:
xmlbuilder.py(45):     entityResolver = None
xmlbuilder.py(46):     errorHandler = None
xmlbuilder.py(47):     filter = None
xmlbuilder.py(49):     ACTION_REPLACE = 1
xmlbuilder.py(50):     ACTION_APPEND_AS_CHILDREN = 2
xmlbuilder.py(51):     ACTION_INSERT_AFTER = 3
xmlbuilder.py(52):     ACTION_INSERT_BEFORE = 4
xmlbuilder.py(54):     _legal_actions = (ACTION_REPLACE, ACTION_APPEND_AS_CHILDREN,
xmlbuilder.py(55):                       ACTION_INSERT_AFTER, ACTION_INSERT_BEFORE)
xmlbuilder.py(57):     def __init__(self):
xmlbuilder.py(60):     def _get_entityResolver(self):
xmlbuilder.py(62):     def _set_entityResolver(self, entityResolver):
xmlbuilder.py(65):     def _get_errorHandler(self):
xmlbuilder.py(67):     def _set_errorHandler(self, errorHandler):
xmlbuilder.py(70):     def _get_filter(self):
xmlbuilder.py(72):     def _set_filter(self, filter):
xmlbuilder.py(75):     def setFeature(self, name, state):
xmlbuilder.py(89):     def supportsFeature(self, name):
xmlbuilder.py(92):     def canSetFeature(self, name, state):
xmlbuilder.py(101):     _settings = {
xmlbuilder.py(103):             ("namespace_declarations", 0)],
xmlbuilder.py(105):             ("namespace_declarations", 1)],
xmlbuilder.py(107):             ("validation", 0)],
xmlbuilder.py(109):             ("external_general_entities", 0)],
xmlbuilder.py(111):             ("external_general_entities", 1)],
xmlbuilder.py(113):             ("external_parameter_entities", 0)],
xmlbuilder.py(115):             ("external_parameter_entities", 1)],
xmlbuilder.py(117):             ("validate_if_schema", 0)],
xmlbuilder.py(119):             ("create_entity_ref_nodes", 0)],
xmlbuilder.py(121):             ("create_entity_ref_nodes", 1)],
xmlbuilder.py(123):             ("create_entity_ref_nodes", 0),
xmlbuilder.py(124):             ("entities", 0)],
xmlbuilder.py(126):             ("entities", 1)],
xmlbuilder.py(128):             ("whitespace_in_element_content", 0)],
xmlbuilder.py(130):             ("whitespace_in_element_content", 1)],
xmlbuilder.py(132):             ("cdata_sections", 0)],
xmlbuilder.py(134):             ("cdata_sections", 1)],
xmlbuilder.py(136):             ("comments", 0)],
xmlbuilder.py(138):             ("comments", 1)],
xmlbuilder.py(140):             ("charset_overrides_xml_encoding", 0)],
xmlbuilder.py(142):             ("charset_overrides_xml_encoding", 1)],
xmlbuilder.py(143):         ("infoset", 0): [],
xmlbuilder.py(145):             ("namespace_declarations", 0),
xmlbuilder.py(146):             ("validate_if_schema", 0),
xmlbuilder.py(147):             ("create_entity_ref_nodes", 0),
xmlbuilder.py(148):             ("entities", 0),
xmlbuilder.py(149):             ("cdata_sections", 0),
xmlbuilder.py(150):             ("datatype_normalization", 1),
xmlbuilder.py(151):             ("whitespace_in_element_content", 1),
xmlbuilder.py(152):             ("comments", 1),
xmlbuilder.py(153):             ("charset_overrides_xml_encoding", 1)],
xmlbuilder.py(155):             ("supported_mediatypes_only", 0)],
xmlbuilder.py(157):             ("namespaces", 0)],
xmlbuilder.py(159):             ("namespaces", 1)],
xmlbuilder.py(162):     def getFeature(self, name):
xmlbuilder.py(180):     def parseURI(self, uri):
xmlbuilder.py(187):     def parse(self, input):
xmlbuilder.py(197):     def parseWithContext(self, input, cnode, action):
xmlbuilder.py(202):     def _parse_bytestream(self, stream, options):
xmlbuilder.py(208): def _name_xform(name):
xmlbuilder.py(212): class DOMEntityResolver(object):
 --- modulename: xmlbuilder, funcname: DOMEntityResolver
xmlbuilder.py(212): class DOMEntityResolver(object):
xmlbuilder.py(213):     __slots__ = '_opener',
xmlbuilder.py(215):     def resolveEntity(self, publicId, systemId):
xmlbuilder.py(237):     def _get_opener(self):
xmlbuilder.py(244):     def _create_opener(self):
xmlbuilder.py(248):     def _guess_media_encoding(self, source):
xmlbuilder.py(256): class DOMInputSource(object):
 --- modulename: xmlbuilder, funcname: DOMInputSource
xmlbuilder.py(256): class DOMInputSource(object):
xmlbuilder.py(258):                  'encoding', 'publicId', 'systemId', 'baseURI')
xmlbuilder.py(260):     def __init__(self):
xmlbuilder.py(269):     def _get_byteStream(self):
xmlbuilder.py(271):     def _set_byteStream(self, byteStream):
xmlbuilder.py(274):     def _get_characterStream(self):
xmlbuilder.py(276):     def _set_characterStream(self, characterStream):
xmlbuilder.py(279):     def _get_stringData(self):
xmlbuilder.py(281):     def _set_stringData(self, data):
xmlbuilder.py(284):     def _get_encoding(self):
xmlbuilder.py(286):     def _set_encoding(self, encoding):
xmlbuilder.py(289):     def _get_publicId(self):
xmlbuilder.py(291):     def _set_publicId(self, publicId):
xmlbuilder.py(294):     def _get_systemId(self):
xmlbuilder.py(296):     def _set_systemId(self, systemId):
xmlbuilder.py(299):     def _get_baseURI(self):
xmlbuilder.py(301):     def _set_baseURI(self, uri):
xmlbuilder.py(305): class DOMBuilderFilter:
 --- modulename: xmlbuilder, funcname: DOMBuilderFilter
xmlbuilder.py(305): class DOMBuilderFilter:
xmlbuilder.py(308):     """
xmlbuilder.py(315):     FILTER_ACCEPT = 1
xmlbuilder.py(316):     FILTER_REJECT = 2
xmlbuilder.py(317):     FILTER_SKIP = 3
xmlbuilder.py(318):     FILTER_INTERRUPT = 4
xmlbuilder.py(320):     whatToShow = NodeFilter.SHOW_ALL
xmlbuilder.py(322):     def _get_whatToShow(self):
xmlbuilder.py(325):     def acceptNode(self, element):
xmlbuilder.py(328):     def startContainer(self, element):
xmlbuilder.py(331): del NodeFilter
xmlbuilder.py(334): class DocumentLS:
 --- modulename: xmlbuilder, funcname: DocumentLS
xmlbuilder.py(334): class DocumentLS:
xmlbuilder.py(335):     """Mixin to create documents that conform to the load/save spec."""
xmlbuilder.py(337):     async = False
xmlbuilder.py(339):     def _get_async(self):
xmlbuilder.py(341):     def _set_async(self, async):
xmlbuilder.py(346):     def abort(self):
xmlbuilder.py(352):     def load(self, uri):
xmlbuilder.py(355):     def loadXML(self, source):
xmlbuilder.py(358):     def saveXML(self, snode):
xmlbuilder.py(366): class DOMImplementationLS:
 --- modulename: xmlbuilder, funcname: DOMImplementationLS
xmlbuilder.py(366): class DOMImplementationLS:
xmlbuilder.py(367):     MODE_SYNCHRONOUS = 1
xmlbuilder.py(368):     MODE_ASYNCHRONOUS = 2
xmlbuilder.py(370):     def createDOMBuilder(self, mode, schemaType):
xmlbuilder.py(381):     def createDOMWriter(self):
xmlbuilder.py(385):     def createDOMInputSource(self):
minidom.py(29): _nodeTypes_with_children = (xml.dom.Node.ELEMENT_NODE,
minidom.py(30):                             xml.dom.Node.ENTITY_REFERENCE_NODE)
minidom.py(33): class Node(xml.dom.Node):
 --- modulename: minidom, funcname: Node
minidom.py(33): class Node(xml.dom.Node):
minidom.py(34):     namespaceURI = None # this is non-null only for elements and attributes
minidom.py(35):     parentNode = None
minidom.py(36):     ownerDocument = None
minidom.py(37):     nextSibling = None
minidom.py(38):     previousSibling = None
minidom.py(40):     prefix = EMPTY_PREFIX # non-null only for NS elements and attributes
minidom.py(42):     def __nonzero__(self):
minidom.py(45):     def toxml(self, encoding = None):
minidom.py(48):     def toprettyxml(self, indent="\t", newl="\n", encoding = None):
minidom.py(63):     def hasChildNodes(self):
minidom.py(69):     def _get_childNodes(self):
minidom.py(72):     def _get_firstChild(self):
minidom.py(76):     def _get_lastChild(self):
minidom.py(80):     def insertBefore(self, newChild, refChild):
minidom.py(112):     def appendChild(self, node):
minidom.py(129):     def replaceChild(self, newChild, oldChild):
minidom.py(161):     def removeChild(self, oldChild):
minidom.py(177):     def normalize(self):
minidom.py(204):     def cloneNode(self, deep):
minidom.py(207):     def isSupported(self, feature, version):
minidom.py(210):     def _get_localName(self):
minidom.py(216):     def isSameNode(self, other):
minidom.py(219):     def getInterface(self, feature):
minidom.py(229):     def getUserData(self, key):
minidom.py(235):     def setUserData(self, key, data, handler):
minidom.py(253):     def _call_user_data_handler(self, operation, src, dst):
minidom.py(261):     def unlink(self):
minidom.py(270): defproperty(Node, "firstChild", doc="First child node, or None.")
 --- modulename: minicompat, funcname: defproperty
minicompat.py(103):     get = getattr(klass, ("_get_" + name)).im_func
minicompat.py(104):     def set(self, value, name=name):
minicompat.py(107):     assert not hasattr(klass, "_set_" + name), \
minicompat.py(109):     prop = property(get, set, doc=doc)
minicompat.py(110):     setattr(klass, name, prop)
minidom.py(271): defproperty(Node, "lastChild",  doc="Last child node, or None.")
 --- modulename: minicompat, funcname: defproperty
minicompat.py(103):     get = getattr(klass, ("_get_" + name)).im_func
minicompat.py(104):     def set(self, value, name=name):
minicompat.py(107):     assert not hasattr(klass, "_set_" + name), \
minicompat.py(109):     prop = property(get, set, doc=doc)
minicompat.py(110):     setattr(klass, name, prop)
minidom.py(272): defproperty(Node, "localName",  doc="Namespace-local name of this node.")
 --- modulename: minicompat, funcname: defproperty
minicompat.py(103):     get = getattr(klass, ("_get_" + name)).im_func
minicompat.py(104):     def set(self, value, name=name):
minicompat.py(107):     assert not hasattr(klass, "_set_" + name), \
minicompat.py(109):     prop = property(get, set, doc=doc)
minicompat.py(110):     setattr(klass, name, prop)
minidom.py(275): def _append_child(self, node):
minidom.py(285): def _in_document(node):
minidom.py(293): def _write_data(writer, data):
minidom.py(300): def _get_elements_by_tagName_helper(parent, name, rc):
minidom.py(308): def _get_elements_by_tagName_ns_helper(parent, nsURI, localName, rc):
minidom.py(317): class DocumentFragment(Node):
 --- modulename: minidom, funcname: DocumentFragment
minidom.py(317): class DocumentFragment(Node):
minidom.py(318):     nodeType = Node.DOCUMENT_FRAGMENT_NODE
minidom.py(319):     nodeName = "#document-fragment"
minidom.py(320):     nodeValue = None
minidom.py(321):     attributes = None
minidom.py(322):     parentNode = None
minidom.py(323):     _child_node_types = (Node.ELEMENT_NODE,
minidom.py(324):                          Node.TEXT_NODE,
minidom.py(325):                          Node.CDATA_SECTION_NODE,
minidom.py(326):                          Node.ENTITY_REFERENCE_NODE,
minidom.py(327):                          Node.PROCESSING_INSTRUCTION_NODE,
minidom.py(328):                          Node.COMMENT_NODE,
minidom.py(329):                          Node.NOTATION_NODE)
minidom.py(331):     def __init__(self):
minidom.py(335): class Attr(Node):
 --- modulename: minidom, funcname: Attr
minidom.py(335): class Attr(Node):
minidom.py(336):     nodeType = Node.ATTRIBUTE_NODE
minidom.py(337):     attributes = None
minidom.py(338):     ownerElement = None
minidom.py(339):     specified = False
minidom.py(340):     _is_id = False
minidom.py(342):     _child_node_types = (Node.TEXT_NODE, Node.ENTITY_REFERENCE_NODE)
minidom.py(344):     def __init__(self, qName, namespaceURI=EMPTY_NAMESPACE, localName=None,
minidom.py(345):                  prefix=None):
minidom.py(358):     def _get_localName(self):
minidom.py(361):     def _get_specified(self):
minidom.py(364):     def __setattr__(self, name, value):
minidom.py(379):     def _set_prefix(self, prefix):
minidom.py(395):     def _set_value(self, value):
minidom.py(402):     def unlink(self):
minidom.py(419):     def _get_isId(self):
minidom.py(435):     def _get_schemaType(self):
minidom.py(449): defproperty(Attr, "isId",       doc="True if this attribute is an ID.")
 --- modulename: minicompat, funcname: defproperty
minicompat.py(103):     get = getattr(klass, ("_get_" + name)).im_func
minicompat.py(104):     def set(self, value, name=name):
minicompat.py(107):     assert not hasattr(klass, "_set_" + name), \
minicompat.py(109):     prop = property(get, set, doc=doc)
minicompat.py(110):     setattr(klass, name, prop)
minidom.py(450): defproperty(Attr, "localName",  doc="Namespace-local name of this attribute.")
 --- modulename: minicompat, funcname: defproperty
minicompat.py(103):     get = getattr(klass, ("_get_" + name)).im_func
minicompat.py(104):     def set(self, value, name=name):
minicompat.py(107):     assert not hasattr(klass, "_set_" + name), \
minicompat.py(109):     prop = property(get, set, doc=doc)
minicompat.py(110):     setattr(klass, name, prop)
minidom.py(451): defproperty(Attr, "schemaType", doc="Schema type for this attribute.")
 --- modulename: minicompat, funcname: defproperty
minicompat.py(103):     get = getattr(klass, ("_get_" + name)).im_func
minicompat.py(104):     def set(self, value, name=name):
minicompat.py(107):     assert not hasattr(klass, "_set_" + name), \
minicompat.py(109):     prop = property(get, set, doc=doc)
minicompat.py(110):     setattr(klass, name, prop)
minidom.py(454): class NamedNodeMap(object):
 --- modulename: minidom, funcname: NamedNodeMap
minidom.py(454): class NamedNodeMap(object):
minidom.py(461):     """
minidom.py(463):     __slots__ = ('_attrs', '_attrsNS', '_ownerElement')
minidom.py(465):     def __init__(self, attrs, attrsNS, ownerElement):
minidom.py(470):     def _get_length(self):
minidom.py(473):     def item(self, index):
minidom.py(479):     def items(self):
minidom.py(485):     def itemsNS(self):
minidom.py(491):     def has_key(self, key):
minidom.py(497):     def keys(self):
minidom.py(500):     def keysNS(self):
minidom.py(503):     def values(self):
minidom.py(506):     def get(self, name, value=None):
minidom.py(509):     __len__ = _get_length
minidom.py(511):     __hash__ = None # Mutable type can't be correctly hashed
minidom.py(512):     def __cmp__(self, other):
minidom.py(518):     def __getitem__(self, attname_or_tuple):
minidom.py(525):     def __setitem__(self, attname, value):
minidom.py(540):     def getNamedItem(self, name):
minidom.py(546):     def getNamedItemNS(self, namespaceURI, localName):
minidom.py(552):     def removeNamedItem(self, name):
minidom.py(564):     def removeNamedItemNS(self, namespaceURI, localName):
minidom.py(576):     def setNamedItem(self, node):
minidom.py(589):     def setNamedItemNS(self, node):
minidom.py(592):     def __delitem__(self, attname_or_tuple):
minidom.py(597):     def __getstate__(self):
minidom.py(600):     def __setstate__(self, state):
minidom.py(603): defproperty(NamedNodeMap, "length",
minidom.py(604):             doc="Number of nodes in the NamedNodeMap.")
 --- modulename: minicompat, funcname: defproperty
minicompat.py(103):     get = getattr(klass, ("_get_" + name)).im_func
minicompat.py(104):     def set(self, value, name=name):
minicompat.py(107):     assert not hasattr(klass, "_set_" + name), \
minicompat.py(109):     prop = property(get, set, doc=doc)
minicompat.py(110):     setattr(klass, name, prop)
minidom.py(606): AttributeList = NamedNodeMap
minidom.py(609): class TypeInfo(object):
 --- modulename: minidom, funcname: TypeInfo
minidom.py(609): class TypeInfo(object):
minidom.py(610):     __slots__ = 'namespace', 'name'
minidom.py(612):     def __init__(self, namespace, name):
minidom.py(616):     def __repr__(self):
minidom.py(622):     def _get_name(self):
minidom.py(625):     def _get_namespace(self):
minidom.py(628): _no_type = TypeInfo(None, None)
 --- modulename: minidom, funcname: __init__
minidom.py(613):         self.namespace = namespace
minidom.py(614):         self.name = name
minidom.py(630): class Element(Node):
 --- modulename: minidom, funcname: Element
minidom.py(630): class Element(Node):
minidom.py(631):     nodeType = Node.ELEMENT_NODE
minidom.py(632):     nodeValue = None
minidom.py(633):     schemaType = _no_type
minidom.py(635):     _magic_id_nodes = 0
minidom.py(637):     _child_node_types = (Node.ELEMENT_NODE,
minidom.py(638):                          Node.PROCESSING_INSTRUCTION_NODE,
minidom.py(639):                          Node.COMMENT_NODE,
minidom.py(640):                          Node.TEXT_NODE,
minidom.py(641):                          Node.CDATA_SECTION_NODE,
minidom.py(642):                          Node.ENTITY_REFERENCE_NODE)
minidom.py(644):     def __init__(self, tagName, namespaceURI=EMPTY_NAMESPACE, prefix=None,
minidom.py(645):                  localName=None):
minidom.py(659):     def _get_localName(self):
minidom.py(662):     def _get_tagName(self):
minidom.py(665):     def unlink(self):
minidom.py(672):     def getAttribute(self, attname):
minidom.py(678):     def getAttributeNS(self, namespaceURI, localName):
minidom.py(684):     def setAttribute(self, attname, value):
minidom.py(699):     def setAttributeNS(self, namespaceURI, qualifiedName, value):
minidom.py(721):     def getAttributeNode(self, attrname):
minidom.py(724):     def getAttributeNodeNS(self, namespaceURI, localName):
minidom.py(727):     def setAttributeNode(self, attr):
minidom.py(745):     setAttributeNodeNS = setAttributeNode
minidom.py(747):     def removeAttribute(self, name):
minidom.py(754):     def removeAttributeNS(self, namespaceURI, localName):
minidom.py(761):     def removeAttributeNode(self, node):
minidom.py(774):     removeAttributeNodeNS = removeAttributeNode
minidom.py(776):     def hasAttribute(self, name):
minidom.py(779):     def hasAttributeNS(self, namespaceURI, localName):
minidom.py(782):     def getElementsByTagName(self, name):
minidom.py(785):     def getElementsByTagNameNS(self, namespaceURI, localName):
minidom.py(789):     def __repr__(self):
minidom.py(792):     def writexml(self, writer, indent="", addindent="", newl=""):
minidom.py(820):     def _get_attributes(self):
minidom.py(823):     def hasAttributes(self):
minidom.py(831):     def setIdAttribute(self, name):
minidom.py(835):     def setIdAttributeNS(self, namespaceURI, localName):
minidom.py(839):     def setIdAttributeNode(self, idAttr):
minidom.py(850): defproperty(Element, "attributes",
minidom.py(851):             doc="NamedNodeMap of attributes on the element.")
 --- modulename: minicompat, funcname: defproperty
minicompat.py(103):     get = getattr(klass, ("_get_" + name)).im_func
minicompat.py(104):     def set(self, value, name=name):
minicompat.py(107):     assert not hasattr(klass, "_set_" + name), \
minicompat.py(109):     prop = property(get, set, doc=doc)
minicompat.py(110):     setattr(klass, name, prop)
minidom.py(852): defproperty(Element, "localName",
minidom.py(853):             doc="Namespace-local name of this element.")
 --- modulename: minicompat, funcname: defproperty
minicompat.py(103):     get = getattr(klass, ("_get_" + name)).im_func
minicompat.py(104):     def set(self, value, name=name):
minicompat.py(107):     assert not hasattr(klass, "_set_" + name), \
minicompat.py(109):     prop = property(get, set, doc=doc)
minicompat.py(110):     setattr(klass, name, prop)
minidom.py(856): def _set_attribute_node(element, attr):
minidom.py(867): class Childless:
 --- modulename: minidom, funcname: Childless
minidom.py(867): class Childless:
minidom.py(870):     """
minidom.py(872):     attributes = None
minidom.py(873):     childNodes = EmptyNodeList()
minidom.py(874):     firstChild = None
minidom.py(875):     lastChild = None
minidom.py(877):     def _get_firstChild(self):
minidom.py(880):     def _get_lastChild(self):
minidom.py(883):     def appendChild(self, node):
minidom.py(887):     def hasChildNodes(self):
minidom.py(890):     def insertBefore(self, newChild, refChild):
minidom.py(894):     def removeChild(self, oldChild):
minidom.py(898):     def normalize(self):
minidom.py(902):     def replaceChild(self, newChild, oldChild):
minidom.py(907): class ProcessingInstruction(Childless, Node):
 --- modulename: minidom, funcname: ProcessingInstruction
minidom.py(907): class ProcessingInstruction(Childless, Node):
minidom.py(908):     nodeType = Node.PROCESSING_INSTRUCTION_NODE
minidom.py(910):     def __init__(self, target, data):
minidom.py(914):     def _get_data(self):
minidom.py(916):     def _set_data(self, value):
minidom.py(920):     def _get_target(self):
minidom.py(922):     def _set_target(self, value):
minidom.py(926):     def __setattr__(self, name, value):
minidom.py(934):     def writexml(self, writer, indent="", addindent="", newl=""):
minidom.py(938): class CharacterData(Childless, Node):
 --- modulename: minidom, funcname: CharacterData
minidom.py(938): class CharacterData(Childless, Node):
minidom.py(939):     def _get_length(self):
minidom.py(941):     __len__ = _get_length
minidom.py(943):     def _get_data(self):
minidom.py(945):     def _set_data(self, data):
minidom.py(949):     _get_nodeValue = _get_data
minidom.py(950):     _set_nodeValue = _set_data
minidom.py(952):     def __setattr__(self, name, value):
minidom.py(958):     def __repr__(self):
minidom.py(967):     def substringData(self, offset, count):
minidom.py(976):     def appendData(self, arg):
minidom.py(979):     def insertData(self, offset, arg):
minidom.py(988):     def deleteData(self, offset, count):
minidom.py(998):     def replaceData(self, offset, count, arg):
minidom.py(1009): defproperty(CharacterData, "length", doc="Length of the string data.")
 --- modulename: minicompat, funcname: defproperty
minicompat.py(103):     get = getattr(klass, ("_get_" + name)).im_func
minicompat.py(104):     def set(self, value, name=name):
minicompat.py(107):     assert not hasattr(klass, "_set_" + name), \
minicompat.py(109):     prop = property(get, set, doc=doc)
minicompat.py(110):     setattr(klass, name, prop)
minidom.py(1012): class Text(CharacterData):
 --- modulename: minidom, funcname: Text
minidom.py(1012): class Text(CharacterData):
minidom.py(1018):     nodeType = Node.TEXT_NODE
minidom.py(1019):     nodeName = "#text"
minidom.py(1020):     attributes = None
minidom.py(1022):     def splitText(self, offset):
minidom.py(1037):     def writexml(self, writer, indent="", addindent="", newl=""):
minidom.py(1042):     def _get_wholeText(self):
minidom.py(1060):     def replaceWholeText(self, content):
minidom.py(1090):     def _get_isWhitespaceInElementContent(self):
minidom.py(1102): defproperty(Text, "isWhitespaceInElementContent",
minidom.py(1103):             doc="True iff this text node contains only whitespace"
 --- modulename: minicompat, funcname: defproperty
minicompat.py(103):     get = getattr(klass, ("_get_" + name)).im_func
minicompat.py(104):     def set(self, value, name=name):
minicompat.py(107):     assert not hasattr(klass, "_set_" + name), \
minicompat.py(109):     prop = property(get, set, doc=doc)
minicompat.py(110):     setattr(klass, name, prop)
minidom.py(1105): defproperty(Text, "wholeText",
minidom.py(1106):             doc="The text of all logically-adjacent text nodes.")
 --- modulename: minicompat, funcname: defproperty
minicompat.py(103):     get = getattr(klass, ("_get_" + name)).im_func
minicompat.py(104):     def set(self, value, name=name):
minicompat.py(107):     assert not hasattr(klass, "_set_" + name), \
minicompat.py(109):     prop = property(get, set, doc=doc)
minicompat.py(110):     setattr(klass, name, prop)
minidom.py(1109): def _get_containing_element(node):
minidom.py(1117): def _get_containing_entref(node):
minidom.py(1126): class Comment(Childless, CharacterData):
 --- modulename: minidom, funcname: Comment
minidom.py(1126): class Comment(Childless, CharacterData):
minidom.py(1127):     nodeType = Node.COMMENT_NODE
minidom.py(1128):     nodeName = "#comment"
minidom.py(1130):     def __init__(self, data):
minidom.py(1133):     def writexml(self, writer, indent="", addindent="", newl=""):
minidom.py(1139): class CDATASection(Text):
 --- modulename: minidom, funcname: CDATASection
minidom.py(1139): class CDATASection(Text):
minidom.py(1145):     nodeType = Node.CDATA_SECTION_NODE
minidom.py(1146):     nodeName = "#cdata-section"
minidom.py(1148):     def writexml(self, writer, indent="", addindent="", newl=""):
minidom.py(1154): class ReadOnlySequentialNamedNodeMap(object):
 --- modulename: minidom, funcname: ReadOnlySequentialNamedNodeMap
minidom.py(1154): class ReadOnlySequentialNamedNodeMap(object):
minidom.py(1155):     __slots__ = '_seq',
minidom.py(1157):     def __init__(self, seq=()):
minidom.py(1161):     def __len__(self):
minidom.py(1164):     def _get_length(self):
minidom.py(1167):     def getNamedItem(self, name):
minidom.py(1172):     def getNamedItemNS(self, namespaceURI, localName):
minidom.py(1177):     def __getitem__(self, name_or_tuple):
minidom.py(1186):     def item(self, index):
minidom.py(1194):     def removeNamedItem(self, name):
minidom.py(1198):     def removeNamedItemNS(self, namespaceURI, localName):
minidom.py(1202):     def setNamedItem(self, node):
minidom.py(1206):     def setNamedItemNS(self, node):
minidom.py(1210):     def __getstate__(self):
minidom.py(1213):     def __setstate__(self, state):
minidom.py(1216): defproperty(ReadOnlySequentialNamedNodeMap, "length",
minidom.py(1217):             doc="Number of entries in the NamedNodeMap.")
 --- modulename: minicompat, funcname: defproperty
minicompat.py(103):     get = getattr(klass, ("_get_" + name)).im_func
minicompat.py(104):     def set(self, value, name=name):
minicompat.py(107):     assert not hasattr(klass, "_set_" + name), \
minicompat.py(109):     prop = property(get, set, doc=doc)
minicompat.py(110):     setattr(klass, name, prop)
minidom.py(1220): class Identified:
 --- modulename: minidom, funcname: Identified
minidom.py(1220): class Identified:
minidom.py(1221):     """Mix-in class that supports the publicId and systemId attributes."""
minidom.py(1226):     def _identified_mixin_init(self, publicId, systemId):
minidom.py(1230):     def _get_publicId(self):
minidom.py(1233):     def _get_systemId(self):
minidom.py(1236): class DocumentType(Identified, Childless, Node):
 --- modulename: minidom, funcname: DocumentType
minidom.py(1236): class DocumentType(Identified, Childless, Node):
minidom.py(1237):     nodeType = Node.DOCUMENT_TYPE_NODE
minidom.py(1238):     nodeValue = None
minidom.py(1239):     name = None
minidom.py(1240):     publicId = None
minidom.py(1241):     systemId = None
minidom.py(1242):     internalSubset = None
minidom.py(1244):     def __init__(self, qualifiedName):
minidom.py(1252):     def _get_internalSubset(self):
minidom.py(1255):     def cloneNode(self, deep):
minidom.py(1282):     def writexml(self, writer, indent="", addindent="", newl=""):
minidom.py(1296): class Entity(Identified, Node):
 --- modulename: minidom, funcname: Entity
minidom.py(1296): class Entity(Identified, Node):
minidom.py(1297):     attributes = None
minidom.py(1298):     nodeType = Node.ENTITY_NODE
minidom.py(1299):     nodeValue = None
minidom.py(1301):     actualEncoding = None
minidom.py(1302):     encoding = None
minidom.py(1303):     version = None
minidom.py(1305):     def __init__(self, name, publicId, systemId, notation):
minidom.py(1311):     def _get_actualEncoding(self):
minidom.py(1314):     def _get_encoding(self):
minidom.py(1317):     def _get_version(self):
minidom.py(1320):     def appendChild(self, newChild):
minidom.py(1324):     def insertBefore(self, newChild, refChild):
minidom.py(1328):     def removeChild(self, oldChild):
minidom.py(1332):     def replaceChild(self, newChild, oldChild):
minidom.py(1336): class Notation(Identified, Childless, Node):
 --- modulename: minidom, funcname: Notation
minidom.py(1336): class Notation(Identified, Childless, Node):
minidom.py(1337):     nodeType = Node.NOTATION_NODE
minidom.py(1338):     nodeValue = None
minidom.py(1340):     def __init__(self, name, publicId, systemId):
minidom.py(1345): class DOMImplementation(DOMImplementationLS):
 --- modulename: minidom, funcname: DOMImplementation
minidom.py(1345): class DOMImplementation(DOMImplementationLS):
minidom.py(1346):     _features = [("core", "1.0"),
minidom.py(1347):                  ("core", "2.0"),
minidom.py(1348):                  ("core", None),
minidom.py(1349):                  ("xml", "1.0"),
minidom.py(1350):                  ("xml", "2.0"),
minidom.py(1351):                  ("xml", None),
minidom.py(1352):                  ("ls-load", "3.0"),
minidom.py(1353):                  ("ls-load", None),
minidom.py(1356):     def hasFeature(self, feature, version):
minidom.py(1361):     def createDocument(self, namespaceURI, qualifiedName, doctype):
minidom.py(1406):     def createDocumentType(self, qualifiedName, publicId, systemId):
minidom.py(1414):     def getInterface(self, feature):
minidom.py(1421):     def _create_document(self):
minidom.py(1424): class ElementInfo(object):
 --- modulename: minidom, funcname: ElementInfo
minidom.py(1424): class ElementInfo(object):
minidom.py(1431):     """
minidom.py(1433):     __slots__ = 'tagName',
minidom.py(1435):     def __init__(self, name):
minidom.py(1438):     def getAttributeType(self, aname):
minidom.py(1441):     def getAttributeTypeNS(self, namespaceURI, localName):
minidom.py(1444):     def isElementContent(self):
minidom.py(1447):     def isEmpty(self):
minidom.py(1452):     def isId(self, aname):
minidom.py(1456):     def isIdNS(self, namespaceURI, localName):
minidom.py(1460):     def __getstate__(self):
minidom.py(1463):     def __setstate__(self, state):
minidom.py(1466): def _clear_id_cache(node):
minidom.py(1474): class Document(Node, DocumentLS):
 --- modulename: minidom, funcname: Document
minidom.py(1474): class Document(Node, DocumentLS):
minidom.py(1475):     _child_node_types = (Node.ELEMENT_NODE, Node.PROCESSING_INSTRUCTION_NODE,
minidom.py(1476):                          Node.COMMENT_NODE, Node.DOCUMENT_TYPE_NODE)
minidom.py(1478):     nodeType = Node.DOCUMENT_NODE
minidom.py(1479):     nodeName = "#document"
minidom.py(1480):     nodeValue = None
minidom.py(1481):     attributes = None
minidom.py(1482):     doctype = None
minidom.py(1483):     parentNode = None
minidom.py(1484):     previousSibling = nextSibling = None
minidom.py(1486):     implementation = DOMImplementation()
minidom.py(1490):     actualEncoding = None
minidom.py(1491):     encoding = None
minidom.py(1492):     standalone = None
minidom.py(1493):     version = None
minidom.py(1494):     strictErrorChecking = False
minidom.py(1495):     errorHandler = None
minidom.py(1496):     documentURI = None
minidom.py(1498):     _magic_id_count = 0
minidom.py(1500):     def __init__(self):
minidom.py(1508):     def _get_elem_info(self, element):
minidom.py(1515):     def _get_actualEncoding(self):
minidom.py(1518):     def _get_doctype(self):
minidom.py(1521):     def _get_documentURI(self):
minidom.py(1524):     def _get_encoding(self):
minidom.py(1527):     def _get_errorHandler(self):
minidom.py(1530):     def _get_standalone(self):
minidom.py(1533):     def _get_strictErrorChecking(self):
minidom.py(1536):     def _get_version(self):
minidom.py(1539):     def appendChild(self, node):
minidom.py(1555):     def removeChild(self, oldChild):
minidom.py(1567):     def _get_documentElement(self):
minidom.py(1572):     def unlink(self):
minidom.py(1578):     def cloneNode(self, deep):
minidom.py(1599):     def createDocumentFragment(self):
minidom.py(1604):     def createElement(self, tagName):
minidom.py(1609):     def createTextNode(self, data):
minidom.py(1617):     def createCDATASection(self, data):
minidom.py(1625):     def createComment(self, data):
minidom.py(1630):     def createProcessingInstruction(self, target, data):
minidom.py(1635):     def createAttribute(self, qName):
minidom.py(1641):     def createElementNS(self, namespaceURI, qualifiedName):
minidom.py(1647):     def createAttributeNS(self, namespaceURI, qualifiedName):
minidom.py(1657):     def _create_entity(self, name, publicId, systemId, notationName):
minidom.py(1662):     def _create_notation(self, name, publicId, systemId):
minidom.py(1667):     def getElementById(self, id):
minidom.py(1725):     def getElementsByTagName(self, name):
minidom.py(1728):     def getElementsByTagNameNS(self, namespaceURI, localName):
minidom.py(1732):     def isSupported(self, feature, version):
minidom.py(1735):     def importNode(self, node, deep):
minidom.py(1742):     def writexml(self, writer, indent="", addindent="", newl="",
minidom.py(1743):                  encoding = None):
minidom.py(1753):     def renameNode(self, n, namespaceURI, name):
minidom.py(1808): defproperty(Document, "documentElement",
minidom.py(1809):             doc="Top-level element of this document.")
 --- modulename: minicompat, funcname: defproperty
minicompat.py(103):     get = getattr(klass, ("_get_" + name)).im_func
minicompat.py(104):     def set(self, value, name=name):
minicompat.py(107):     assert not hasattr(klass, "_set_" + name), \
minicompat.py(109):     prop = property(get, set, doc=doc)
minicompat.py(110):     setattr(klass, name, prop)
minidom.py(1812): def _clone_node(node, deep, newOwnerDocument):
minidom.py(1894): def _nssplit(qualifiedName):
minidom.py(1902): def _get_StringIO():
minidom.py(1907): def _do_pulldom_parse(func, args, kwargs):
minidom.py(1914): def parse(file, parser=None, bufsize=None):
minidom.py(1924): def parseString(string, parser=None):
minidom.py(1934): def getDOMImplementation(features=None):
xmlreport.py(12): from coverage import env
xmlreport.py(13): from coverage import __url__, __version__, files
xmlreport.py(14): from coverage.misc import isolate_module
xmlreport.py(15): from coverage.report import Reporter
xmlreport.py(17): os = isolate_module(os)
 --- modulename: misc, funcname: isolate_module
misc.py(28):     if mod not in ISOLATED_MODULES:
misc.py(36):     return ISOLATED_MODULES[mod]
xmlreport.py(21):     'https://raw.githubusercontent.com/cobertura/web/'
xmlreport.py(27): def rate(hit, num):
xmlreport.py(35): class XmlReporter(Reporter):
 --- modulename: xmlreport, funcname: XmlReporter
xmlreport.py(35): class XmlReporter(Reporter):
xmlreport.py(36):     """A reporter for writing Cobertura-style XML coverage results."""
xmlreport.py(38):     def __init__(self, coverage, config):
xmlreport.py(50):     def report(self, morfs, outfile=None):
xmlreport.py(138):     def xml_file(self, fr, analysis):
control.py(35): os = isolate_module(os)
 --- modulename: misc, funcname: isolate_module
misc.py(28):     if mod not in ISOLATED_MODULES:
misc.py(36):     return ISOLATED_MODULES[mod]
control.py(39): try:
control.py(40):     import _structseq
control.py(41): except ImportError:
control.py(42):     _structseq = None
control.py(45): class Coverage(object):
 --- modulename: control, funcname: Coverage
control.py(45): class Coverage(object):
control.py(58):     """
control.py(60):         self, data_file=None, data_suffix=None, cover_pylib=None,
control.py(61):         auto_data=False, timid=None, branch=None, config_file=True,
control.py(62):         source=None, omit=None, include=None, debug=None,
control.py(63):         concurrency=None,
control.py(195):     def _init(self):
control.py(358):     def _canonical_dir(self, morf):
control.py(363):     def _source_for_file(self, filename):
control.py(395):     def _name_for_module(self, module_globals, filename):
control.py(431):     def _should_trace_internal(self, filename, frame):
control.py(539):     def _check_include_omit_etc_internal(self, filename, frame):
control.py(581):     def _should_trace(self, filename, frame):
control.py(592):     def _check_include_omit_etc(self, filename, frame):
control.py(608):     def _warn(self, msg):
control.py(615):     def get_option(self, option_name):
control.py(629):     def set_option(self, option_name, value):
control.py(654):     def use_cache(self, usecache):
control.py(660):     def load(self):
control.py(666):     def start(self):
control.py(689):     def stop(self):
control.py(695):     def _atexit(self):
control.py(702):     def erase(self):
control.py(714):     def clear_exclude(self, which='exclude'):
control.py(720):     def exclude(self, regex, which='exclude'):
control.py(740):     def _exclude_regex_stale(self):
control.py(744):     def _exclude_regex(self, which):
control.py(751):     def get_exclude_list(self, which='exclude'):
control.py(761):     def save(self):
control.py(767):     def combine(self, data_paths=None):
control.py(796):     def get_data(self):
control.py(849):     def analysis(self, morf):
control.py(854):     def analysis2(self, morf):
control.py(881):     def _analyze(self, it):
control.py(893):     def _get_file_reporter(self, morf):
control.py(918):     def _get_file_reporters(self, morfs=None):
control.py(944):         self, morfs=None, show_missing=True, ignore_errors=None,
control.py(945):         file=None,                  # pylint: disable=redefined-builtin
control.py(946):         omit=None, include=None, skip_covered=False,
control.py(969):         self, morfs=None, directory=None, ignore_errors=None,
control.py(970):         omit=None, include=None,
control.py(989):     def html_report(self, morfs=None, directory=None, ignore_errors=None,
control.py(990):                     omit=None, include=None, extra_css=None, title=None):
control.py(1017):         self, morfs=None, outfile=None, ignore_errors=None,
control.py(1018):         omit=None, include=None,
control.py(1067):     def sys_info(self):
control.py(1126): def _disposition_init(cls, original_filename):
control.py(1139): def _disposition_debug_msg(disp):
control.py(1150): def process_startup():
__init__.py(14): from coverage.data import CoverageData
__init__.py(15): from coverage.misc import CoverageException
__init__.py(16): from coverage.plugin import CoveragePlugin, FileTracer, FileReporter
__init__.py(19): coverage = Coverage
__init__.py(24): import encodings.utf_8
__init__.py(30): import sys
__init__.py(31): try:
__init__.py(32):     del sys.modules['coverage.coverage']
test_draw_failing.py(6): cov = coverage.Coverage()
 --- modulename: control, funcname: __init__
control.py(122):         self.config = CoverageConfig()
 --- modulename: config, funcname: __init__
config.py(152):         self.attempted_config_files = []
config.py(153):         self.config_files = []
config.py(156):         self.branch = False
config.py(157):         self.concurrency = None
config.py(158):         self.cover_pylib = False
config.py(159):         self.data_file = ".coverage"
config.py(160):         self.debug = []
config.py(161):         self.note = None
config.py(162):         self.parallel = False
config.py(163):         self.plugins = []
config.py(164):         self.source = None
config.py(165):         self.timid = False
config.py(168):         self.exclude_list = DEFAULT_EXCLUDE[:]
config.py(169):         self.fail_under = 0
config.py(170):         self.ignore_errors = False
config.py(171):         self.include = None
config.py(172):         self.omit = None
config.py(173):         self.partial_always_list = DEFAULT_PARTIAL_ALWAYS[:]
config.py(174):         self.partial_list = DEFAULT_PARTIAL[:]
config.py(175):         self.precision = 0
config.py(176):         self.show_missing = False
config.py(177):         self.skip_covered = False
config.py(180):         self.extra_css = None
config.py(181):         self.html_dir = "htmlcov"
config.py(182):         self.html_title = "Coverage report"
config.py(185):         self.xml_output = "coverage.xml"
config.py(186):         self.xml_package_depth = 99
config.py(189):         self.paths = {}
config.py(192):         self.plugin_options = {}
control.py(125):         if config_file:
control.py(126):             did_read_rc = False
control.py(129):             if config_file == ".coveragerc":
control.py(131):             specified_file = (config_file is not True)
control.py(132):             if not specified_file:
control.py(133):                 config_file = ".coveragerc"
control.py(135):             did_read_rc = self.config.from_file(config_file)
 --- modulename: config, funcname: from_file
config.py(212):         self.attempted_config_files.append(filename)
config.py(214):         cp = HandyConfigParser(section_prefix)
 --- modulename: config, funcname: __init__
config.py(21):         configparser.RawConfigParser.__init__(self)
 --- modulename: ConfigParser, funcname: __init__
ConfigParser.py(234):         self._dict = dict_type
ConfigParser.py(235):         self._sections = self._dict()
 --- modulename: collections, funcname: __init__
collections.py(44):         if not args:
collections.py(47):         self = args[0]
collections.py(48):         args = args[1:]
collections.py(49):         if len(args) > 1:
collections.py(51):         try:
collections.py(52):             self.__root
collections.py(53):         except AttributeError:
collections.py(54):             self.__root = root = []                     # sentinel node
collections.py(55):             root[:] = [root, root, None]
collections.py(56):             self.__map = {}
collections.py(57):         self.__update(*args, **kwds)
 --- modulename: abc, funcname: __subclasscheck__
abc.py(151):         if subclass in cls._abc_cache:
 --- modulename: _weakrefset, funcname: __contains__
_weakrefset.py(71):         try:
_weakrefset.py(72):             wr = ref(item)
_weakrefset.py(75):         return wr in self.data
abc.py(154):         if cls._abc_negative_cache_version < ABCMeta._abc_invalidation_counter:
abc.py(156):             cls._abc_negative_cache = WeakSet()
 --- modulename: _weakrefset, funcname: __init__
_weakrefset.py(37):         self.data = set()
_weakrefset.py(38):         def _remove(item, selfref=ref(self)):
_weakrefset.py(45):         self._remove = _remove
_weakrefset.py(47):         self._pending_removals = []
_weakrefset.py(48):         self._iterating = set()
_weakrefset.py(49):         if data is not None:
abc.py(157):             cls._abc_negative_cache_version = ABCMeta._abc_invalidation_counter
abc.py(161):         ok = cls.__subclasshook__(subclass)
 --- modulename: _abcoll, funcname: __subclasshook__
_abcoll.py(100):         if cls is Sized:
_abcoll.py(103):         return NotImplemented
abc.py(162):         if ok is not NotImplemented:
abc.py(170):         if cls in getattr(subclass, '__mro__', ()):
abc.py(174):         for rcls in cls._abc_registry:
 --- modulename: _weakrefset, funcname: __iter__
_weakrefset.py(59):         with _IterationGuard(self):
 --- modulename: _weakrefset, funcname: __init__
_weakrefset.py(18):         self.weakcontainer = ref(weakcontainer)
 --- modulename: _weakrefset, funcname: __enter__
_weakrefset.py(21):         w = self.weakcontainer()
_weakrefset.py(22):         if w is not None:
_weakrefset.py(23):             w._iterating.add(self)
_weakrefset.py(24):         return self
_weakrefset.py(60):             for itemref in self.data:
_weakrefset.py(61):                 item = itemref()
_weakrefset.py(62):                 if item is not None:
_weakrefset.py(65):                     yield item
abc.py(175):             if issubclass(subclass, rcls):
abc.py(174):         for rcls in cls._abc_registry:
 --- modulename: _weakrefset, funcname: __iter__
_weakrefset.py(60):             for itemref in self.data:
_weakrefset.py(61):                 item = itemref()
_weakrefset.py(62):                 if item is not None:
_weakrefset.py(65):                     yield item
abc.py(175):             if issubclass(subclass, rcls):
abc.py(176):                 cls._abc_cache.add(subclass)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(84):         if self._pending_removals:
_weakrefset.py(86):         self.data.add(ref(item, self._remove))
abc.py(177):                 return True
 --- modulename: _weakrefset, funcname: __iter__
 --- modulename: _weakrefset, funcname: __exit__
_weakrefset.py(27):         w = self.weakcontainer()
_weakrefset.py(28):         if w is not None:
_weakrefset.py(29):             s = w._iterating
_weakrefset.py(30):             s.remove(self)
_weakrefset.py(31):             if not s:
_weakrefset.py(32):                 w._commit_removals()
 --- modulename: _weakrefset, funcname: _commit_removals
_weakrefset.py(53):         l = self._pending_removals
_weakrefset.py(54):         discard = self.data.discard
_weakrefset.py(55):         while l:
 --- modulename: _abcoll, funcname: update
_abcoll.py(554):         if not args:
_abcoll.py(557):         self = args[0]
_abcoll.py(558):         args = args[1:]
_abcoll.py(559):         if len(args) > 1:
_abcoll.py(562):         if args:
_abcoll.py(573):         for key, value in kwds.items():
ConfigParser.py(236):         self._defaults = self._dict()
 --- modulename: collections, funcname: __init__
collections.py(44):         if not args:
collections.py(47):         self = args[0]
collections.py(48):         args = args[1:]
collections.py(49):         if len(args) > 1:
collections.py(51):         try:
collections.py(52):             self.__root
collections.py(53):         except AttributeError:
collections.py(54):             self.__root = root = []                     # sentinel node
collections.py(55):             root[:] = [root, root, None]
collections.py(56):             self.__map = {}
collections.py(57):         self.__update(*args, **kwds)
 --- modulename: abc, funcname: __subclasscheck__
abc.py(151):         if subclass in cls._abc_cache:
 --- modulename: _weakrefset, funcname: __contains__
_weakrefset.py(71):         try:
_weakrefset.py(72):             wr = ref(item)
_weakrefset.py(75):         return wr in self.data
abc.py(152):             return True
 --- modulename: _abcoll, funcname: update
_abcoll.py(554):         if not args:
_abcoll.py(557):         self = args[0]
_abcoll.py(558):         args = args[1:]
_abcoll.py(559):         if len(args) > 1:
_abcoll.py(562):         if args:
_abcoll.py(573):         for key, value in kwds.items():
ConfigParser.py(237):         if allow_no_value:
ConfigParser.py(240):             self._optcre = self.OPTCRE
ConfigParser.py(241):         if defaults:
config.py(22):         self.section_prefix = section_prefix
config.py(215):         try:
config.py(216):             files_read = cp.read(filename)
 --- modulename: config, funcname: read
config.py(26):         kwargs = {}
config.py(27):         if sys.version_info >= (3, 2):
config.py(29):         return configparser.RawConfigParser.read(self, filename, **kwargs)
 --- modulename: ConfigParser, funcname: read
ConfigParser.py(297):         if isinstance(filenames, basestring):
ConfigParser.py(298):             filenames = [filenames]
ConfigParser.py(299):         read_ok = []
ConfigParser.py(300):         for filename in filenames:
ConfigParser.py(301):             try:
ConfigParser.py(302):                 fp = open(filename)
ConfigParser.py(303):             except IOError:
ConfigParser.py(304):                 continue
ConfigParser.py(300):         for filename in filenames:
ConfigParser.py(308):         return read_ok
config.py(219):         if not files_read:
config.py(220):             return False
control.py(137):             if not did_read_rc:
control.py(138):                 if specified_file:
control.py(142):                 self.config.from_file("setup.cfg", section_prefix="coverage:")
 --- modulename: config, funcname: from_file
config.py(212):         self.attempted_config_files.append(filename)
config.py(214):         cp = HandyConfigParser(section_prefix)
 --- modulename: config, funcname: __init__
config.py(21):         configparser.RawConfigParser.__init__(self)
 --- modulename: ConfigParser, funcname: __init__
ConfigParser.py(234):         self._dict = dict_type
ConfigParser.py(235):         self._sections = self._dict()
 --- modulename: collections, funcname: __init__
collections.py(44):         if not args:
collections.py(47):         self = args[0]
collections.py(48):         args = args[1:]
collections.py(49):         if len(args) > 1:
collections.py(51):         try:
collections.py(52):             self.__root
collections.py(53):         except AttributeError:
collections.py(54):             self.__root = root = []                     # sentinel node
collections.py(55):             root[:] = [root, root, None]
collections.py(56):             self.__map = {}
collections.py(57):         self.__update(*args, **kwds)
 --- modulename: abc, funcname: __subclasscheck__
abc.py(151):         if subclass in cls._abc_cache:
 --- modulename: _weakrefset, funcname: __contains__
_weakrefset.py(71):         try:
_weakrefset.py(72):             wr = ref(item)
_weakrefset.py(75):         return wr in self.data
abc.py(152):             return True
 --- modulename: _abcoll, funcname: update
_abcoll.py(554):         if not args:
_abcoll.py(557):         self = args[0]
_abcoll.py(558):         args = args[1:]
_abcoll.py(559):         if len(args) > 1:
_abcoll.py(562):         if args:
_abcoll.py(573):         for key, value in kwds.items():
ConfigParser.py(236):         self._defaults = self._dict()
 --- modulename: collections, funcname: __init__
collections.py(44):         if not args:
collections.py(47):         self = args[0]
collections.py(48):         args = args[1:]
collections.py(49):         if len(args) > 1:
collections.py(51):         try:
collections.py(52):             self.__root
collections.py(53):         except AttributeError:
collections.py(54):             self.__root = root = []                     # sentinel node
collections.py(55):             root[:] = [root, root, None]
collections.py(56):             self.__map = {}
collections.py(57):         self.__update(*args, **kwds)
 --- modulename: abc, funcname: __subclasscheck__
abc.py(151):         if subclass in cls._abc_cache:
 --- modulename: _weakrefset, funcname: __contains__
_weakrefset.py(71):         try:
_weakrefset.py(72):             wr = ref(item)
_weakrefset.py(75):         return wr in self.data
abc.py(152):             return True
 --- modulename: _abcoll, funcname: update
_abcoll.py(554):         if not args:
_abcoll.py(557):         self = args[0]
_abcoll.py(558):         args = args[1:]
_abcoll.py(559):         if len(args) > 1:
_abcoll.py(562):         if args:
_abcoll.py(573):         for key, value in kwds.items():
ConfigParser.py(237):         if allow_no_value:
ConfigParser.py(240):             self._optcre = self.OPTCRE
ConfigParser.py(241):         if defaults:
config.py(22):         self.section_prefix = section_prefix
config.py(215):         try:
config.py(216):             files_read = cp.read(filename)
 --- modulename: config, funcname: read
config.py(26):         kwargs = {}
config.py(27):         if sys.version_info >= (3, 2):
config.py(29):         return configparser.RawConfigParser.read(self, filename, **kwargs)
 --- modulename: ConfigParser, funcname: read
ConfigParser.py(297):         if isinstance(filenames, basestring):
ConfigParser.py(298):             filenames = [filenames]
ConfigParser.py(299):         read_ok = []
ConfigParser.py(300):         for filename in filenames:
ConfigParser.py(301):             try:
ConfigParser.py(302):                 fp = open(filename)
ConfigParser.py(303):             except IOError:
ConfigParser.py(304):                 continue
ConfigParser.py(300):         for filename in filenames:
ConfigParser.py(308):         return read_ok
config.py(219):         if not files_read:
config.py(220):             return False
control.py(145):         env_data_file = os.environ.get('COVERAGE_FILE')
 --- modulename: UserDict, funcname: get
UserDict.py(92):         if key not in self:
 --- modulename: UserDict, funcname: __contains__
UserDict.py(104):         return key in self.data
UserDict.py(93):             return failobj
control.py(146):         if env_data_file:
control.py(148):         debugs = os.environ.get('COVERAGE_DEBUG')
 --- modulename: UserDict, funcname: get
UserDict.py(92):         if key not in self:
 --- modulename: UserDict, funcname: __contains__
UserDict.py(104):         return key in self.data
UserDict.py(93):             return failobj
control.py(149):         if debugs:
control.py(153):         self.config.from_args(
control.py(154):             data_file=data_file, cover_pylib=cover_pylib, timid=timid,
control.py(155):             branch=branch, parallel=bool_or_none(data_suffix),
 --- modulename: misc, funcname: bool_or_none
misc.py(134):     if b is None:
misc.py(135):         return None
control.py(156):             source=source, omit=omit, include=include, debug=debug,
control.py(157):             concurrency=concurrency,
 --- modulename: config, funcname: from_args
config.py(198):         for k, v in iitems(kwargs):
 --- modulename: backward, funcname: iitems
backward.py(71):         return d.iteritems()
config.py(199):             if v is not None:
config.py(198):         for k, v in iitems(kwargs):
config.py(199):             if v is not None:
config.py(198):         for k, v in iitems(kwargs):
config.py(199):             if v is not None:
config.py(198):         for k, v in iitems(kwargs):
config.py(199):             if v is not None:
config.py(198):         for k, v in iitems(kwargs):
config.py(199):             if v is not None:
config.py(198):         for k, v in iitems(kwargs):
config.py(199):             if v is not None:
config.py(198):         for k, v in iitems(kwargs):
config.py(199):             if v is not None:
config.py(198):         for k, v in iitems(kwargs):
config.py(199):             if v is not None:
config.py(198):         for k, v in iitems(kwargs):
config.py(199):             if v is not None:
config.py(198):         for k, v in iitems(kwargs):
config.py(199):             if v is not None:
config.py(198):         for k, v in iitems(kwargs):
control.py(160):         self._debug_file = None
control.py(161):         self._auto_data = auto_data
control.py(162):         self._data_suffix = data_suffix
control.py(165):         self.source_match = None
control.py(166):         self.source_pkgs_match = None
control.py(167):         self.pylib_match = self.cover_match = None
control.py(168):         self.include_match = self.omit_match = None
control.py(171):         self._warn_no_data = True
control.py(172):         self._warn_unimported_source = True
control.py(175):         self._warnings = []
control.py(178):         self.omit = self.include = self.source = None
control.py(179):         self.source_pkgs = None
control.py(180):         self.data = self.data_files = self.collector = None
control.py(181):         self.plugins = None
control.py(182):         self.pylib_dirs = self.cover_dirs = None
control.py(183):         self.data_suffix = self.run_suffix = None
control.py(184):         self._exclude_re = None
control.py(185):         self.debug = None
control.py(189):         self._inited = False
control.py(191):         self._started = False
control.py(193):         self._measured = False
test_draw_failing.py(7): cov.start()
 --- modulename: control, funcname: start
control.py(677):         self._init()
 --- modulename: control, funcname: _init
control.py(203):         if self._inited:
control.py(209):         if self._debug_file is None:
control.py(210):             debug_file_name = os.environ.get("COVERAGE_DEBUG_FILE")
 --- modulename: UserDict, funcname: get
UserDict.py(92):         if key not in self:
 --- modulename: UserDict, funcname: __contains__
UserDict.py(104):         return key in self.data
UserDict.py(93):             return failobj
control.py(211):             if debug_file_name:
control.py(214):                 self._debug_file = sys.stderr
control.py(215):         self.debug = DebugControl(self.config.debug, self._debug_file)
 --- modulename: debug, funcname: __init__
debug.py(29):         self.options = options
debug.py(30):         self.output = output
control.py(218):         self.plugins = Plugins.load_plugins(self.config.plugins, self.config, self.debug)
 --- modulename: plugin_support, funcname: load_plugins
plugin_support.py(34):         plugins = cls()
 --- modulename: plugin_support, funcname: __init__
plugin_support.py(20):         self.order = []
plugin_support.py(21):         self.names = {}
plugin_support.py(22):         self.file_tracers = []
plugin_support.py(24):         self.current_module = None
plugin_support.py(25):         self.debug = None
plugin_support.py(35):         plugins.debug = debug
plugin_support.py(37):         for module in modules:
plugin_support.py(51):         plugins.current_module = None
plugin_support.py(52):         return plugins
control.py(222):         self._exclude_re = {}
control.py(223):         self._exclude_regex_stale()
 --- modulename: control, funcname: _exclude_regex_stale
control.py(742):         self._exclude_re.clear()
control.py(225):         files.set_relative_directory()
 --- modulename: files, funcname: set_relative_directory
files.py(27):     RELATIVE_DIR = os.path.normcase(abs_file(os.curdir) + os.sep)
 --- modulename: files, funcname: abs_file
files.py(149):     path = os.path.expandvars(os.path.expanduser(filename))
 --- modulename: posixpath, funcname: expanduser
posixpath.py(254):     if not path.startswith('~'):
posixpath.py(255):         return path
 --- modulename: posixpath, funcname: expandvars
posixpath.py(287):     if '$' not in path:
posixpath.py(288):         return path
files.py(150):     path = os.path.abspath(os.path.realpath(path))
 --- modulename: posixpath, funcname: realpath
posixpath.py(375):     path, ok = _joinrealpath('', filename, {})
 --- modulename: posixpath, funcname: _joinrealpath
posixpath.py(381):     if isabs(rest):
 --- modulename: posixpath, funcname: isabs
posixpath.py(54):     return s.startswith('/')
posixpath.py(385):     while rest:
posixpath.py(386):         name, _, rest = rest.partition(sep)
posixpath.py(387):         if not name or name == curdir:
posixpath.py(389):             continue
posixpath.py(385):     while rest:
posixpath.py(419):     return path, True
posixpath.py(376):     return abspath(path)
 --- modulename: posixpath, funcname: abspath
posixpath.py(360):     if not isabs(path):
 --- modulename: posixpath, funcname: isabs
posixpath.py(54):     return s.startswith('/')
posixpath.py(361):         if isinstance(path, _unicode):
posixpath.py(364):             cwd = os.getcwd()
posixpath.py(365):         path = join(cwd, path)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
posixpath.py(366):     return normpath(path)
 --- modulename: posixpath, funcname: normpath
posixpath.py(332):     slash, dot = (u'/', u'.') if isinstance(path, _unicode) else ('/', '.')
posixpath.py(333):     if path == '':
posixpath.py(335):     initial_slashes = path.startswith('/')
posixpath.py(338):     if (initial_slashes and
posixpath.py(339):         path.startswith('//') and not path.startswith('///')):
posixpath.py(341):     comps = path.split('/')
posixpath.py(342):     new_comps = []
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(345):             continue
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(345):             continue
posixpath.py(343):     for comp in comps:
posixpath.py(351):     comps = new_comps
posixpath.py(352):     path = slash.join(comps)
posixpath.py(353):     if initial_slashes:
posixpath.py(354):         path = slash*initial_slashes + path
posixpath.py(355):     return path or dot
 --- modulename: posixpath, funcname: abspath
posixpath.py(360):     if not isabs(path):
 --- modulename: posixpath, funcname: isabs
posixpath.py(54):     return s.startswith('/')
posixpath.py(366):     return normpath(path)
 --- modulename: posixpath, funcname: normpath
posixpath.py(332):     slash, dot = (u'/', u'.') if isinstance(path, _unicode) else ('/', '.')
posixpath.py(333):     if path == '':
posixpath.py(335):     initial_slashes = path.startswith('/')
posixpath.py(338):     if (initial_slashes and
posixpath.py(339):         path.startswith('//') and not path.startswith('///')):
posixpath.py(341):     comps = path.split('/')
posixpath.py(342):     new_comps = []
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(345):             continue
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(351):     comps = new_comps
posixpath.py(352):     path = slash.join(comps)
posixpath.py(353):     if initial_slashes:
posixpath.py(354):         path = slash*initial_slashes + path
posixpath.py(355):     return path or dot
files.py(151):     path = actual_path(path)
 --- modulename: files, funcname: actual_path
files.py(128):         return filename
files.py(152):     path = unicode_filename(path)
 --- modulename: files, funcname: unicode_filename
files.py(135):         if isinstance(filename, str):
files.py(136):             encoding = sys.getfilesystemencoding() or sys.getdefaultencoding()
files.py(137):             filename = filename.decode(encoding, "replace")
 --- modulename: utf_8, funcname: decode
utf_8.py(16):     return codecs.utf_8_decode(input, errors, True)
files.py(138):         return filename
files.py(153):     return path
 --- modulename: posixpath, funcname: normcase
posixpath.py(46):     return s
files.py(31):     CANONICAL_FILENAME_CACHE = {}
control.py(228):         self.source = []
control.py(229):         self.source_pkgs = []
control.py(230):         for src in self.config.source or []:
control.py(236):         self.omit = prep_patterns(self.config.omit)
 --- modulename: files, funcname: prep_patterns
files.py(176):     prepped = []
files.py(177):     for p in patterns or []:
files.py(182):     return prepped
control.py(237):         self.include = prep_patterns(self.config.include)
 --- modulename: files, funcname: prep_patterns
files.py(176):     prepped = []
files.py(177):     for p in patterns or []:
files.py(182):     return prepped
control.py(239):         concurrency = self.config.concurrency
control.py(240):         if concurrency == "multiprocessing":
control.py(244):         self.collector = Collector(
control.py(245):             should_trace=self._should_trace,
control.py(246):             check_include=self._check_include_omit_etc,
control.py(247):             timid=self.config.timid,
control.py(248):             branch=self.config.branch,
control.py(249):             warn=self._warn,
control.py(250):             concurrency=concurrency,
 --- modulename: collector, funcname: __init__
collector.py(87):         self.should_trace = should_trace
collector.py(88):         self.check_include = check_include
collector.py(89):         self.warn = warn
collector.py(90):         self.branch = branch
collector.py(91):         self.threading = None
collector.py(92):         self.concurrency = concurrency
collector.py(94):         self.concur_id_func = None
collector.py(96):         try:
collector.py(97):             if concurrency == "greenlet":
collector.py(100):             elif concurrency == "eventlet":
collector.py(103):             elif concurrency == "gevent":
collector.py(106):             elif concurrency == "thread" or not concurrency:
collector.py(110):                 import threading
collector.py(111):                 self.threading = threading
collector.py(119):         self.reset()
 --- modulename: collector, funcname: reset
collector.py(148):         self.data = {}
collector.py(152):         self.file_tracers = {}
collector.py(162):         if env.PYPY:
collector.py(180):             self.should_trace_cache = {}
collector.py(183):         self.tracers = []
collector.py(121):         if timid:
collector.py(127):             self._trace_class = CTracer or PyTracer
collector.py(129):         if self._trace_class is CTracer:
collector.py(130):             self.file_disposition_class = CFileDisposition
collector.py(131):             self.supports_plugins = True
control.py(254):         if self.plugins.file_tracers and not self.collector.supports_plugins:
control.py(271):         if self._data_suffix or self.config.parallel:
control.py(276):             self._data_suffix = None
control.py(277):         self.data_suffix = None
control.py(278):         self.run_suffix = self._data_suffix
control.py(283):         self.data = CoverageData(debug=self.debug)
 --- modulename: data, funcname: __init__
data.py(120):         self._debug = debug
data.py(128):         self._lines = None
data.py(135):         self._arcs = None
data.py(141):         self._file_tracers = {}
data.py(144):         self._runs = []
control.py(284):         self.data_files = CoverageDataFiles(basename=self.config.data_file, warn=self._warn)
 --- modulename: data, funcname: __init__
data.py(614):         self.warn = warn
data.py(616):         self.filename = os.path.abspath(basename or ".coverage")
 --- modulename: posixpath, funcname: abspath
posixpath.py(360):     if not isabs(path):
 --- modulename: posixpath, funcname: isabs
posixpath.py(54):     return s.startswith('/')
posixpath.py(361):         if isinstance(path, _unicode):
posixpath.py(364):             cwd = os.getcwd()
posixpath.py(365):         path = join(cwd, path)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
posixpath.py(366):     return normpath(path)
 --- modulename: posixpath, funcname: normpath
posixpath.py(332):     slash, dot = (u'/', u'.') if isinstance(path, _unicode) else ('/', '.')
posixpath.py(333):     if path == '':
posixpath.py(335):     initial_slashes = path.startswith('/')
posixpath.py(338):     if (initial_slashes and
posixpath.py(339):         path.startswith('//') and not path.startswith('///')):
posixpath.py(341):     comps = path.split('/')
posixpath.py(342):     new_comps = []
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(345):             continue
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(351):     comps = new_comps
posixpath.py(352):     path = slash.join(comps)
posixpath.py(353):     if initial_slashes:
posixpath.py(354):         path = slash*initial_slashes + path
posixpath.py(355):     return path or dot
control.py(287):         self.pylib_dirs = set()
control.py(288):         if not self.config.cover_pylib:
control.py(294):             for m in (atexit, inspect, os, platform, re, _structseq, traceback):
control.py(295):                 if m is not None and hasattr(m, "__file__"):
control.py(296):                     self.pylib_dirs.add(self._canonical_dir(m))
 --- modulename: control, funcname: _canonical_dir
control.py(360):         morf_filename = PythonFileReporter(morf, self).filename
 --- modulename: python, funcname: __init__
python.py(91):         self.coverage = coverage
python.py(93):         if hasattr(morf, '__file__'):
python.py(94):             filename = morf.__file__
python.py(98):         filename = files.unicode_filename(filename)
 --- modulename: files, funcname: unicode_filename
files.py(135):         if isinstance(filename, str):
files.py(136):             encoding = sys.getfilesystemencoding() or sys.getdefaultencoding()
files.py(137):             filename = filename.decode(encoding, "replace")
 --- modulename: utf_8, funcname: decode
utf_8.py(16):     return codecs.utf_8_decode(input, errors, True)
files.py(138):         return filename
python.py(101):         if filename.endswith(('.pyc', '.pyo')):
python.py(102):             filename = filename[:-1]
python.py(106):         super(PythonFileReporter, self).__init__(files.canonical_filename(filename))
 --- modulename: files, funcname: canonical_filename
files.py(60):     if filename not in CANONICAL_FILENAME_CACHE:
files.py(61):         if not os.path.isabs(filename):
 --- modulename: posixpath, funcname: isabs
posixpath.py(54):     return s.startswith('/')
files.py(69):         cf = abs_file(filename)
 --- modulename: files, funcname: abs_file
files.py(149):     path = os.path.expandvars(os.path.expanduser(filename))
 --- modulename: posixpath, funcname: expanduser
posixpath.py(254):     if not path.startswith('~'):
posixpath.py(255):         return path
 --- modulename: posixpath, funcname: expandvars
posixpath.py(287):     if '$' not in path:
posixpath.py(288):         return path
files.py(150):     path = os.path.abspath(os.path.realpath(path))
 --- modulename: posixpath, funcname: realpath
posixpath.py(375):     path, ok = _joinrealpath('', filename, {})
 --- modulename: posixpath, funcname: _joinrealpath
posixpath.py(381):     if isabs(rest):
 --- modulename: posixpath, funcname: isabs
posixpath.py(54):     return s.startswith('/')
posixpath.py(382):         rest = rest[1:]
posixpath.py(383):         path = sep
posixpath.py(385):     while rest:
posixpath.py(386):         name, _, rest = rest.partition(sep)
posixpath.py(387):         if not name or name == curdir:
posixpath.py(390):         if name == pardir:
posixpath.py(399):         newpath = join(path, name)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(71):             path +=  b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
posixpath.py(400):         if not islink(newpath):
 --- modulename: posixpath, funcname: islink
posixpath.py(134):     try:
posixpath.py(135):         st = os.lstat(path)
posixpath.py(138):     return stat.S_ISLNK(st.st_mode)
 --- modulename: stat, funcname: S_ISLNK
stat.py(56):     return S_IFMT(mode) == S_IFLNK
 --- modulename: stat, funcname: S_IFMT
stat.py(25):     return mode & 0170000
posixpath.py(401):             path = newpath
posixpath.py(402):             continue
posixpath.py(385):     while rest:
posixpath.py(386):         name, _, rest = rest.partition(sep)
posixpath.py(387):         if not name or name == curdir:
posixpath.py(390):         if name == pardir:
posixpath.py(399):         newpath = join(path, name)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
posixpath.py(400):         if not islink(newpath):
 --- modulename: posixpath, funcname: islink
posixpath.py(134):     try:
posixpath.py(135):         st = os.lstat(path)
posixpath.py(138):     return stat.S_ISLNK(st.st_mode)
 --- modulename: stat, funcname: S_ISLNK
stat.py(56):     return S_IFMT(mode) == S_IFLNK
 --- modulename: stat, funcname: S_IFMT
stat.py(25):     return mode & 0170000
posixpath.py(401):             path = newpath
posixpath.py(402):             continue
posixpath.py(385):     while rest:
posixpath.py(386):         name, _, rest = rest.partition(sep)
posixpath.py(387):         if not name or name == curdir:
posixpath.py(390):         if name == pardir:
posixpath.py(399):         newpath = join(path, name)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
posixpath.py(400):         if not islink(newpath):
 --- modulename: posixpath, funcname: islink
posixpath.py(134):     try:
posixpath.py(135):         st = os.lstat(path)
posixpath.py(138):     return stat.S_ISLNK(st.st_mode)
 --- modulename: stat, funcname: S_ISLNK
stat.py(56):     return S_IFMT(mode) == S_IFLNK
 --- modulename: stat, funcname: S_IFMT
stat.py(25):     return mode & 0170000
posixpath.py(401):             path = newpath
posixpath.py(402):             continue
posixpath.py(385):     while rest:
posixpath.py(386):         name, _, rest = rest.partition(sep)
posixpath.py(387):         if not name or name == curdir:
posixpath.py(390):         if name == pardir:
posixpath.py(399):         newpath = join(path, name)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
posixpath.py(400):         if not islink(newpath):
 --- modulename: posixpath, funcname: islink
posixpath.py(134):     try:
posixpath.py(135):         st = os.lstat(path)
posixpath.py(138):     return stat.S_ISLNK(st.st_mode)
 --- modulename: stat, funcname: S_ISLNK
stat.py(56):     return S_IFMT(mode) == S_IFLNK
 --- modulename: stat, funcname: S_IFMT
stat.py(25):     return mode & 0170000
posixpath.py(401):             path = newpath
posixpath.py(402):             continue
posixpath.py(385):     while rest:
posixpath.py(419):     return path, True
posixpath.py(376):     return abspath(path)
 --- modulename: posixpath, funcname: abspath
posixpath.py(360):     if not isabs(path):
 --- modulename: posixpath, funcname: isabs
posixpath.py(54):     return s.startswith('/')
posixpath.py(366):     return normpath(path)
 --- modulename: posixpath, funcname: normpath
posixpath.py(332):     slash, dot = (u'/', u'.') if isinstance(path, _unicode) else ('/', '.')
posixpath.py(333):     if path == '':
posixpath.py(335):     initial_slashes = path.startswith('/')
posixpath.py(338):     if (initial_slashes and
posixpath.py(339):         path.startswith('//') and not path.startswith('///')):
posixpath.py(341):     comps = path.split('/')
posixpath.py(342):     new_comps = []
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(345):             continue
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(351):     comps = new_comps
posixpath.py(352):     path = slash.join(comps)
posixpath.py(353):     if initial_slashes:
posixpath.py(354):         path = slash*initial_slashes + path
posixpath.py(355):     return path or dot
 --- modulename: posixpath, funcname: abspath
posixpath.py(360):     if not isabs(path):
 --- modulename: posixpath, funcname: isabs
posixpath.py(54):     return s.startswith('/')
posixpath.py(366):     return normpath(path)
 --- modulename: posixpath, funcname: normpath
posixpath.py(332):     slash, dot = (u'/', u'.') if isinstance(path, _unicode) else ('/', '.')
posixpath.py(333):     if path == '':
posixpath.py(335):     initial_slashes = path.startswith('/')
posixpath.py(338):     if (initial_slashes and
posixpath.py(339):         path.startswith('//') and not path.startswith('///')):
posixpath.py(341):     comps = path.split('/')
posixpath.py(342):     new_comps = []
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(345):             continue
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(351):     comps = new_comps
posixpath.py(352):     path = slash.join(comps)
posixpath.py(353):     if initial_slashes:
posixpath.py(354):         path = slash*initial_slashes + path
posixpath.py(355):     return path or dot
files.py(151):     path = actual_path(path)
 --- modulename: files, funcname: actual_path
files.py(128):         return filename
files.py(152):     path = unicode_filename(path)
 --- modulename: files, funcname: unicode_filename
files.py(135):         if isinstance(filename, str):
files.py(138):         return filename
files.py(153):     return path
files.py(70):         CANONICAL_FILENAME_CACHE[filename] = cf
files.py(71):     return CANONICAL_FILENAME_CACHE[filename]
 --- modulename: plugin, funcname: __init__
plugin.py(205):         self.filename = filename
python.py(108):         if hasattr(morf, '__name__'):
python.py(109):             name = morf.__name__
python.py(110):             name = name.replace(".", os.sep) + ".py"
python.py(111):             name = files.unicode_filename(name)
 --- modulename: files, funcname: unicode_filename
files.py(135):         if isinstance(filename, str):
files.py(136):             encoding = sys.getfilesystemencoding() or sys.getdefaultencoding()
files.py(137):             filename = filename.decode(encoding, "replace")
 --- modulename: utf_8, funcname: decode
utf_8.py(16):     return codecs.utf_8_decode(input, errors, True)
files.py(138):         return filename
python.py(114):         self.relname = name
python.py(116):         self._source = None
python.py(117):         self._parser = None
python.py(118):         self._statements = None
python.py(119):         self._excluded = None
control.py(361):         return os.path.split(morf_filename)[0]
 --- modulename: posixpath, funcname: split
posixpath.py(85):     i = p.rfind('/') + 1
posixpath.py(86):     head, tail = p[:i], p[i:]
posixpath.py(87):     if head and head != '/'*len(head):
posixpath.py(88):         head = head.rstrip('/')
posixpath.py(89):     return head, tail
control.py(294):             for m in (atexit, inspect, os, platform, re, _structseq, traceback):
control.py(295):                 if m is not None and hasattr(m, "__file__"):
control.py(296):                     self.pylib_dirs.add(self._canonical_dir(m))
 --- modulename: control, funcname: _canonical_dir
control.py(360):         morf_filename = PythonFileReporter(morf, self).filename
 --- modulename: python, funcname: __init__
python.py(91):         self.coverage = coverage
python.py(93):         if hasattr(morf, '__file__'):
python.py(94):             filename = morf.__file__
python.py(98):         filename = files.unicode_filename(filename)
 --- modulename: files, funcname: unicode_filename
files.py(135):         if isinstance(filename, str):
files.py(136):             encoding = sys.getfilesystemencoding() or sys.getdefaultencoding()
files.py(137):             filename = filename.decode(encoding, "replace")
 --- modulename: utf_8, funcname: decode
utf_8.py(16):     return codecs.utf_8_decode(input, errors, True)
files.py(138):         return filename
python.py(101):         if filename.endswith(('.pyc', '.pyo')):
python.py(102):             filename = filename[:-1]
python.py(106):         super(PythonFileReporter, self).__init__(files.canonical_filename(filename))
 --- modulename: files, funcname: canonical_filename
files.py(60):     if filename not in CANONICAL_FILENAME_CACHE:
files.py(61):         if not os.path.isabs(filename):
 --- modulename: posixpath, funcname: isabs
posixpath.py(54):     return s.startswith('/')
files.py(69):         cf = abs_file(filename)
 --- modulename: files, funcname: abs_file
files.py(149):     path = os.path.expandvars(os.path.expanduser(filename))
 --- modulename: posixpath, funcname: expanduser
posixpath.py(254):     if not path.startswith('~'):
posixpath.py(255):         return path
 --- modulename: posixpath, funcname: expandvars
posixpath.py(287):     if '$' not in path:
posixpath.py(288):         return path
files.py(150):     path = os.path.abspath(os.path.realpath(path))
 --- modulename: posixpath, funcname: realpath
posixpath.py(375):     path, ok = _joinrealpath('', filename, {})
 --- modulename: posixpath, funcname: _joinrealpath
posixpath.py(381):     if isabs(rest):
 --- modulename: posixpath, funcname: isabs
posixpath.py(54):     return s.startswith('/')
posixpath.py(382):         rest = rest[1:]
posixpath.py(383):         path = sep
posixpath.py(385):     while rest:
posixpath.py(386):         name, _, rest = rest.partition(sep)
posixpath.py(387):         if not name or name == curdir:
posixpath.py(390):         if name == pardir:
posixpath.py(399):         newpath = join(path, name)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(71):             path +=  b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
posixpath.py(400):         if not islink(newpath):
 --- modulename: posixpath, funcname: islink
posixpath.py(134):     try:
posixpath.py(135):         st = os.lstat(path)
posixpath.py(138):     return stat.S_ISLNK(st.st_mode)
 --- modulename: stat, funcname: S_ISLNK
stat.py(56):     return S_IFMT(mode) == S_IFLNK
 --- modulename: stat, funcname: S_IFMT
stat.py(25):     return mode & 0170000
posixpath.py(401):             path = newpath
posixpath.py(402):             continue
posixpath.py(385):     while rest:
posixpath.py(386):         name, _, rest = rest.partition(sep)
posixpath.py(387):         if not name or name == curdir:
posixpath.py(390):         if name == pardir:
posixpath.py(399):         newpath = join(path, name)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
posixpath.py(400):         if not islink(newpath):
 --- modulename: posixpath, funcname: islink
posixpath.py(134):     try:
posixpath.py(135):         st = os.lstat(path)
posixpath.py(138):     return stat.S_ISLNK(st.st_mode)
 --- modulename: stat, funcname: S_ISLNK
stat.py(56):     return S_IFMT(mode) == S_IFLNK
 --- modulename: stat, funcname: S_IFMT
stat.py(25):     return mode & 0170000
posixpath.py(401):             path = newpath
posixpath.py(402):             continue
posixpath.py(385):     while rest:
posixpath.py(386):         name, _, rest = rest.partition(sep)
posixpath.py(387):         if not name or name == curdir:
posixpath.py(390):         if name == pardir:
posixpath.py(399):         newpath = join(path, name)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
posixpath.py(400):         if not islink(newpath):
 --- modulename: posixpath, funcname: islink
posixpath.py(134):     try:
posixpath.py(135):         st = os.lstat(path)
posixpath.py(138):     return stat.S_ISLNK(st.st_mode)
 --- modulename: stat, funcname: S_ISLNK
stat.py(56):     return S_IFMT(mode) == S_IFLNK
 --- modulename: stat, funcname: S_IFMT
stat.py(25):     return mode & 0170000
posixpath.py(401):             path = newpath
posixpath.py(402):             continue
posixpath.py(385):     while rest:
posixpath.py(386):         name, _, rest = rest.partition(sep)
posixpath.py(387):         if not name or name == curdir:
posixpath.py(390):         if name == pardir:
posixpath.py(399):         newpath = join(path, name)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
posixpath.py(400):         if not islink(newpath):
 --- modulename: posixpath, funcname: islink
posixpath.py(134):     try:
posixpath.py(135):         st = os.lstat(path)
posixpath.py(138):     return stat.S_ISLNK(st.st_mode)
 --- modulename: stat, funcname: S_ISLNK
stat.py(56):     return S_IFMT(mode) == S_IFLNK
 --- modulename: stat, funcname: S_IFMT
stat.py(25):     return mode & 0170000
posixpath.py(401):             path = newpath
posixpath.py(402):             continue
posixpath.py(385):     while rest:
posixpath.py(419):     return path, True
posixpath.py(376):     return abspath(path)
 --- modulename: posixpath, funcname: abspath
posixpath.py(360):     if not isabs(path):
 --- modulename: posixpath, funcname: isabs
posixpath.py(54):     return s.startswith('/')
posixpath.py(366):     return normpath(path)
 --- modulename: posixpath, funcname: normpath
posixpath.py(332):     slash, dot = (u'/', u'.') if isinstance(path, _unicode) else ('/', '.')
posixpath.py(333):     if path == '':
posixpath.py(335):     initial_slashes = path.startswith('/')
posixpath.py(338):     if (initial_slashes and
posixpath.py(339):         path.startswith('//') and not path.startswith('///')):
posixpath.py(341):     comps = path.split('/')
posixpath.py(342):     new_comps = []
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(345):             continue
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(351):     comps = new_comps
posixpath.py(352):     path = slash.join(comps)
posixpath.py(353):     if initial_slashes:
posixpath.py(354):         path = slash*initial_slashes + path
posixpath.py(355):     return path or dot
 --- modulename: posixpath, funcname: abspath
posixpath.py(360):     if not isabs(path):
 --- modulename: posixpath, funcname: isabs
posixpath.py(54):     return s.startswith('/')
posixpath.py(366):     return normpath(path)
 --- modulename: posixpath, funcname: normpath
posixpath.py(332):     slash, dot = (u'/', u'.') if isinstance(path, _unicode) else ('/', '.')
posixpath.py(333):     if path == '':
posixpath.py(335):     initial_slashes = path.startswith('/')
posixpath.py(338):     if (initial_slashes and
posixpath.py(339):         path.startswith('//') and not path.startswith('///')):
posixpath.py(341):     comps = path.split('/')
posixpath.py(342):     new_comps = []
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(345):             continue
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(351):     comps = new_comps
posixpath.py(352):     path = slash.join(comps)
posixpath.py(353):     if initial_slashes:
posixpath.py(354):         path = slash*initial_slashes + path
posixpath.py(355):     return path or dot
files.py(151):     path = actual_path(path)
 --- modulename: files, funcname: actual_path
files.py(128):         return filename
files.py(152):     path = unicode_filename(path)
 --- modulename: files, funcname: unicode_filename
files.py(135):         if isinstance(filename, str):
files.py(138):         return filename
files.py(153):     return path
files.py(70):         CANONICAL_FILENAME_CACHE[filename] = cf
files.py(71):     return CANONICAL_FILENAME_CACHE[filename]
 --- modulename: plugin, funcname: __init__
plugin.py(205):         self.filename = filename
python.py(108):         if hasattr(morf, '__name__'):
python.py(109):             name = morf.__name__
python.py(110):             name = name.replace(".", os.sep) + ".py"
python.py(111):             name = files.unicode_filename(name)
 --- modulename: files, funcname: unicode_filename
files.py(135):         if isinstance(filename, str):
files.py(136):             encoding = sys.getfilesystemencoding() or sys.getdefaultencoding()
files.py(137):             filename = filename.decode(encoding, "replace")
 --- modulename: utf_8, funcname: decode
utf_8.py(16):     return codecs.utf_8_decode(input, errors, True)
files.py(138):         return filename
python.py(114):         self.relname = name
python.py(116):         self._source = None
python.py(117):         self._parser = None
python.py(118):         self._statements = None
python.py(119):         self._excluded = None
control.py(361):         return os.path.split(morf_filename)[0]
 --- modulename: posixpath, funcname: split
posixpath.py(85):     i = p.rfind('/') + 1
posixpath.py(86):     head, tail = p[:i], p[i:]
posixpath.py(87):     if head and head != '/'*len(head):
posixpath.py(88):         head = head.rstrip('/')
posixpath.py(89):     return head, tail
control.py(294):             for m in (atexit, inspect, os, platform, re, _structseq, traceback):
control.py(295):                 if m is not None and hasattr(m, "__file__"):
control.py(296):                     self.pylib_dirs.add(self._canonical_dir(m))
 --- modulename: control, funcname: _canonical_dir
control.py(360):         morf_filename = PythonFileReporter(morf, self).filename
 --- modulename: python, funcname: __init__
python.py(91):         self.coverage = coverage
python.py(93):         if hasattr(morf, '__file__'):
python.py(94):             filename = morf.__file__
python.py(98):         filename = files.unicode_filename(filename)
 --- modulename: files, funcname: unicode_filename
files.py(135):         if isinstance(filename, str):
files.py(136):             encoding = sys.getfilesystemencoding() or sys.getdefaultencoding()
files.py(137):             filename = filename.decode(encoding, "replace")
 --- modulename: utf_8, funcname: decode
utf_8.py(16):     return codecs.utf_8_decode(input, errors, True)
files.py(138):         return filename
python.py(101):         if filename.endswith(('.pyc', '.pyo')):
python.py(102):             filename = filename[:-1]
python.py(106):         super(PythonFileReporter, self).__init__(files.canonical_filename(filename))
 --- modulename: files, funcname: canonical_filename
files.py(60):     if filename not in CANONICAL_FILENAME_CACHE:
files.py(61):         if not os.path.isabs(filename):
 --- modulename: posixpath, funcname: isabs
posixpath.py(54):     return s.startswith('/')
files.py(69):         cf = abs_file(filename)
 --- modulename: files, funcname: abs_file
files.py(149):     path = os.path.expandvars(os.path.expanduser(filename))
 --- modulename: posixpath, funcname: expanduser
posixpath.py(254):     if not path.startswith('~'):
posixpath.py(255):         return path
 --- modulename: posixpath, funcname: expandvars
posixpath.py(287):     if '$' not in path:
posixpath.py(288):         return path
files.py(150):     path = os.path.abspath(os.path.realpath(path))
 --- modulename: posixpath, funcname: realpath
posixpath.py(375):     path, ok = _joinrealpath('', filename, {})
 --- modulename: posixpath, funcname: _joinrealpath
posixpath.py(381):     if isabs(rest):
 --- modulename: posixpath, funcname: isabs
posixpath.py(54):     return s.startswith('/')
posixpath.py(382):         rest = rest[1:]
posixpath.py(383):         path = sep
posixpath.py(385):     while rest:
posixpath.py(386):         name, _, rest = rest.partition(sep)
posixpath.py(387):         if not name or name == curdir:
posixpath.py(390):         if name == pardir:
posixpath.py(399):         newpath = join(path, name)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(71):             path +=  b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
posixpath.py(400):         if not islink(newpath):
 --- modulename: posixpath, funcname: islink
posixpath.py(134):     try:
posixpath.py(135):         st = os.lstat(path)
posixpath.py(138):     return stat.S_ISLNK(st.st_mode)
 --- modulename: stat, funcname: S_ISLNK
stat.py(56):     return S_IFMT(mode) == S_IFLNK
 --- modulename: stat, funcname: S_IFMT
stat.py(25):     return mode & 0170000
posixpath.py(401):             path = newpath
posixpath.py(402):             continue
posixpath.py(385):     while rest:
posixpath.py(386):         name, _, rest = rest.partition(sep)
posixpath.py(387):         if not name or name == curdir:
posixpath.py(390):         if name == pardir:
posixpath.py(399):         newpath = join(path, name)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
posixpath.py(400):         if not islink(newpath):
 --- modulename: posixpath, funcname: islink
posixpath.py(134):     try:
posixpath.py(135):         st = os.lstat(path)
posixpath.py(138):     return stat.S_ISLNK(st.st_mode)
 --- modulename: stat, funcname: S_ISLNK
stat.py(56):     return S_IFMT(mode) == S_IFLNK
 --- modulename: stat, funcname: S_IFMT
stat.py(25):     return mode & 0170000
posixpath.py(401):             path = newpath
posixpath.py(402):             continue
posixpath.py(385):     while rest:
posixpath.py(386):         name, _, rest = rest.partition(sep)
posixpath.py(387):         if not name or name == curdir:
posixpath.py(390):         if name == pardir:
posixpath.py(399):         newpath = join(path, name)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
posixpath.py(400):         if not islink(newpath):
 --- modulename: posixpath, funcname: islink
posixpath.py(134):     try:
posixpath.py(135):         st = os.lstat(path)
posixpath.py(138):     return stat.S_ISLNK(st.st_mode)
 --- modulename: stat, funcname: S_ISLNK
stat.py(56):     return S_IFMT(mode) == S_IFLNK
 --- modulename: stat, funcname: S_IFMT
stat.py(25):     return mode & 0170000
posixpath.py(401):             path = newpath
posixpath.py(402):             continue
posixpath.py(385):     while rest:
posixpath.py(386):         name, _, rest = rest.partition(sep)
posixpath.py(387):         if not name or name == curdir:
posixpath.py(390):         if name == pardir:
posixpath.py(399):         newpath = join(path, name)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
posixpath.py(400):         if not islink(newpath):
 --- modulename: posixpath, funcname: islink
posixpath.py(134):     try:
posixpath.py(135):         st = os.lstat(path)
posixpath.py(138):     return stat.S_ISLNK(st.st_mode)
 --- modulename: stat, funcname: S_ISLNK
stat.py(56):     return S_IFMT(mode) == S_IFLNK
 --- modulename: stat, funcname: S_IFMT
stat.py(25):     return mode & 0170000
posixpath.py(401):             path = newpath
posixpath.py(402):             continue
posixpath.py(385):     while rest:
posixpath.py(419):     return path, True
posixpath.py(376):     return abspath(path)
 --- modulename: posixpath, funcname: abspath
posixpath.py(360):     if not isabs(path):
 --- modulename: posixpath, funcname: isabs
posixpath.py(54):     return s.startswith('/')
posixpath.py(366):     return normpath(path)
 --- modulename: posixpath, funcname: normpath
posixpath.py(332):     slash, dot = (u'/', u'.') if isinstance(path, _unicode) else ('/', '.')
posixpath.py(333):     if path == '':
posixpath.py(335):     initial_slashes = path.startswith('/')
posixpath.py(338):     if (initial_slashes and
posixpath.py(339):         path.startswith('//') and not path.startswith('///')):
posixpath.py(341):     comps = path.split('/')
posixpath.py(342):     new_comps = []
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(345):             continue
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(351):     comps = new_comps
posixpath.py(352):     path = slash.join(comps)
posixpath.py(353):     if initial_slashes:
posixpath.py(354):         path = slash*initial_slashes + path
posixpath.py(355):     return path or dot
 --- modulename: posixpath, funcname: abspath
posixpath.py(360):     if not isabs(path):
 --- modulename: posixpath, funcname: isabs
posixpath.py(54):     return s.startswith('/')
posixpath.py(366):     return normpath(path)
 --- modulename: posixpath, funcname: normpath
posixpath.py(332):     slash, dot = (u'/', u'.') if isinstance(path, _unicode) else ('/', '.')
posixpath.py(333):     if path == '':
posixpath.py(335):     initial_slashes = path.startswith('/')
posixpath.py(338):     if (initial_slashes and
posixpath.py(339):         path.startswith('//') and not path.startswith('///')):
posixpath.py(341):     comps = path.split('/')
posixpath.py(342):     new_comps = []
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(345):             continue
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(351):     comps = new_comps
posixpath.py(352):     path = slash.join(comps)
posixpath.py(353):     if initial_slashes:
posixpath.py(354):         path = slash*initial_slashes + path
posixpath.py(355):     return path or dot
files.py(151):     path = actual_path(path)
 --- modulename: files, funcname: actual_path
files.py(128):         return filename
files.py(152):     path = unicode_filename(path)
 --- modulename: files, funcname: unicode_filename
files.py(135):         if isinstance(filename, str):
files.py(138):         return filename
files.py(153):     return path
files.py(70):         CANONICAL_FILENAME_CACHE[filename] = cf
files.py(71):     return CANONICAL_FILENAME_CACHE[filename]
 --- modulename: plugin, funcname: __init__
plugin.py(205):         self.filename = filename
python.py(108):         if hasattr(morf, '__name__'):
python.py(109):             name = morf.__name__
python.py(110):             name = name.replace(".", os.sep) + ".py"
python.py(111):             name = files.unicode_filename(name)
 --- modulename: files, funcname: unicode_filename
files.py(135):         if isinstance(filename, str):
files.py(136):             encoding = sys.getfilesystemencoding() or sys.getdefaultencoding()
files.py(137):             filename = filename.decode(encoding, "replace")
 --- modulename: utf_8, funcname: decode
utf_8.py(16):     return codecs.utf_8_decode(input, errors, True)
files.py(138):         return filename
python.py(114):         self.relname = name
python.py(116):         self._source = None
python.py(117):         self._parser = None
python.py(118):         self._statements = None
python.py(119):         self._excluded = None
control.py(361):         return os.path.split(morf_filename)[0]
 --- modulename: posixpath, funcname: split
posixpath.py(85):     i = p.rfind('/') + 1
posixpath.py(86):     head, tail = p[:i], p[i:]
posixpath.py(87):     if head and head != '/'*len(head):
posixpath.py(88):         head = head.rstrip('/')
posixpath.py(89):     return head, tail
control.py(294):             for m in (atexit, inspect, os, platform, re, _structseq, traceback):
control.py(295):                 if m is not None and hasattr(m, "__file__"):
control.py(296):                     self.pylib_dirs.add(self._canonical_dir(m))
 --- modulename: control, funcname: _canonical_dir
control.py(360):         morf_filename = PythonFileReporter(morf, self).filename
 --- modulename: python, funcname: __init__
python.py(91):         self.coverage = coverage
python.py(93):         if hasattr(morf, '__file__'):
python.py(94):             filename = morf.__file__
python.py(98):         filename = files.unicode_filename(filename)
 --- modulename: files, funcname: unicode_filename
files.py(135):         if isinstance(filename, str):
files.py(136):             encoding = sys.getfilesystemencoding() or sys.getdefaultencoding()
files.py(137):             filename = filename.decode(encoding, "replace")
 --- modulename: utf_8, funcname: decode
utf_8.py(16):     return codecs.utf_8_decode(input, errors, True)
files.py(138):         return filename
python.py(101):         if filename.endswith(('.pyc', '.pyo')):
python.py(102):             filename = filename[:-1]
python.py(106):         super(PythonFileReporter, self).__init__(files.canonical_filename(filename))
 --- modulename: files, funcname: canonical_filename
files.py(60):     if filename not in CANONICAL_FILENAME_CACHE:
files.py(61):         if not os.path.isabs(filename):
 --- modulename: posixpath, funcname: isabs
posixpath.py(54):     return s.startswith('/')
files.py(69):         cf = abs_file(filename)
 --- modulename: files, funcname: abs_file
files.py(149):     path = os.path.expandvars(os.path.expanduser(filename))
 --- modulename: posixpath, funcname: expanduser
posixpath.py(254):     if not path.startswith('~'):
posixpath.py(255):         return path
 --- modulename: posixpath, funcname: expandvars
posixpath.py(287):     if '$' not in path:
posixpath.py(288):         return path
files.py(150):     path = os.path.abspath(os.path.realpath(path))
 --- modulename: posixpath, funcname: realpath
posixpath.py(375):     path, ok = _joinrealpath('', filename, {})
 --- modulename: posixpath, funcname: _joinrealpath
posixpath.py(381):     if isabs(rest):
 --- modulename: posixpath, funcname: isabs
posixpath.py(54):     return s.startswith('/')
posixpath.py(382):         rest = rest[1:]
posixpath.py(383):         path = sep
posixpath.py(385):     while rest:
posixpath.py(386):         name, _, rest = rest.partition(sep)
posixpath.py(387):         if not name or name == curdir:
posixpath.py(390):         if name == pardir:
posixpath.py(399):         newpath = join(path, name)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(71):             path +=  b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
posixpath.py(400):         if not islink(newpath):
 --- modulename: posixpath, funcname: islink
posixpath.py(134):     try:
posixpath.py(135):         st = os.lstat(path)
posixpath.py(138):     return stat.S_ISLNK(st.st_mode)
 --- modulename: stat, funcname: S_ISLNK
stat.py(56):     return S_IFMT(mode) == S_IFLNK
 --- modulename: stat, funcname: S_IFMT
stat.py(25):     return mode & 0170000
posixpath.py(401):             path = newpath
posixpath.py(402):             continue
posixpath.py(385):     while rest:
posixpath.py(386):         name, _, rest = rest.partition(sep)
posixpath.py(387):         if not name or name == curdir:
posixpath.py(390):         if name == pardir:
posixpath.py(399):         newpath = join(path, name)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
posixpath.py(400):         if not islink(newpath):
 --- modulename: posixpath, funcname: islink
posixpath.py(134):     try:
posixpath.py(135):         st = os.lstat(path)
posixpath.py(138):     return stat.S_ISLNK(st.st_mode)
 --- modulename: stat, funcname: S_ISLNK
stat.py(56):     return S_IFMT(mode) == S_IFLNK
 --- modulename: stat, funcname: S_IFMT
stat.py(25):     return mode & 0170000
posixpath.py(401):             path = newpath
posixpath.py(402):             continue
posixpath.py(385):     while rest:
posixpath.py(386):         name, _, rest = rest.partition(sep)
posixpath.py(387):         if not name or name == curdir:
posixpath.py(390):         if name == pardir:
posixpath.py(399):         newpath = join(path, name)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
posixpath.py(400):         if not islink(newpath):
 --- modulename: posixpath, funcname: islink
posixpath.py(134):     try:
posixpath.py(135):         st = os.lstat(path)
posixpath.py(138):     return stat.S_ISLNK(st.st_mode)
 --- modulename: stat, funcname: S_ISLNK
stat.py(56):     return S_IFMT(mode) == S_IFLNK
 --- modulename: stat, funcname: S_IFMT
stat.py(25):     return mode & 0170000
posixpath.py(401):             path = newpath
posixpath.py(402):             continue
posixpath.py(385):     while rest:
posixpath.py(386):         name, _, rest = rest.partition(sep)
posixpath.py(387):         if not name or name == curdir:
posixpath.py(390):         if name == pardir:
posixpath.py(399):         newpath = join(path, name)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
posixpath.py(400):         if not islink(newpath):
 --- modulename: posixpath, funcname: islink
posixpath.py(134):     try:
posixpath.py(135):         st = os.lstat(path)
posixpath.py(138):     return stat.S_ISLNK(st.st_mode)
 --- modulename: stat, funcname: S_ISLNK
stat.py(56):     return S_IFMT(mode) == S_IFLNK
 --- modulename: stat, funcname: S_IFMT
stat.py(25):     return mode & 0170000
posixpath.py(401):             path = newpath
posixpath.py(402):             continue
posixpath.py(385):     while rest:
posixpath.py(419):     return path, True
posixpath.py(376):     return abspath(path)
 --- modulename: posixpath, funcname: abspath
posixpath.py(360):     if not isabs(path):
 --- modulename: posixpath, funcname: isabs
posixpath.py(54):     return s.startswith('/')
posixpath.py(366):     return normpath(path)
 --- modulename: posixpath, funcname: normpath
posixpath.py(332):     slash, dot = (u'/', u'.') if isinstance(path, _unicode) else ('/', '.')
posixpath.py(333):     if path == '':
posixpath.py(335):     initial_slashes = path.startswith('/')
posixpath.py(338):     if (initial_slashes and
posixpath.py(339):         path.startswith('//') and not path.startswith('///')):
posixpath.py(341):     comps = path.split('/')
posixpath.py(342):     new_comps = []
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(345):             continue
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(351):     comps = new_comps
posixpath.py(352):     path = slash.join(comps)
posixpath.py(353):     if initial_slashes:
posixpath.py(354):         path = slash*initial_slashes + path
posixpath.py(355):     return path or dot
 --- modulename: posixpath, funcname: abspath
posixpath.py(360):     if not isabs(path):
 --- modulename: posixpath, funcname: isabs
posixpath.py(54):     return s.startswith('/')
posixpath.py(366):     return normpath(path)
 --- modulename: posixpath, funcname: normpath
posixpath.py(332):     slash, dot = (u'/', u'.') if isinstance(path, _unicode) else ('/', '.')
posixpath.py(333):     if path == '':
posixpath.py(335):     initial_slashes = path.startswith('/')
posixpath.py(338):     if (initial_slashes and
posixpath.py(339):         path.startswith('//') and not path.startswith('///')):
posixpath.py(341):     comps = path.split('/')
posixpath.py(342):     new_comps = []
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(345):             continue
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(351):     comps = new_comps
posixpath.py(352):     path = slash.join(comps)
posixpath.py(353):     if initial_slashes:
posixpath.py(354):         path = slash*initial_slashes + path
posixpath.py(355):     return path or dot
files.py(151):     path = actual_path(path)
 --- modulename: files, funcname: actual_path
files.py(128):         return filename
files.py(152):     path = unicode_filename(path)
 --- modulename: files, funcname: unicode_filename
files.py(135):         if isinstance(filename, str):
files.py(138):         return filename
files.py(153):     return path
files.py(70):         CANONICAL_FILENAME_CACHE[filename] = cf
files.py(71):     return CANONICAL_FILENAME_CACHE[filename]
 --- modulename: plugin, funcname: __init__
plugin.py(205):         self.filename = filename
python.py(108):         if hasattr(morf, '__name__'):
python.py(109):             name = morf.__name__
python.py(110):             name = name.replace(".", os.sep) + ".py"
python.py(111):             name = files.unicode_filename(name)
 --- modulename: files, funcname: unicode_filename
files.py(135):         if isinstance(filename, str):
files.py(136):             encoding = sys.getfilesystemencoding() or sys.getdefaultencoding()
files.py(137):             filename = filename.decode(encoding, "replace")
 --- modulename: utf_8, funcname: decode
utf_8.py(16):     return codecs.utf_8_decode(input, errors, True)
files.py(138):         return filename
python.py(114):         self.relname = name
python.py(116):         self._source = None
python.py(117):         self._parser = None
python.py(118):         self._statements = None
python.py(119):         self._excluded = None
control.py(361):         return os.path.split(morf_filename)[0]
 --- modulename: posixpath, funcname: split
posixpath.py(85):     i = p.rfind('/') + 1
posixpath.py(86):     head, tail = p[:i], p[i:]
posixpath.py(87):     if head and head != '/'*len(head):
posixpath.py(88):         head = head.rstrip('/')
posixpath.py(89):     return head, tail
control.py(294):             for m in (atexit, inspect, os, platform, re, _structseq, traceback):
control.py(295):                 if m is not None and hasattr(m, "__file__"):
control.py(296):                     self.pylib_dirs.add(self._canonical_dir(m))
 --- modulename: control, funcname: _canonical_dir
control.py(360):         morf_filename = PythonFileReporter(morf, self).filename
 --- modulename: python, funcname: __init__
python.py(91):         self.coverage = coverage
python.py(93):         if hasattr(morf, '__file__'):
python.py(94):             filename = morf.__file__
python.py(98):         filename = files.unicode_filename(filename)
 --- modulename: files, funcname: unicode_filename
files.py(135):         if isinstance(filename, str):
files.py(136):             encoding = sys.getfilesystemencoding() or sys.getdefaultencoding()
files.py(137):             filename = filename.decode(encoding, "replace")
 --- modulename: utf_8, funcname: decode
utf_8.py(16):     return codecs.utf_8_decode(input, errors, True)
files.py(138):         return filename
python.py(101):         if filename.endswith(('.pyc', '.pyo')):
python.py(102):             filename = filename[:-1]
python.py(106):         super(PythonFileReporter, self).__init__(files.canonical_filename(filename))
 --- modulename: files, funcname: canonical_filename
files.py(60):     if filename not in CANONICAL_FILENAME_CACHE:
files.py(61):         if not os.path.isabs(filename):
 --- modulename: posixpath, funcname: isabs
posixpath.py(54):     return s.startswith('/')
files.py(69):         cf = abs_file(filename)
 --- modulename: files, funcname: abs_file
files.py(149):     path = os.path.expandvars(os.path.expanduser(filename))
 --- modulename: posixpath, funcname: expanduser
posixpath.py(254):     if not path.startswith('~'):
posixpath.py(255):         return path
 --- modulename: posixpath, funcname: expandvars
posixpath.py(287):     if '$' not in path:
posixpath.py(288):         return path
files.py(150):     path = os.path.abspath(os.path.realpath(path))
 --- modulename: posixpath, funcname: realpath
posixpath.py(375):     path, ok = _joinrealpath('', filename, {})
 --- modulename: posixpath, funcname: _joinrealpath
posixpath.py(381):     if isabs(rest):
 --- modulename: posixpath, funcname: isabs
posixpath.py(54):     return s.startswith('/')
posixpath.py(382):         rest = rest[1:]
posixpath.py(383):         path = sep
posixpath.py(385):     while rest:
posixpath.py(386):         name, _, rest = rest.partition(sep)
posixpath.py(387):         if not name or name == curdir:
posixpath.py(390):         if name == pardir:
posixpath.py(399):         newpath = join(path, name)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(71):             path +=  b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
posixpath.py(400):         if not islink(newpath):
 --- modulename: posixpath, funcname: islink
posixpath.py(134):     try:
posixpath.py(135):         st = os.lstat(path)
posixpath.py(138):     return stat.S_ISLNK(st.st_mode)
 --- modulename: stat, funcname: S_ISLNK
stat.py(56):     return S_IFMT(mode) == S_IFLNK
 --- modulename: stat, funcname: S_IFMT
stat.py(25):     return mode & 0170000
posixpath.py(401):             path = newpath
posixpath.py(402):             continue
posixpath.py(385):     while rest:
posixpath.py(386):         name, _, rest = rest.partition(sep)
posixpath.py(387):         if not name or name == curdir:
posixpath.py(390):         if name == pardir:
posixpath.py(399):         newpath = join(path, name)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
posixpath.py(400):         if not islink(newpath):
 --- modulename: posixpath, funcname: islink
posixpath.py(134):     try:
posixpath.py(135):         st = os.lstat(path)
posixpath.py(138):     return stat.S_ISLNK(st.st_mode)
 --- modulename: stat, funcname: S_ISLNK
stat.py(56):     return S_IFMT(mode) == S_IFLNK
 --- modulename: stat, funcname: S_IFMT
stat.py(25):     return mode & 0170000
posixpath.py(401):             path = newpath
posixpath.py(402):             continue
posixpath.py(385):     while rest:
posixpath.py(386):         name, _, rest = rest.partition(sep)
posixpath.py(387):         if not name or name == curdir:
posixpath.py(390):         if name == pardir:
posixpath.py(399):         newpath = join(path, name)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
posixpath.py(400):         if not islink(newpath):
 --- modulename: posixpath, funcname: islink
posixpath.py(134):     try:
posixpath.py(135):         st = os.lstat(path)
posixpath.py(138):     return stat.S_ISLNK(st.st_mode)
 --- modulename: stat, funcname: S_ISLNK
stat.py(56):     return S_IFMT(mode) == S_IFLNK
 --- modulename: stat, funcname: S_IFMT
stat.py(25):     return mode & 0170000
posixpath.py(401):             path = newpath
posixpath.py(402):             continue
posixpath.py(385):     while rest:
posixpath.py(386):         name, _, rest = rest.partition(sep)
posixpath.py(387):         if not name or name == curdir:
posixpath.py(390):         if name == pardir:
posixpath.py(399):         newpath = join(path, name)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
posixpath.py(400):         if not islink(newpath):
 --- modulename: posixpath, funcname: islink
posixpath.py(134):     try:
posixpath.py(135):         st = os.lstat(path)
posixpath.py(138):     return stat.S_ISLNK(st.st_mode)
 --- modulename: stat, funcname: S_ISLNK
stat.py(56):     return S_IFMT(mode) == S_IFLNK
 --- modulename: stat, funcname: S_IFMT
stat.py(25):     return mode & 0170000
posixpath.py(401):             path = newpath
posixpath.py(402):             continue
posixpath.py(385):     while rest:
posixpath.py(419):     return path, True
posixpath.py(376):     return abspath(path)
 --- modulename: posixpath, funcname: abspath
posixpath.py(360):     if not isabs(path):
 --- modulename: posixpath, funcname: isabs
posixpath.py(54):     return s.startswith('/')
posixpath.py(366):     return normpath(path)
 --- modulename: posixpath, funcname: normpath
posixpath.py(332):     slash, dot = (u'/', u'.') if isinstance(path, _unicode) else ('/', '.')
posixpath.py(333):     if path == '':
posixpath.py(335):     initial_slashes = path.startswith('/')
posixpath.py(338):     if (initial_slashes and
posixpath.py(339):         path.startswith('//') and not path.startswith('///')):
posixpath.py(341):     comps = path.split('/')
posixpath.py(342):     new_comps = []
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(345):             continue
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(351):     comps = new_comps
posixpath.py(352):     path = slash.join(comps)
posixpath.py(353):     if initial_slashes:
posixpath.py(354):         path = slash*initial_slashes + path
posixpath.py(355):     return path or dot
 --- modulename: posixpath, funcname: abspath
posixpath.py(360):     if not isabs(path):
 --- modulename: posixpath, funcname: isabs
posixpath.py(54):     return s.startswith('/')
posixpath.py(366):     return normpath(path)
 --- modulename: posixpath, funcname: normpath
posixpath.py(332):     slash, dot = (u'/', u'.') if isinstance(path, _unicode) else ('/', '.')
posixpath.py(333):     if path == '':
posixpath.py(335):     initial_slashes = path.startswith('/')
posixpath.py(338):     if (initial_slashes and
posixpath.py(339):         path.startswith('//') and not path.startswith('///')):
posixpath.py(341):     comps = path.split('/')
posixpath.py(342):     new_comps = []
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(345):             continue
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(351):     comps = new_comps
posixpath.py(352):     path = slash.join(comps)
posixpath.py(353):     if initial_slashes:
posixpath.py(354):         path = slash*initial_slashes + path
posixpath.py(355):     return path or dot
files.py(151):     path = actual_path(path)
 --- modulename: files, funcname: actual_path
files.py(128):         return filename
files.py(152):     path = unicode_filename(path)
 --- modulename: files, funcname: unicode_filename
files.py(135):         if isinstance(filename, str):
files.py(138):         return filename
files.py(153):     return path
files.py(70):         CANONICAL_FILENAME_CACHE[filename] = cf
files.py(71):     return CANONICAL_FILENAME_CACHE[filename]
 --- modulename: plugin, funcname: __init__
plugin.py(205):         self.filename = filename
python.py(108):         if hasattr(morf, '__name__'):
python.py(109):             name = morf.__name__
python.py(110):             name = name.replace(".", os.sep) + ".py"
python.py(111):             name = files.unicode_filename(name)
 --- modulename: files, funcname: unicode_filename
files.py(135):         if isinstance(filename, str):
files.py(136):             encoding = sys.getfilesystemencoding() or sys.getdefaultencoding()
files.py(137):             filename = filename.decode(encoding, "replace")
 --- modulename: utf_8, funcname: decode
utf_8.py(16):     return codecs.utf_8_decode(input, errors, True)
files.py(138):         return filename
python.py(114):         self.relname = name
python.py(116):         self._source = None
python.py(117):         self._parser = None
python.py(118):         self._statements = None
python.py(119):         self._excluded = None
control.py(361):         return os.path.split(morf_filename)[0]
 --- modulename: posixpath, funcname: split
posixpath.py(85):     i = p.rfind('/') + 1
posixpath.py(86):     head, tail = p[:i], p[i:]
posixpath.py(87):     if head and head != '/'*len(head):
posixpath.py(88):         head = head.rstrip('/')
posixpath.py(89):     return head, tail
control.py(294):             for m in (atexit, inspect, os, platform, re, _structseq, traceback):
control.py(295):                 if m is not None and hasattr(m, "__file__"):
control.py(294):             for m in (atexit, inspect, os, platform, re, _structseq, traceback):
control.py(295):                 if m is not None and hasattr(m, "__file__"):
control.py(296):                     self.pylib_dirs.add(self._canonical_dir(m))
 --- modulename: control, funcname: _canonical_dir
control.py(360):         morf_filename = PythonFileReporter(morf, self).filename
 --- modulename: python, funcname: __init__
python.py(91):         self.coverage = coverage
python.py(93):         if hasattr(morf, '__file__'):
python.py(94):             filename = morf.__file__
python.py(98):         filename = files.unicode_filename(filename)
 --- modulename: files, funcname: unicode_filename
files.py(135):         if isinstance(filename, str):
files.py(136):             encoding = sys.getfilesystemencoding() or sys.getdefaultencoding()
files.py(137):             filename = filename.decode(encoding, "replace")
 --- modulename: utf_8, funcname: decode
utf_8.py(16):     return codecs.utf_8_decode(input, errors, True)
files.py(138):         return filename
python.py(101):         if filename.endswith(('.pyc', '.pyo')):
python.py(102):             filename = filename[:-1]
python.py(106):         super(PythonFileReporter, self).__init__(files.canonical_filename(filename))
 --- modulename: files, funcname: canonical_filename
files.py(60):     if filename not in CANONICAL_FILENAME_CACHE:
files.py(61):         if not os.path.isabs(filename):
 --- modulename: posixpath, funcname: isabs
posixpath.py(54):     return s.startswith('/')
files.py(69):         cf = abs_file(filename)
 --- modulename: files, funcname: abs_file
files.py(149):     path = os.path.expandvars(os.path.expanduser(filename))
 --- modulename: posixpath, funcname: expanduser
posixpath.py(254):     if not path.startswith('~'):
posixpath.py(255):         return path
 --- modulename: posixpath, funcname: expandvars
posixpath.py(287):     if '$' not in path:
posixpath.py(288):         return path
files.py(150):     path = os.path.abspath(os.path.realpath(path))
 --- modulename: posixpath, funcname: realpath
posixpath.py(375):     path, ok = _joinrealpath('', filename, {})
 --- modulename: posixpath, funcname: _joinrealpath
posixpath.py(381):     if isabs(rest):
 --- modulename: posixpath, funcname: isabs
posixpath.py(54):     return s.startswith('/')
posixpath.py(382):         rest = rest[1:]
posixpath.py(383):         path = sep
posixpath.py(385):     while rest:
posixpath.py(386):         name, _, rest = rest.partition(sep)
posixpath.py(387):         if not name or name == curdir:
posixpath.py(390):         if name == pardir:
posixpath.py(399):         newpath = join(path, name)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(71):             path +=  b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
posixpath.py(400):         if not islink(newpath):
 --- modulename: posixpath, funcname: islink
posixpath.py(134):     try:
posixpath.py(135):         st = os.lstat(path)
posixpath.py(138):     return stat.S_ISLNK(st.st_mode)
 --- modulename: stat, funcname: S_ISLNK
stat.py(56):     return S_IFMT(mode) == S_IFLNK
 --- modulename: stat, funcname: S_IFMT
stat.py(25):     return mode & 0170000
posixpath.py(401):             path = newpath
posixpath.py(402):             continue
posixpath.py(385):     while rest:
posixpath.py(386):         name, _, rest = rest.partition(sep)
posixpath.py(387):         if not name or name == curdir:
posixpath.py(390):         if name == pardir:
posixpath.py(399):         newpath = join(path, name)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
posixpath.py(400):         if not islink(newpath):
 --- modulename: posixpath, funcname: islink
posixpath.py(134):     try:
posixpath.py(135):         st = os.lstat(path)
posixpath.py(138):     return stat.S_ISLNK(st.st_mode)
 --- modulename: stat, funcname: S_ISLNK
stat.py(56):     return S_IFMT(mode) == S_IFLNK
 --- modulename: stat, funcname: S_IFMT
stat.py(25):     return mode & 0170000
posixpath.py(401):             path = newpath
posixpath.py(402):             continue
posixpath.py(385):     while rest:
posixpath.py(386):         name, _, rest = rest.partition(sep)
posixpath.py(387):         if not name or name == curdir:
posixpath.py(390):         if name == pardir:
posixpath.py(399):         newpath = join(path, name)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
posixpath.py(400):         if not islink(newpath):
 --- modulename: posixpath, funcname: islink
posixpath.py(134):     try:
posixpath.py(135):         st = os.lstat(path)
posixpath.py(138):     return stat.S_ISLNK(st.st_mode)
 --- modulename: stat, funcname: S_ISLNK
stat.py(56):     return S_IFMT(mode) == S_IFLNK
 --- modulename: stat, funcname: S_IFMT
stat.py(25):     return mode & 0170000
posixpath.py(401):             path = newpath
posixpath.py(402):             continue
posixpath.py(385):     while rest:
posixpath.py(386):         name, _, rest = rest.partition(sep)
posixpath.py(387):         if not name or name == curdir:
posixpath.py(390):         if name == pardir:
posixpath.py(399):         newpath = join(path, name)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
posixpath.py(400):         if not islink(newpath):
 --- modulename: posixpath, funcname: islink
posixpath.py(134):     try:
posixpath.py(135):         st = os.lstat(path)
posixpath.py(138):     return stat.S_ISLNK(st.st_mode)
 --- modulename: stat, funcname: S_ISLNK
stat.py(56):     return S_IFMT(mode) == S_IFLNK
 --- modulename: stat, funcname: S_IFMT
stat.py(25):     return mode & 0170000
posixpath.py(401):             path = newpath
posixpath.py(402):             continue
posixpath.py(385):     while rest:
posixpath.py(419):     return path, True
posixpath.py(376):     return abspath(path)
 --- modulename: posixpath, funcname: abspath
posixpath.py(360):     if not isabs(path):
 --- modulename: posixpath, funcname: isabs
posixpath.py(54):     return s.startswith('/')
posixpath.py(366):     return normpath(path)
 --- modulename: posixpath, funcname: normpath
posixpath.py(332):     slash, dot = (u'/', u'.') if isinstance(path, _unicode) else ('/', '.')
posixpath.py(333):     if path == '':
posixpath.py(335):     initial_slashes = path.startswith('/')
posixpath.py(338):     if (initial_slashes and
posixpath.py(339):         path.startswith('//') and not path.startswith('///')):
posixpath.py(341):     comps = path.split('/')
posixpath.py(342):     new_comps = []
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(345):             continue
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(351):     comps = new_comps
posixpath.py(352):     path = slash.join(comps)
posixpath.py(353):     if initial_slashes:
posixpath.py(354):         path = slash*initial_slashes + path
posixpath.py(355):     return path or dot
 --- modulename: posixpath, funcname: abspath
posixpath.py(360):     if not isabs(path):
 --- modulename: posixpath, funcname: isabs
posixpath.py(54):     return s.startswith('/')
posixpath.py(366):     return normpath(path)
 --- modulename: posixpath, funcname: normpath
posixpath.py(332):     slash, dot = (u'/', u'.') if isinstance(path, _unicode) else ('/', '.')
posixpath.py(333):     if path == '':
posixpath.py(335):     initial_slashes = path.startswith('/')
posixpath.py(338):     if (initial_slashes and
posixpath.py(339):         path.startswith('//') and not path.startswith('///')):
posixpath.py(341):     comps = path.split('/')
posixpath.py(342):     new_comps = []
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(345):             continue
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(351):     comps = new_comps
posixpath.py(352):     path = slash.join(comps)
posixpath.py(353):     if initial_slashes:
posixpath.py(354):         path = slash*initial_slashes + path
posixpath.py(355):     return path or dot
files.py(151):     path = actual_path(path)
 --- modulename: files, funcname: actual_path
files.py(128):         return filename
files.py(152):     path = unicode_filename(path)
 --- modulename: files, funcname: unicode_filename
files.py(135):         if isinstance(filename, str):
files.py(138):         return filename
files.py(153):     return path
files.py(70):         CANONICAL_FILENAME_CACHE[filename] = cf
files.py(71):     return CANONICAL_FILENAME_CACHE[filename]
 --- modulename: plugin, funcname: __init__
plugin.py(205):         self.filename = filename
python.py(108):         if hasattr(morf, '__name__'):
python.py(109):             name = morf.__name__
python.py(110):             name = name.replace(".", os.sep) + ".py"
python.py(111):             name = files.unicode_filename(name)
 --- modulename: files, funcname: unicode_filename
files.py(135):         if isinstance(filename, str):
files.py(136):             encoding = sys.getfilesystemencoding() or sys.getdefaultencoding()
files.py(137):             filename = filename.decode(encoding, "replace")
 --- modulename: utf_8, funcname: decode
utf_8.py(16):     return codecs.utf_8_decode(input, errors, True)
files.py(138):         return filename
python.py(114):         self.relname = name
python.py(116):         self._source = None
python.py(117):         self._parser = None
python.py(118):         self._statements = None
python.py(119):         self._excluded = None
control.py(361):         return os.path.split(morf_filename)[0]
 --- modulename: posixpath, funcname: split
posixpath.py(85):     i = p.rfind('/') + 1
posixpath.py(86):     head, tail = p[:i], p[i:]
posixpath.py(87):     if head and head != '/'*len(head):
posixpath.py(88):         head = head.rstrip('/')
posixpath.py(89):     return head, tail
control.py(294):             for m in (atexit, inspect, os, platform, re, _structseq, traceback):
control.py(297):             if _structseq and not hasattr(_structseq, '__file__'):
control.py(310):         self.cover_dirs = [self._canonical_dir(__file__)]
 --- modulename: control, funcname: _canonical_dir
control.py(360):         morf_filename = PythonFileReporter(morf, self).filename
 --- modulename: python, funcname: __init__
python.py(91):         self.coverage = coverage
python.py(93):         if hasattr(morf, '__file__'):
python.py(96):             filename = morf
python.py(98):         filename = files.unicode_filename(filename)
 --- modulename: files, funcname: unicode_filename
files.py(135):         if isinstance(filename, str):
files.py(136):             encoding = sys.getfilesystemencoding() or sys.getdefaultencoding()
files.py(137):             filename = filename.decode(encoding, "replace")
 --- modulename: utf_8, funcname: decode
utf_8.py(16):     return codecs.utf_8_decode(input, errors, True)
files.py(138):         return filename
python.py(101):         if filename.endswith(('.pyc', '.pyo')):
python.py(102):             filename = filename[:-1]
python.py(106):         super(PythonFileReporter, self).__init__(files.canonical_filename(filename))
 --- modulename: files, funcname: canonical_filename
files.py(60):     if filename not in CANONICAL_FILENAME_CACHE:
files.py(61):         if not os.path.isabs(filename):
 --- modulename: posixpath, funcname: isabs
posixpath.py(54):     return s.startswith('/')
files.py(69):         cf = abs_file(filename)
 --- modulename: files, funcname: abs_file
files.py(149):     path = os.path.expandvars(os.path.expanduser(filename))
 --- modulename: posixpath, funcname: expanduser
posixpath.py(254):     if not path.startswith('~'):
posixpath.py(255):         return path
 --- modulename: posixpath, funcname: expandvars
posixpath.py(287):     if '$' not in path:
posixpath.py(288):         return path
files.py(150):     path = os.path.abspath(os.path.realpath(path))
 --- modulename: posixpath, funcname: realpath
posixpath.py(375):     path, ok = _joinrealpath('', filename, {})
 --- modulename: posixpath, funcname: _joinrealpath
posixpath.py(381):     if isabs(rest):
 --- modulename: posixpath, funcname: isabs
posixpath.py(54):     return s.startswith('/')
posixpath.py(382):         rest = rest[1:]
posixpath.py(383):         path = sep
posixpath.py(385):     while rest:
posixpath.py(386):         name, _, rest = rest.partition(sep)
posixpath.py(387):         if not name or name == curdir:
posixpath.py(390):         if name == pardir:
posixpath.py(399):         newpath = join(path, name)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(71):             path +=  b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
posixpath.py(400):         if not islink(newpath):
 --- modulename: posixpath, funcname: islink
posixpath.py(134):     try:
posixpath.py(135):         st = os.lstat(path)
posixpath.py(138):     return stat.S_ISLNK(st.st_mode)
 --- modulename: stat, funcname: S_ISLNK
stat.py(56):     return S_IFMT(mode) == S_IFLNK
 --- modulename: stat, funcname: S_IFMT
stat.py(25):     return mode & 0170000
posixpath.py(401):             path = newpath
posixpath.py(402):             continue
posixpath.py(385):     while rest:
posixpath.py(386):         name, _, rest = rest.partition(sep)
posixpath.py(387):         if not name or name == curdir:
posixpath.py(390):         if name == pardir:
posixpath.py(399):         newpath = join(path, name)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
posixpath.py(400):         if not islink(newpath):
 --- modulename: posixpath, funcname: islink
posixpath.py(134):     try:
posixpath.py(135):         st = os.lstat(path)
posixpath.py(138):     return stat.S_ISLNK(st.st_mode)
 --- modulename: stat, funcname: S_ISLNK
stat.py(56):     return S_IFMT(mode) == S_IFLNK
 --- modulename: stat, funcname: S_IFMT
stat.py(25):     return mode & 0170000
posixpath.py(401):             path = newpath
posixpath.py(402):             continue
posixpath.py(385):     while rest:
posixpath.py(386):         name, _, rest = rest.partition(sep)
posixpath.py(387):         if not name or name == curdir:
posixpath.py(390):         if name == pardir:
posixpath.py(399):         newpath = join(path, name)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
posixpath.py(400):         if not islink(newpath):
 --- modulename: posixpath, funcname: islink
posixpath.py(134):     try:
posixpath.py(135):         st = os.lstat(path)
posixpath.py(138):     return stat.S_ISLNK(st.st_mode)
 --- modulename: stat, funcname: S_ISLNK
stat.py(56):     return S_IFMT(mode) == S_IFLNK
 --- modulename: stat, funcname: S_IFMT
stat.py(25):     return mode & 0170000
posixpath.py(401):             path = newpath
posixpath.py(402):             continue
posixpath.py(385):     while rest:
posixpath.py(386):         name, _, rest = rest.partition(sep)
posixpath.py(387):         if not name or name == curdir:
posixpath.py(390):         if name == pardir:
posixpath.py(399):         newpath = join(path, name)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
posixpath.py(400):         if not islink(newpath):
 --- modulename: posixpath, funcname: islink
posixpath.py(134):     try:
posixpath.py(135):         st = os.lstat(path)
posixpath.py(138):     return stat.S_ISLNK(st.st_mode)
 --- modulename: stat, funcname: S_ISLNK
stat.py(56):     return S_IFMT(mode) == S_IFLNK
 --- modulename: stat, funcname: S_IFMT
stat.py(25):     return mode & 0170000
posixpath.py(401):             path = newpath
posixpath.py(402):             continue
posixpath.py(385):     while rest:
posixpath.py(386):         name, _, rest = rest.partition(sep)
posixpath.py(387):         if not name or name == curdir:
posixpath.py(390):         if name == pardir:
posixpath.py(399):         newpath = join(path, name)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
posixpath.py(400):         if not islink(newpath):
 --- modulename: posixpath, funcname: islink
posixpath.py(134):     try:
posixpath.py(135):         st = os.lstat(path)
posixpath.py(138):     return stat.S_ISLNK(st.st_mode)
 --- modulename: stat, funcname: S_ISLNK
stat.py(56):     return S_IFMT(mode) == S_IFLNK
 --- modulename: stat, funcname: S_IFMT
stat.py(25):     return mode & 0170000
posixpath.py(401):             path = newpath
posixpath.py(402):             continue
posixpath.py(385):     while rest:
posixpath.py(386):         name, _, rest = rest.partition(sep)
posixpath.py(387):         if not name or name == curdir:
posixpath.py(390):         if name == pardir:
posixpath.py(399):         newpath = join(path, name)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
posixpath.py(400):         if not islink(newpath):
 --- modulename: posixpath, funcname: islink
posixpath.py(134):     try:
posixpath.py(135):         st = os.lstat(path)
posixpath.py(138):     return stat.S_ISLNK(st.st_mode)
 --- modulename: stat, funcname: S_ISLNK
stat.py(56):     return S_IFMT(mode) == S_IFLNK
 --- modulename: stat, funcname: S_IFMT
stat.py(25):     return mode & 0170000
posixpath.py(401):             path = newpath
posixpath.py(402):             continue
posixpath.py(385):     while rest:
posixpath.py(386):         name, _, rest = rest.partition(sep)
posixpath.py(387):         if not name or name == curdir:
posixpath.py(390):         if name == pardir:
posixpath.py(399):         newpath = join(path, name)
 --- modulename: posixpath, funcname: join
posixpath.py(66):     path = a
posixpath.py(67):     for b in p:
posixpath.py(68):         if b.startswith('/'):
posixpath.py(70):         elif path == '' or path.endswith('/'):
posixpath.py(73):             path += '/' + b
posixpath.py(67):     for b in p:
posixpath.py(74):     return path
posixpath.py(400):         if not islink(newpath):
 --- modulename: posixpath, funcname: islink
posixpath.py(134):     try:
posixpath.py(135):         st = os.lstat(path)
posixpath.py(138):     return stat.S_ISLNK(st.st_mode)
 --- modulename: stat, funcname: S_ISLNK
stat.py(56):     return S_IFMT(mode) == S_IFLNK
 --- modulename: stat, funcname: S_IFMT
stat.py(25):     return mode & 0170000
posixpath.py(401):             path = newpath
posixpath.py(402):             continue
posixpath.py(385):     while rest:
posixpath.py(419):     return path, True
posixpath.py(376):     return abspath(path)
 --- modulename: posixpath, funcname: abspath
posixpath.py(360):     if not isabs(path):
 --- modulename: posixpath, funcname: isabs
posixpath.py(54):     return s.startswith('/')
posixpath.py(366):     return normpath(path)
 --- modulename: posixpath, funcname: normpath
posixpath.py(332):     slash, dot = (u'/', u'.') if isinstance(path, _unicode) else ('/', '.')
posixpath.py(333):     if path == '':
posixpath.py(335):     initial_slashes = path.startswith('/')
posixpath.py(338):     if (initial_slashes and
posixpath.py(339):         path.startswith('//') and not path.startswith('///')):
posixpath.py(341):     comps = path.split('/')
posixpath.py(342):     new_comps = []
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(345):             continue
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(351):     comps = new_comps
posixpath.py(352):     path = slash.join(comps)
posixpath.py(353):     if initial_slashes:
posixpath.py(354):         path = slash*initial_slashes + path
posixpath.py(355):     return path or dot
 --- modulename: posixpath, funcname: abspath
posixpath.py(360):     if not isabs(path):
 --- modulename: posixpath, funcname: isabs
posixpath.py(54):     return s.startswith('/')
posixpath.py(366):     return normpath(path)
 --- modulename: posixpath, funcname: normpath
posixpath.py(332):     slash, dot = (u'/', u'.') if isinstance(path, _unicode) else ('/', '.')
posixpath.py(333):     if path == '':
posixpath.py(335):     initial_slashes = path.startswith('/')
posixpath.py(338):     if (initial_slashes and
posixpath.py(339):         path.startswith('//') and not path.startswith('///')):
posixpath.py(341):     comps = path.split('/')
posixpath.py(342):     new_comps = []
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(345):             continue
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(344):         if comp in ('', '.'):
posixpath.py(346):         if (comp != '..' or (not initial_slashes and not new_comps) or
posixpath.py(348):             new_comps.append(comp)
posixpath.py(343):     for comp in comps:
posixpath.py(351):     comps = new_comps
posixpath.py(352):     path = slash.join(comps)
posixpath.py(353):     if initial_slashes:
posixpath.py(354):         path = slash*initial_slashes + path
posixpath.py(355):     return path or dot
files.py(151):     path = actual_path(path)
 --- modulename: files, funcname: actual_path
files.py(128):         return filename
files.py(152):     path = unicode_filename(path)
 --- modulename: files, funcname: unicode_filename
files.py(135):         if isinstance(filename, str):
files.py(138):         return filename
files.py(153):     return path
files.py(70):         CANONICAL_FILENAME_CACHE[filename] = cf
files.py(71):     return CANONICAL_FILENAME_CACHE[filename]
 --- modulename: plugin, funcname: __init__
plugin.py(205):         self.filename = filename
python.py(108):         if hasattr(morf, '__name__'):
python.py(113):             name = files.relative_filename(filename)
 --- modulename: files, funcname: relative_filename
files.py(47):     fnorm = os.path.normcase(filename)
 --- modulename: posixpath, funcname: normcase
posixpath.py(46):     return s
files.py(48):     if fnorm.startswith(RELATIVE_DIR):
files.py(50):     return unicode_filename(filename)
 --- modulename: files, funcname: unicode_filename
files.py(135):         if isinstance(filename, str):
files.py(138):         return filename
python.py(114):         self.relname = name
python.py(116):         self._source = None
python.py(117):         self._parser = None
python.py(118):         self._statements = None
python.py(119):         self._excluded = None
control.py(361):         return os.path.split(morf_filename)[0]
 --- modulename: posixpath, funcname: split
posixpath.py(85):     i = p.rfind('/') + 1
posixpath.py(86):     head, tail = p[:i], p[i:]
posixpath.py(87):     if head and head != '/'*len(head):
posixpath.py(88):         head = head.rstrip('/')
posixpath.py(89):     return head, tail
control.py(311):         if env.TESTING:
control.py(320):         Numbers.set_precision(self.config.precision)
 --- modulename: results, funcname: set_precision
results.py(196):         assert 0 <= precision < 10
results.py(197):         cls._precision = precision
results.py(198):         cls._near0 = 1.0 / 10**precision
results.py(199):         cls._near100 = 100.0 - cls._near0
control.py(322):         atexit.register(self._atexit)
 --- modulename: atexit, funcname: register
atexit.py(46):     _exithandlers.append((func, targs, kargs))
atexit.py(47):     return func
control.py(324):         self._inited = True
control.py(327):         if self.source or self.source_pkgs:
control.py(331):             if self.cover_dirs:
control.py(332):                 self.cover_match = TreeMatcher(self.cover_dirs)
 --- modulename: files, funcname: __init__
files.py(188):         self.dirs = list(directories)
control.py(333):             if self.pylib_dirs:
control.py(334):                 self.pylib_match = TreeMatcher(self.pylib_dirs)
 --- modulename: files, funcname: __init__
files.py(188):         self.dirs = list(directories)
control.py(335):         if self.include:
control.py(337):         if self.omit:
control.py(341):         wrote_any = False
control.py(342):         if self.debug.should('config'):
 --- modulename: debug, funcname: should
debug.py(37):         return (option in self.options or option in FORCED_DEBUG)
control.py(347):         if self.debug.should('sys'):
 --- modulename: debug, funcname: should
debug.py(37):         return (option in self.options or option in FORCED_DEBUG)
control.py(355):         if wrote_any:
control.py(678):         if self.run_suffix:
control.py(682):         if self._auto_data:
control.py(685):         self.collector.start()
 --- modulename: collector, funcname: start
collector.py(236):         if self._collectors:
collector.py(241):         traces0 = []
collector.py(242):         fn0 = sys.gettrace()
collector.py(243):         if fn0:
collector.py(244):             tracer0 = getattr(fn0, '__self__', None)
collector.py(245):             if tracer0:
collector.py(246):                 traces0 = getattr(tracer0, 'traces', [])
collector.py(248):         try:
collector.py(250):             fn = self._start_tracer()
 --- modulename: collector, funcname: _start_tracer
collector.py(187):         tracer = self._trace_class()
collector.py(188):         tracer.data = self.data
collector.py(189):         tracer.trace_arcs = self.branch
collector.py(190):         tracer.should_trace = self.should_trace
collector.py(191):         tracer.should_trace_cache = self.should_trace_cache
collector.py(192):         tracer.warn = self.warn
collector.py(194):         if hasattr(tracer, 'concur_id_func'):
collector.py(195):             tracer.concur_id_func = self.concur_id_func
collector.py(203):         if hasattr(tracer, 'file_tracers'):
collector.py(204):             tracer.file_tracers = self.file_tracers
collector.py(205):         if hasattr(tracer, 'threading'):
collector.py(207):         if hasattr(tracer, 'check_include'):
collector.py(208):             tracer.check_include = self.check_include
collector.py(210):         fn = tracer.start()
